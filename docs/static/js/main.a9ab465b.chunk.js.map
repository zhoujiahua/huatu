{"version":3,"sources":["constants.ts","analytics.ts","css/variables.module.scss","locales lazy /^/.//.*/.json$/ groupOptions: {} namespace object","i18n.ts","colors.ts","keys.ts","utils.ts","appState.ts","hooks/useCallbackRefState.ts","element/typeChecks.ts","math.ts","points.ts","element/bounds.ts","renderer/renderElement.ts","scene/Scene.ts","random.ts","element/mutateElement.ts","element/sizeHelpers.ts","groups.ts","element/newElement.ts","element/transformHandles.ts","ga.ts","galines.ts","gapoints.ts","gadirections.ts","gatransforms.ts","element/collision.ts","element/resizeTest.ts","element/linearElementEditor.ts","element/binding.ts","element/resizeElements.ts","element/dragElements.ts","element/textWysiwyg.tsx","element/textElement.ts","element/showSelectedShapeActions.ts","element/index.ts","scene/scrollbars.ts","scene/selection.ts","scene/scroll.ts","scene/comparisons.ts","scene/zoom.ts","components/ToolButton.tsx","components/icons.tsx","actions/register.ts","actions/actionDeleteSelected.tsx","zindex.ts","actions/actionZindex.tsx","actions/actionSelectAll.ts","actions/actionDuplicateSelection.tsx","components/ButtonIconSelect.tsx","components/Popover.tsx","components/ColorPicker.tsx","components/IconPicker.tsx","actions/actionProperties.tsx","components/DarkModeToggle.tsx","actions/actionCanvas.tsx","actions/actionFinalize.tsx","components/ProjectName.tsx","components/Tooltip.tsx","clients.ts","types.ts","renderer/renderScene.ts","renderer/roundRect.ts","errors.ts","data/restore.ts","data/blob.ts","data/json.ts","scene/export.ts","charts.ts","clipboard.ts","data/index.ts","components/CheckboxItem.tsx","components/Stack.tsx","components/ActiveFile.tsx","actions/actionExport.tsx","actions/actionStyles.ts","components/HelpIcon.tsx","actions/actionGroup.tsx","actions/actionMenu.tsx","components/Avatar.tsx","actions/actionAddToLibrary.ts","actions/actionNavigate.tsx","align.ts","actions/actionAlign.tsx","disitrubte.ts","actions/actionDistribute.tsx","actions/actionFlip.ts","actions/actionClipboard.tsx","actions/actionToggleGridMode.tsx","actions/actionToggleZenMode.tsx","actions/actionToggleStats.tsx","actions/actionHistory.tsx","actions/manager.tsx","data/library.ts","gesture.ts","history.ts","shapes.tsx","actions/shortcuts.ts","components/ContextMenu.tsx","components/Actions.tsx","components/BackgroundPickerAndDarkModeToggle.tsx","components/CollabButton.tsx","components/ImageExportDialog.tsx","components/FixedSideContainer.tsx","components/HintViewer.tsx","components/Island.tsx","components/LibraryUnit.tsx","components/LoadingMessage.tsx","components/LockButton.tsx","components/Section.tsx","components/UserList.tsx","components/LibraryButton.tsx","components/MobileMenu.tsx","components/PasteChartDialog.tsx","components/HelpDialog.tsx","components/Card.tsx","components/JSONExportDialog.tsx","components/LayerUI.tsx","components/Stats.tsx","components/Toast.tsx","actions/actionToggleViewMode.tsx","components/App.tsx","components/Modal.tsx","components/Dialog.tsx","components/ErrorDialog.tsx","components/TopErrorBoundary.tsx","packages/excalidraw/publicPath.js","components/InitializeApp.tsx","packages/utils.ts","packages/excalidraw/index.tsx","excalidraw-app/app_constants.ts","excalidraw-app/data/index.ts","excalidraw-app/data/firebase.ts","excalidraw-app/data/localStorage.ts","excalidraw-app/collab/Portal.tsx","excalidraw-app/collab/RoomDialog.tsx","createInverseContext.tsx","excalidraw-app/collab/CollabWrapper.tsx","excalidraw-app/components/LanguageList.tsx","excalidraw-app/CustomStats.tsx","excalidraw-app/components/icons.tsx","excalidraw-app/components/ExportToExcalidrawPlus.tsx","excalidraw-app/index.tsx","serviceWorker.tsx","excalidraw-app/pwa.ts","excalidraw-app/sentry.ts","index.tsx"],"names":["APP_NAME","DRAGGING_THRESHOLD","LINE_CONFIRM_THRESHOLD","ELEMENT_SHIFT_TRANSLATE_AMOUNT","ELEMENT_TRANSLATE_AMOUNT","TEXT_TO_CENTER_SNAP_THRESHOLD","SHIFT_LOCKING_ANGLE","Math","PI","CURSOR_TYPE","TEXT","CROSSHAIR","GRABBING","POINTER","MOVE","AUTO","POINTER_BUTTON","MAIN","WHEEL","SECONDARY","TOUCH","EVENT","ENV","TEST","DEVELOPMENT","CLASSES","SHAPE_ACTIONS_MENU","FONT_FAMILY","Virgil","Helvetica","Cascadia","WINDOWS_EMOJI_FALLBACK_FONT","DEFAULT_FONT_SIZE","DEFAULT_FONT_FAMILY","DEFAULT_TEXT_ALIGN","DEFAULT_VERTICAL_ALIGN","DEFAULT_VERSION","GRID_SIZE","MIME_TYPES","excalidraw","excalidrawlib","EXPORT_DATA_TYPES","excalidrawClipboard","excalidrawLibrary","EXPORT_SOURCE","window","location","origin","STORAGE_KEYS","LOCAL_STORAGE_LIBRARY","TAP_TWICE_TIMEOUT","TOUCH_CTX_MENU_TIMEOUT","TITLE_TIMEOUT","TOAST_TIMEOUT","VERSION_TIMEOUT","SCROLL_TIMEOUT","ZOOM_STEP","IDLE_THRESHOLD","ACTIVE_THRESHOLD","MODES","VIEW","ZEN","GRID","THEME_FILTER","cssVariables","themeFilter","URL_QUERY_KEYS","addLibrary","URL_HASH_KEYS","DEFAULT_UI_OPTIONS","canvasActions","changeViewBackgroundColor","clearCanvas","export","saveFileToDisk","loadScene","saveToActiveFile","theme","saveAsImage","MQ_MAX_WIDTH_PORTRAIT","MQ_MAX_WIDTH_LANDSCAPE","MQ_MAX_HEIGHT_LANDSCAPE","MAX_DECIMALS_FOR_SVG_EXPORT","EXPORT_SCALES","DEFAULT_EXPORT_PADDING","trackEvent","process","REACT_APP_GOOGLE_ANALYTICS_ID","gtag","category","name","label","value","event_category","event_label","JEST_WORKER_ID","module","exports","map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","e","Error","code","ids","id","all","slice","t","keys","Object","defaultLang","languages","rtl","concat","sort","left","right","filter","lang","percentages","TEST_LANG_CODE","unshift","currentLang","currentLangData","setLanguage","async","document","documentElement","dir","startsWith","getLanguage","findPartsForData","data","parts","index","length","part","undefined","path","replacement","JSON","stringify","split","translation","fallbackLangData","key","replace","shades","oc","red","pink","grape","violet","indigo","blue","cyan","teal","green","lime","yellow","orange","canvasBackground","white","gray","elementBackground","elementStroke","black","isDarwin","test","navigator","platform","isWindows","CODES","KEYS","isArrowKey","getResizeCenterPointKey","event","altKey","getResizeWithSidesSameLengthKey","shiftKey","getRotateWithDiscreteAngleKey","SVG_NS","mockDateTime","getDateTime","date","Date","year","getFullYear","month","getMonth","padStart","day","getDate","hr","getHours","min","getMinutes","capitalizeString","str","charAt","toUpperCase","isWritableElement","target","HTMLElement","dataset","type","HTMLBRElement","HTMLTextAreaElement","HTMLInputElement","getFontFamilyString","fontFamily","fontFamilyString","entries","getFontString","fontSize","measureText","text","font","line","createElement","body","style","position","whiteSpace","appendChild","innerText","x","join","width","offsetWidth","height","offsetHeight","span","display","overflow","baseline","offsetTop","removeChild","debounce","fn","timeout","handle","lastArgs","ret","args","clearTimeout","setTimeout","flush","_lastArgs","cancel","distance","y","abs","resetCursor","canvas","cursor","setCursor","setCursorForShape","shape","isFullScreen","fullscreenElement","nodeName","getShortcutKey","shortcut","viewportCoordsToSceneCoords","clientX","clientY","zoom","offsetLeft","scrollX","scrollY","invScale","sceneCoordsToViewportCoords","sceneX","sceneY","getGlobalCSSVariable","getComputedStyle","getPropertyValue","RE_RTL_CHECK","RegExp","isRTL","tupleToCoors","xyTuple","muteFSAbortError","error","resolvablePromise","reject","promise","_resolve","_reject","withBatchedUpdates","func","unstable_batchedUpdates","nFormatter","num","digits","si","symbol","toFixed","getVersion","querySelector","content","defaultExportScale","includes","devicePixelRatio","getDefaultAppState","collaborators","Map","currentChartType","currentItemBackgroundColor","currentItemEndArrowhead","currentItemFillStyle","currentItemFontFamily","currentItemFontSize","currentItemLinearStrokeSharpness","currentItemOpacity","currentItemRoughness","currentItemStartArrowhead","currentItemStrokeColor","currentItemStrokeSharpness","currentItemStrokeStyle","currentItemStrokeWidth","currentItemTextAlign","cursorButton","draggingElement","editingElement","editingGroupId","editingLinearElement","elementLocked","elementType","errorMessage","exportBackground","exportScale","exportEmbedScene","exportWithDarkMode","fileHandle","gridSize","isBindingEnabled","isLibraryOpen","isLoading","isResizing","isRotating","lastPointerDownWith","multiElement","openMenu","openPopup","pasteDialog","shown","previousSelectedElementIds","resizingElement","scrolledOutside","selectedElementIds","selectedGroupIds","selectionElement","shouldCacheIgnoreZoom","showHelpDialog","showStats","startBoundElement","suggestedBindings","toastMessage","viewBackgroundColor","zenModeEnabled","viewModeEnabled","APP_STATE_STORAGE_CONF","browser","_clearAppStateForStorage","appState","exportType","stateForExport","propConfig","clearAppStateForLocalStorage","cleanAppStateForExport","useCallbackRefState","refValue","setRefValue","useState","useCallback","isTextElement","element","isFreeDrawElement","isFreeDrawElementType","isLinearElement","isLinearElementType","isBindingElement","isBindingElementType","isBindableElement","rotate","x1","y1","x2","y2","angle","cos","sin","rotatePoint","point","center","adjustXYWithRotation","sides","deltaX1","deltaY1","deltaX2","deltaY2","w","n","s","distance2d","xd","yd","hypot","isPathALoop","points","zoomValue","first","last","isPointInPolygon","vertices","extreme","Number","MAX_SAFE_INTEGER","p","count","i","current","next","doSegmentsIntersect","orderedColinearOrientation","isPointWithinBounds","q","r","max","val","p1","q1","p2","q2","o1","o2","o3","o4","getGridPoint","round","getSizeFromPoints","xs","ys","rescalePoints","dimension","nextDimensionSize","prevPoints","prevDimValues","prevMaxDimension","prevMinDimension","prevDimensionSize","dimensionScaleFactor","nextMinDimension","Infinity","scaledPoints","prevPoint","currentDimension","scaledValue","scaledPoint","getElementAbsoluteCoords","getFreeDrawElementAbsoluteCoords","getLinearElementAbsoluteCoords","getCurvePathOps","set","sets","ops","getMinMaxXYFromCurvePathOps","transformXY","currentP","minX","minY","maxX","maxY","reduce","limits","op","p3","p0","equation","idx","pow","getBoundsFromPoints","coords","getShapeForElement","getElementBounds","bounds","cx","cy","getLinearElementRotatedBounds","x11","y11","x12","y12","x22","y22","x21","y21","h","ww","hh","getCommonBounds","elements","forEach","getResizedElementAbsoluteCoords","nextWidth","nextHeight","gen","rough","generator","curve","strokeSharpness","linearPath","generateRoughOptions","getElementPointsCoords","sharpness","defaultAppState","getDashArrayDotted","strokeWidth","getCanvasPadding","drawElementOnCanvas","rc","context","globalAlpha","opacity","lineJoin","lineCap","draw","save","fillStyle","strokeColor","pathsCache","get","getFreeDrawPath2D","fill","restore","shouldTemporarilyAttach","isConnected","setAttribute","textAlign","lines","lineHeight","verticalOffset","horizontalOffset","fillText","remove","elementWithCanvasCache","WeakMap","shapeCache","invalidateShapeForElement","delete","continuousPath","options","seed","strokeLineDash","strokeStyle","disableMultiStroke","fillWeight","hachureGap","roughness","stroke","preserveVertices","backgroundColor","curveFitting","generateElementShape","rectangle","topX","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","floor","getDiamondPoints","polygon","ellipse","startArrowhead","endArrowhead","getArrowheadShapes","arrowhead","arrowheadPoints","prevOp","nx","ny","size","arrow","bar","dot","px","py","minSize","x3","y3","x4","y4","getArrowheadPoints","circle","dash","shapes","push","generateFreeDrawShape","generateElementWithCanvas","sceneState","prevElementWithCanvas","shouldRegenerateBecauseZoom","canvasZoom","elementWithCanvas","getContext","padding","canvasOffsetX","canvasOffsetY","ceil","translate","scale","generateElementCanvas","drawElementFromCanvas","drawImage","renderElement","renderOptimizations","fillRect","shiftX","shiftY","roughSVGDrawWithPrecision","rsvg","drawable","precision","pshape","fixedDecimalPlaceDigits","svgPathData","getFreeDrawSvgPath","Path2D","inputPoints","simulatePressure","pressures","thinning","smoothing","streamline","easing","getFreeDrawShape","d","isIdKey","elementKey","Scene","callbacks","Set","nonDeletedElements","elementsMap","scene","this","sceneMapById","sceneMapByElement","getElementsIncludingDeleted","getElements","getElement","getNonDeletedElement","isNonDeletedElement","getNonDeletedElements","result","replaceAllElements","nextElements","clear","mapElementToScene","informMutation","callback","Array","from","addCallback","cb","has","add","destroy","random","Random","now","randomInteger","randomId","nanoid","mutateElement","updates","didChange","nextPoints","didChangePoints","nextPoint","version","versionNonce","getScene","newElementWith","bumpVersion","isInvisiblySmallElement","getPerfectElementSize","absWidth","absHeight","lockedAngle","atan","tan","sign","getNormalizedDimensions","selectGroup","groupId","elementsInGroup","groupIds","fromEntries","isSelectedViaGroup","getSelectedGroupForElement","find","getSelectedGroupIds","isSelected","selectGroupsForSelectedElements","nextAppState","selectedElements","getSelectedElements","selectedElement","indexOfEditingGroup","indexOf","isElementInGroup","getElementsInGroup","addToGroup","prevGroupIds","newGroupId","positionOfEditingGroupId","positionToInsert","splice","_newElementBase","boundElementIds","rest","isDeleted","newElement","opts","getTextElementPositionOffsets","metrics","verticalAlign","newTextElement","offsets","getAdjustedDimensions","nextText","nextBaseline","prevMetrics","nextX1","nextY1","nextX2","nextY2","isFinite","newLinearElement","lastCommittedPoint","startBinding","endBinding","deepCopyElement","depth","prototype","toString","call","tmp","constructor","create","getPrototypeOf","hasOwnProperty","isArray","k","arr","duplicateElement","groupIdMapForOperation","overrides","copy","mapper","endIndex","getNewGroupIdsForDuplication","assign","transformHandleSizes","mouse","pen","touch","OMIT_SIDES_FOR_MULTIPLE_ELEMENTS","OMIT_SIDES_FOR_TEXT_ELEMENT","OMIT_SIDES_FOR_LINE_SLASH","nw","se","OMIT_SIDES_FOR_LINE_BACKSLASH","ne","sw","generateTransformHandle","xx","yy","getTransformHandlesFromCoords","pointerType","omitSides","handleWidth","handleHeight","handleMarginX","handleMarginY","dashedLineMargin","centeringOffset","transformHandles","rotation","minimumSizeForEightHandles","getTransformHandles","nvector","reverse","a","b","isNumber","sub","mul","mulScalar","meet","joinScalar","norm","sqrt","inorm","normalized","inormalized","c","GA","through","to","orthogonal","toTuple","intersect","line1","line2","point1","point2","distanceToLine","pivot","apply","motor","isHittingElementBoundingBoxWithoutHittingElement","threshold","isHittingElementNotConsideringBoundingBox","isPointHittingElementBoundingBox","check","isStrictlyInside","isDraggableFromInside","isElementDraggableFromInside","isInsideCheck","isNearCheck","hitTestPointAgainstElement","isElementSelected","elementCenterX","elementCenterY","rotatedX","rotatedY","bindingBorderTest","maxBindingGap","isOutsideCheck","elementWidth","elementHeight","smallerDimension","distanceToBindableElement","distanceToRectangle","hitTestFreeDrawElement","hitTestLinear","console","warn","distanceToDiamond","distanceToEllipse","pointRel","hwidth","hheight","pointRelativeToElement","GAPoint","GALine","side","tangent","ellipseParamsForTest","tx","ty","_","ex","ey","rx","ry","qx","qy","closestPoint","intersection","rotatedPoint","P","A","B","delta","U","C","da","db","pointAbs","side1","side2","relX","relY","some","subshape","hitTestCurveInside","hitTestRoughShape","pointTuple","elementCoords","coordsCenter","GATransform","pointRotated","pointRelToCenterAbs","GADirection","elementPos","pointRelToPos","ax","ay","bx","by","relativizationToElementCenter","direction","determineFocusDistance","relateToCenter","aRel","bRel","m","mabs","nabs","getSortedElementLineIntersections","nearPoint","gap","intersections","corners","getCorners","flatMap","edge","intersectSegment","offsetSegment","getCircleIntersections","getEllipseIntersections","sortedIntersections","i1","i2","hx","hy","segment","offset","squares","discr","discrRoot","xn","yn","radius","findFocusPointForEllipse","relativeDistance","relativeDistanceAbs","orientation","pyo","findFocusPointForRectangulars","maxDistance","tangentPoint","corner","odd","operation","polygonPoints","pointsOnBezierCurves","lineThreshold","mx","my","pointInBezierEquation","isInsideTransformHandle","transformHandle","getElementWithTransformHandleType","scenePointerX","scenePointerY","transformHandleType","rotationTransformHandle","resizeTest","getTransformHandleTypeFromCoords","RESIZE_CURSORS","getCursorForResizingElement","shouldSwapCursors","rotateResizeCursor","LinearElementEditor","elementId","activePointIndex","isDragging","lastUncommittedPoint","pointerOffset","startBindingElement","endBindingElement","normalizePoints","setState","maybeSuggestBinding","newPoint","createPointAt","movePoint","binding","getHoveredElementForBinding","getPointAtIndexGlobalCoordinates","history","scenePointer","didAddPoint","hitElement","resumeRecording","clickedPointIndex","getPointIndexUnderCursor","bindOrUnbindLinearElement","targetPoint","lastPoint","indexMaybeFromEnd","absoluteCoords","pointHandles","getPointsGlobalCoordinates","POINT_HANDLE_SIZE","pointerOnGrid","offsetX","offsetY","_idx","getNormalizedPoints","pointIndex","targetPosition","otherUpdates","deltaX","deltaY","nextCoords","prevCoords","nextCenterX","nextCenterY","prevCenterX","prevCenterY","rotated","linearElement","boundToElementIds","unboundFromElementIds","bindOrUnbindLinearElementEdge","onlyUnbound","bindableElement","otherEdgeBindableElement","startOrEnd","isLinearElementSimpleAndAlreadyBoundOnOppositeEdge","bindLinearElement","unbound","unbindLinearElement","bindOrUnbindSelectedElements","getElligibleElementForBindingElement","maybeBindBindableElement","getElligibleElementsForBindableElementAndWhere","where","maybeBindLinearElement","pointerCoords","hoveredElement","calculateFocusAndGap","otherBinding","isLinearElementSimpleAndAlreadyBound","alreadyBoundToId","unbindLinearElements","field","getElementAtPosition","edgePointIndex","adjacentPointIndex","edgePoint","adjacentPoint","focus","updateBoundElements","changedElement","newSize","simultaneouslyUpdated","simultaneouslyUpdatedElementIds","getSimultaneouslyUpdatedElementIds","doesNeedUpdate","maybeCalculateNewGapWhenScaling","updateBoundPoint","boundElement","bindingElement","focusPointAbsolute","adjecentPoint","adjecentPointRel","reverseRelateToCenter","determineFocusPoint","newEdgePoint","intersectElementWithLine","pointFromAbsoluteCoords","currentBinding","newWidth","newHeight","getElligibleElementsForBindingElement","getLinearElementEdgeCoors","canBindStart","isLinearElementEligibleForNewBindingByBindable","canBindEnd","maybeElement","fixBindingsAfterDuplication","sceneElements","oldElements","oldIdToDuplicatedId","duplicatesServeAsOld","allBoundElementIds","allBindableElementIds","shouldReverseRoles","oldElement","boundElementId","newBindingAfterDuplication","fixBindingsAfterDeletion","deletedElements","deletedElementIds","deletedElement","newBindingAfterDeletion","normalizeAngle","rotateSingleElement","pointerX","pointerY","isRotateWithDiscreteAngle","atan2","reshapeSingleTwoPointElement","resizeArrowDirection","getPerfectElementSizeWithRotation","nextElementX","nextElementY","rescalePointsInElement","measureFontSizeFromWH","nextFontSize","resizeSingleTextElement","isResizeFromCenter","nextFont","getSidesForTransformHandle","resizeSingleElement","stateAtResizeStart","shouldKeepSidesRatio","transformHandleDirection","startTopLeft","startBottomRight","startCenter","rotatedPointer","esx1","esy1","esx2","esy2","boundsCurrentWidth","boundsCurrentHeight","scaleX","scaleY","eleInitialWidth","eleInitialHeight","eleNewWidth","eleNewHeight","widthRatio","heightRatio","ratio","newBoundsX1","newBoundsY1","newBoundsX2","newBoundsY2","newBoundsWidth","newBoundsHeight","newTopLeft","bottomLeft","topRight","rotatedTopLeft","newCenter","rotatedNewCenter","rescaledPoints","newOrigin","resizedElement","resizeMultipleElements","getNextXY","origX1","origY1","finalX1","finalY1","origX2","origY2","finalX2","finalY2","prev","origCoords","finalCoords","rotateMultipleElements","pointerDownState","centerX","centerY","centerAngle","origAngle","originalElements","rotatedCX","rotatedCY","dragNewElement","originX","originY","isResizeWithSidesSameLength","isResizeCenterPoint","newX","newY","normalizeText","getTransform","maxWidth","degree","translateX","translateY","redrawTextBoundingBox","showSelectedShapeActions","Boolean","getElementMap","acc","getSceneVersion","el","_clearElements","clearElementsForExport","clearElementsForLocalStorage","isOverScrollBars","scrollBars","isOverHorizontal","isOverVertical","horizontal","vertical","scrollBar","isOverEither","isSomeElementSelected","getTargetElements","centerScrollOn","scenePoint","viewportDimensions","calculateScrollCenter","getVisibleElements","cords","viewportX1","viewportY1","viewportX2","viewportY2","isOutsideViewPort","minDistance","closestElement","getClosestElementBounds","hasBackground","hasStrokeWidth","hasStrokeStyle","canChangeSharpness","hasText","canHaveArrowheads","isAtPositionFn","getNewZoom","newZoomValue","prevZoom","canvasOffset","zoomOnViewportPoint","top","getNormalizedZoom","normalizedZoom","parseFloat","ToolButton","React","forwardRef","props","ref","excalId","useExcalidrawContainer","innerRef","useRef","useImperativeHandle","sizeCn","className","clsx","visible","hidden","ToolIcon","selected","data-testid","title","aria-label","onClick","icon","aria-hidden","keyBindingLabel","showAriaLabel","children","aria-keyshortcuts","onChange","checked","defaultProps","activeElementColor","iconFillColor","handlerColor","createIcon","mirror","focusable","role","viewBox","checkIcon","link","saveAs","load","clipboard","trash","palette","exportFile","exportImage","exportToFileIcon","zoomIn","zoomOut","done","menu","undo","redo","questionCircle","share","shareIOS","shareWindows","resetZoom","BringForwardIcon","memo","SendBackwardIcon","BringToFrontIcon","SendToBackIcon","AlignTopIcon","strokeLinecap","AlignBottomIcon","AlignLeftIcon","AlignRightIcon","DistributeHorizontallyIcon","DistributeVerticallyIcon","CenterVerticallyIcon","strokeDasharray","CenterHorizontallyIcon","users","start","stop","close","back","marginLeft","clone","shield","file","GroupIcon","UngroupIcon","FillHachureIcon","fillRule","clipRule","FillCrossHatchIcon","FillSolidIcon","StrokeWidthIcon","StrokeStyleSolidIcon","StrokeStyleDashedIcon","StrokeStyleDottedIcon","SloppinessArchitectIcon","SloppinessArtistIcon","SloppinessCartoonistIcon","EdgeSharpIcon","EdgeRoundIcon","ArrowheadNoneIcon","ArrowheadArrowIcon","flip","transform","ArrowheadDotIcon","ArrowheadBarIcon","FontSizeSmallIcon","FontSizeMediumIcon","FontSizeLargeIcon","FontSizeExtraLargeIcon","FontFamilyHandDrawnIcon","FontFamilyNormalIcon","FontFamilyCodeIcon","TextAlignLeftIcon","TextAlignCenterIcon","TextAlignRightIcon","actions","register","action","handleGroupEditingState","siblingElements","actionDeleteSelected","perform","commitToHistory","deleteSelectedElements","contextItemLabel","keyTest","PanelComponent","updateData","getIndicesToMove","selectedIndices","deletedIndices","includeDeletedIndex","getTargetIndex","boundaryIndex","sourceElement","indexFilter","candidateIndex","array","fromIndex","findLastIndex","findIndex","nextElement","siblingGroupId","elementsInSiblingGroup","getTargetElementsMap","indices","shiftElements","indicesToMove","targetElementsMap","groupedIndices","toContiguousGroups","leadingIndex","trailingIndex","targetIndex","leadingElements","targetElements","displacedElements","trailingElements","shiftElementsToEnd","groupElements","values","moveOneLeft","moveOneRight","moveAllLeft","moveAllRight","actionSendBackward","keyPriority","actionBringForward","actionSendToBack","actionBringToFront","actionSelectAll","actionDuplicateSelection","selectedPoint","duplicateElements","groupIdMap","newElements","duplicateAndOffsetElement","finalElements","ButtonIconSelect","group","option","active","Popover","onCloseRequest","fitInViewport","popoverRef","useLayoutEffect","getBoundingClientRect","viewportWidth","innerWidth","viewportHeight","innerHeight","useEffect","handler","contains","addEventListener","removeEventListener","isValidColor","color","Option","keyBindings","flat","Picker","colors","onClose","showInput","firstItem","activeItem","gallery","colorInput","aria-modal","onKeyDown","activeElement","preventDefault","nextIndex","toLowerCase","nativeEvent","stopImmediatePropagation","stopPropagation","tabIndex","_color","currentTarget","onFocus","ColorInput","innerValue","setInnerValue","inputRef","changeColor","inputValue","getColor","spellCheck","onBlur","ColorPicker","isActive","setActive","pickerButton","Suspense","fallback","changedColor","rFirstItem","rActiveItem","rGallery","pressedOption","keyBinding","metaKey","ctrlKey","IconPicker","rPickerButton","changeProperty","getFormValue","getAttribute","defaultValue","attributes","getCommonAttributeOfSelectedElements","DarkModeToggle","step","onWheel","shouldUpdateForNonLinearElements","every","shouldUpdateForLinearElements","ICONS","MOON","SUN","zoomToFitElements","useIsMobile","confirm","_elements","zoomToSelection","commonBounds","commonBoundsWidth","zoomValueForWidth","commonBoundsHeight","zoomValueForHeight","smallestZoomValue","zoomAdjustedToSteps","zoomValueToFitBoundsOnViewport","newZoom","actionFinalize","marginInlineStart","focusContainer","multiPointElement","isLoop","linePoints","firstPoint","ProjectName","fileName","setFileName","htmlFor","isNameEditable","parent","parentElement","focusNearestParent","isComposing","keyCode","blur","getTooltipDiv","existingDiv","div","classList","Tooltip","long","onPointerEnter","item","tooltip","minWidth","textContent","itemX","bottom","itemBottom","itemTop","itemWidth","labelWidth","labelHeight","margin","updateTooltip","onPointerLeave","getClientColors","clientId","currentUser","sum","charCodeAt","backgrounds","strokes","background","UserIdleState","hasEmojiSupport","ctx","textBaseline","getImageData","supportsEmoji","strokeRectWithRotation","strokeRect","fillCircle","beginPath","arc","renderScene","renderScrollbars","renderSelection","renderGrid","atLeastOneVisibleElement","normalizedCanvasWidth","normalizedCanvasHeight","clearRect","zoomTranslationX","zoomTranslationY","origStrokeStyle","moveTo","lineTo","strokeGrid","visibleElements","isVisibleElement","lineWidth","setLineDash","renderLinearPointHandles","suggestedBinding","renderBindingHighlight","selections","selectionColors","remoteSelectedElementIds","socketId","elementX1","elementY1","elementX2","elementY2","addSelectionForGroupId","selection","renderSelectionBorder","locallySelectedElements","renderTransformHandles","dashedLinePadding","initialLineDash","getLineDash","remotePointerViewportCoords","isOutOfBounds","userState","remotePointerUserStates","AWAY","remotePointerButton","closePath","username","remotePointerUsernames","idleState","IDLE","ACTIVE","usernameAndIdleState","paddingHorizontal","paddingVertical","measure","measureHeight","actualBoundingBoxDescent","actualBoundingBoxAscent","elementsMinX","elementsMinY","elementsMaxX","elementsMaxY","viewportWidthWithZoom","viewportHeightWithZoom","viewportWidthDiff","viewportHeightDiff","safeArea","parseInt","viewportMinX","viewportMinY","viewportMaxX","viewportMaxY","sceneMinX","sceneMinY","sceneMaxX","sceneMaxY","SCROLLBAR_MARGIN","getScrollBars","quadraticCurveTo","roundRect","SCROLLBAR_WIDTH","elementProperties","lineDashOffset","dashWidth","spaceWidth","originalStrokeStyle","originalLineWidth","renderHighlight","renderBindingHighlightForSuggestedPointBinding","renderBindingHighlightForBindableElement","strokeOffset","strokeDiamondWithRotation","strokeEllipseWithRotation","canvasWidth","canvasHeight","viewTransformations","topLeftSceneCoords","bottomRightSceneCoords","renderSceneToSvg","svgRoot","node","ownerDocument","createElementNS","textAnchor","renderElementToSvg","CanvasError","message","super","AllowedExcalidrawElementTypes","diamond","freedraw","restoreElementWithProperties","extra","base","restoreElement","fontFamilyName","fontPx","_fontFamily","restoreElements","localElements","localElementsMap","migratedElement","localElement","restoreAppState","localAppState","suppliedValue","localValue","parseFileContents","contents","blob","decodePngMetadata","Blob","reader","FileReader","readAsText","onloadend","readyState","DONE","decodeSvgMetadata","svg","loadFromBlob","parse","isValidExcalidrawData","canvasToBlob","toBlob","serializeAsJSON","source","saveAsJSON","serialized","fileSave","description","extensions","SVG_EXPORT_TAG","exportToCanvas","exportPadding","createCanvas","getCanvasSize","exportToSvg","metadata","encodeSvgMetadata","err","innerHTML","rect","BAR_WIDTH","BAR_GAP","BAR_HEIGHT","NOT_SPREADSHEET","VALID_SPREADSHEET","tryParseNumber","match","exec","isNumericColumn","columnIndex","tryParseCells","cells","numCols","reason","hasHeader","spreadsheet","labels","valueColumnIndex","labelColumnIndex","rows","row","bgColors","commonProps","getChartDimentions","chartWidth","chartHeight","chartXLabels","chartYLabels","minYLabel","toLocaleString","chartLines","chartBaseElements","debug","debugRect","renderSpreadsheet","chartType","dots","chartTypeLine","barHeight","chartTypeBar","CLIPBOARD","PREFER_APP_CLIPBOARD","probablySupportsClipboardReadText","probablySupportsClipboardWriteText","probablySupportsClipboardBlob","HTMLCanvasElement","copyToClipboard","json","copyTextToSystemClipboard","getAppClipboard","parsePotentialSpreadsheet","trim","numColsFirstLine","transposedResults","nextCells","col","nextCellRow","transposeCells","tryParseSpreadsheet","parseClipboard","systemClipboard","clipboardData","getData","readText","getSystemClipboard","spreadsheetResult","appClipboardData","systemClipboardData","copied","writeText","copyTextViaExecCommand","textarea","border","yPosition","pageYOffset","scrollTop","success","select","setSelectionRange","execCommand","exportCanvas","tempSvg","outerHTML","tempCanvas","encodePngMetadata","write","ClipboardItem","copyBlobToClipboardAsPng","CheckboxItem","aria-checked","align","justifyContent","alignItems","justifyItems","ActiveFile","onSave","actionSaveFileToDisk","appProps","allElements","exportedElements","trunc","getExportSize","scaleButtonTitle","fileHandleExists","fsSupported","loadedElements","loadedAppState","fileOpen","loadFromJSON","marginTop","marginBottom","copiedStyles","actionCopyStyles","actionPasteStyles","pastedElement","HelpIcon","enableActionGroup","requestFullscreen","exitFullscreen","allElementsInSameGroup","actionGroup","selectedGroupId","elementIdsInGroup","updatedElements","lastElementInGroup","lastGroupElementIndex","lastIndexOf","elementsAfterGroup","updatedElementsInOrder","updatedElement","contextItemPredicate","actionUngroup","nextGroupIds","removeFromSelectedGroups","Avatar","actionAddToLibrary","collaborator","shortName","names","substring","firstName","lastName","getClientInitials","pointer","app","library","loadLibrary","items","saveLibrary","getMaximumGroups","groups","currentGroupMembers","calculateTranslation","selectionBoundingBox","axis","groupBoundingBox","getCommonBoundingBox","noTranslation","alignSelectedElements","alignment","alignElements","updatedElementsMap","midX","midY","distributeSelectedElements","distribution","mid","end","extent","index0","g","index1","pos","box","distributeElements","actionFlipHorizontal","space","flipSelectedElements","eligibleElements","enableActionFlipHorizontal","actionFlipVertical","enableActionFlipVertical","flipDirection","flipElements","flipElement","rotateElement","originalX","originalY","originalAngle","finalOffsetX","usingNWHandle","newNCoordsX","nHandle","rotationAngle","actionCopy","actionCut","actionCopyAsSvg","_data","actionCopyAsPng","exportSelection","exportColorScheme","actionToggleGridMode","actionToggleZenMode","actionToggleStats","writeData","prevElements","updater","prevElementMap","nextElementMap","prevElement","syncHistory","ActionManager","getAppState","renderAction","UIOptions","formState","actionResult","registerAction","registerAll","handleKeyDown","executeAction","Library","libraryCache","resetLibrary","onLibraryChange","restoreLibraryItem","libraryItem","libraryItems","libraryItemsFromStorage","prevLibraryItems","serializedItems","libraryFile","loadLibraryFromBlob","existingLibraryItems","filtered","restoredItem","targetLibraryItem","libItemExcalidrawItem","isUniqueitem","getCenter","pointers","allCoords","getDistance","clearAppStatePropertiesForHistory","History","elementCache","recording","stateHistory","redoStack","lastEntry","generateEntry","dehydrateHistoryEntry","hydrateHistoryEntry","dehydratedExcalidrawElement","versions","getSnapshotForTest","dehydratedHistoryEntry","shouldCreateEntry","nextEntry","pushEntry","newEntryDehydrated","newEntry","clearRedoStack","redoOnce","entryToRestore","pop","undoOnce","currentEntry","setCurrentState","record","state","SHAPES","shortcutMap","cut","paste","copyStyles","pasteStyles","selectAll","duplicateSelection","sendBackward","bringForward","sendToBack","bringToFront","copyAsPng","copyAsSvg","ungroup","gridMode","zenMode","stats","addToLibrary","flipHorizontal","flipVertical","viewMode","getShortcutFromShortcutName","shortcuts","ContextMenu","actionManager","onContextMenu","actionName","dangerous","checkmark","contextMenuNodeByContainer","params","of","render","container","contextMenuNode","unmountComponentAtNode","handleClose","getContextMenuNode","SelectedShapeActions","isEditing","isMobile","showFillIcons","isRGBTransparent","substr","isRRGGBBTransparent","isTransparent","showChangeBackgroundIcons","ShapesSwitcher","setAppState","letter","ZoomActions","BackgroundPickerAndDarkModeToggle","showThemeBtn","CollabButton","isCollaborating","collaboratorCount","supportsContextFilters","ErrorCanvasPreview","renderPreview","previewNode","ExportButton","shade","OpenColor","ImageExportModal","onExportToPng","onExportToSvg","onExportToClipboard","someElementIsSelected","exportSelected","setExportSelected","previewRef","catch","gridTemplateColumns","userSelect","ImageExportDialog","modalIsShown","setModalIsShown","FixedSideContainer","HintViewer","hint","multiMode","targetElement","getHints","Island","PLUS_ICON","LibraryUnit","pendingElements","onRemoveFromLibrary","elementsToRender","child","tagName","isHovered","setIsHovered","adder","onMouseEnter","onMouseLeave","draggable","onDragStart","dataTransfer","setData","LoadingMessage","CHECKED","xmlns","UNCHECKED","LockButton","Section","heading","header","aria-labelledby","UserList","mobile","UserList_mobile","LIBRARY_ICON","LibraryButton","MobileMenu","libraryMenu","renderJSONExportDialog","renderImageExportDialog","onCollabButtonClick","onLockToggle","renderCustomFooter","marginRight","client","Fragment","ChartPreviewBtn","chartElements","setChartElements","parentNode","PasteChartDialog","onInsertChart","handleChartClick","small","autofocus","Header","href","rel","Columns","flexDirection","flexWrap","Column","ShortcutIsland","caption","Shortcut","flex","ShortcutKey","isOr","HelpDialog","Card","JSONExportModal","exportOpts","onExportToBackend","renderCustomUI","JSONExportDialog","LibraryMenuItems","onAddToLibrary","onInsertShape","setLibraryItems","libraryReturnUrl","numCells","CELLS_PER_ROW","numRows","addedPendingElements","referrer","pathname","importLibrary","importLibraryFromJSON","saveLibraryAsJSON","shouldAddPendingElements","bind","LibraryMenu","onClickOutside","listener","Element","useOnClickOutside","closest","loadingState","setIsLoading","loadingTimerRef","race","removeFromLibrary","nextItems","indexToRemove","LayerUI","onInsertElements","showExitZenModeBtn","toggleZenMode","renderTopRightUI","createExporter","Separator","closeLibrary","deselectItems","dialogs","ErrorDialog","shouldRenderSelectedShapeActions","zIndex","maxHeight","renderFixedSideContainer","areEqual","getNecessaryObj","prevAppState","langCode","Stats","boundingBox","selectedBoundingBox","colSpan","renderCustomStats","Toast","clearToast","timerRef","scheduleTimeout","actionToggleViewMode","IsMobileContext","createContext","useContext","ExcalidrawContainerContext","didTapTwice","tappedTwiceTimer","cursorX","cursorY","isHoldingSpace","isPanning","isDraggingScrollBar","currentScrollBars","touchTimeout","invalidateContextMenu","lastPointerUp","gesture","lastCenter","initialDistance","initialScale","App","Component","unmounted","detachIsMobileMqHandler","excalidrawContainerRef","createRef","resizeObserver","nearestScrollableContainer","excalidrawContainerValue","autoFocus","getSceneElementsIncludingDeleted","getSceneElements","syncActionResult","gridModeEnabled","onUnload","disableEvent","onFontLoaded","onSceneUpdated","importLibraryFromUrl","url","token","hash","URLSearchParams","replaceState","search","query","request","fetch","decodeURIComponent","isValidLibrary","numShapes","alert","resetHistory","resetScene","resetLoadingState","initializeScene","launchQueue","setConsumer","launchParams","files","getFile","initialData","scrollToContent","libraryUrl","onResize","onScroll","getCanvasOffsets","onCut","cutAll","onCopy","copyAll","onTapStart","resetTapTwice","touches","handleCanvasDoubleClick","onTapEnd","pasteFromClipboard","elementUnderCursor","elementFromPoint","onPaste","addElementsFromPasteOrLibrary","addTextFromPaste","selectShapeTool","elementsCenterX","elementsCenterY","dx","dy","gridX","gridY","obj","removePointer","pointerId","toggleLock","prevState","toggleStats","setToastMessage","restoreFileFromShare","webShareTargetCache","caches","open","loadFileToCanvas","updateScene","sceneData","updateCurrentCursorPosition","Proxy","ev","prop","HTMLSelectElement","maybeSuggestBindingForAll","startTextEditing","findShapeByKey","onKeyUp","onGestureStart","onGestureChange","onGestureEnd","insertAtParentCenter","existingTextElement","getTextElementAtPosition","parentCenterPosition","getTextWysiwygSnappedToCenterPosition","handleTextWysiwyg","isExistingElement","getSelectedGroupIdForElement","handleCanvasPointerMove","savePointer","scaleFactor","resetShouldCacheIgnoreZoomDebounced","isOverScrollBar","handlePointerMove","maybeSuggestBindingAtCursor","maybeSuggestBindingForLinearElementAtCursor","buttons","elementWithTransformHandleType","isHittingCommonBoundingBoxOfSelectedElements","handleTouchMove","handleCanvasPointerDown","getSelection","anchorNode","removeAllRanges","maybeOpenContextMenuAfterPointerDownOnTouchDevices","maybeCleanupAfterMissingPointerUp","handleCanvasPanUsingWheelOrSpaceDrag","button","updateGestureOnPointerDown","initialPointerDownState","handleDraggingScrollBar","clearSelectionIfNotUsingSelection","updateBindingEnabledOnPointerMove","handleSelectionOnPointerDown","handleTextOnPointerDown","handleLinearElementOnPointerDown","handleFreeDrawElementOnPointerDown","createGenericElementOnPointerDown","onPointerMove","onPointerMoveFromPointerDownHandler","onPointerUp","onPointerUpFromPointerDownHandler","onKeyDownFromPointerDownHandler","onKeyUpFromPointerDownHandler","POINTER_MOVE","POINTER_UP","KEYDOWN","KEYUP","eventListeners","onMove","onUp","handleCanvasContextMenu","nextPastePrevented","isLinux","lastX","lastY","preventNextPaste","PASTE","enableNextPaste","teardown","BLUR","passive","resize","handleType","getResizeOffsetXY","arrowDirection","getResizeArrowDirection","handlePointerDown","hit","allHitElements","getElementsAtPosition","someHitElementIsSelected","isASelectedElement","hasHitCommonBoundingBoxOfSelectedElements","clearSelection","wasAddedToSelection","pressure","shouldEnableBinding","shouldEnableBindingForPointerEvent","hoveredBindableElement","oppositeBindingBoundElement","handleCanvasRef","handleWheel","TOUCH_START","TOUCH_END","handleAppOnDrop","libraryShapes","endsWith","getAsFileSystemHandle","preferSelected","_openContextMenu","maybeDragNewGenericElement","lastCoords","originInGrid","maybeHandleResize","resizeX","resizeY","transformElements","maybeGroupAction","maybeUngroupAction","maybeFlipHorizontal","maybeFlipVertical","separator","appStates","viewModeOptions","MAX_STEP","log10","isNaN","onPointerUpdate","pointersMap","updateDOMRect","excalidrawContainer","currentWidth","currentHeight","currentOffsetTop","currentOffsetLeft","refresh","excalidrawRef","readyPromise","api","ready","createRedoAction","renderCanvas","canvasScale","canvasDOMWidth","canvasDOMHeight","onPointerCancel","onTouchMove","onPointerDown","onDoubleClick","renderFooter","onDrop","handleKeyboardGlobally","Provider","defineProperties","configurable","addEventListeners","ResizeObserver","observe","matchMedia","mediaQuery","matches","addListener","removeListener","componentWillUnmount","disconnect","removeEventListeners","COPY","CUT","SCROLL","MOUSE_MOVE","RESIZE","UNLOAD","DRAG_OVER","DROP","GESTURE_START","GESTURE_CHANGE","GESTURE_END","fonts","detectScroll","overflowY","scrollHeight","clientHeight","getNearestScrollableContainer","componentDidUpdate","prevProps","updateLanguage","deselectElements","toggle","pointerViewportCoords","pointerUsernames","pointerUserStates","user","updateElement","_element","updateTextElement","onSubmit","getViewportCoords","updateWysiwygStyle","viewportX","viewportY","editable","wrap","minHeight","backfaceVisibility","outline","oninput","onkeydown","submittedViaKeyboard","handleSubmit","outdent","indent","dispatchEvent","Event","TAB","repeat","RE_LEADING_TAB","selectionStart","selectionEnd","linesStartIndices","getSelectedLinesStartIndices","startIndex","startValue","endValue","removedTabs","tabMatch","startOffset","startIndices","stopEvent","cleanup","viaKeyboard","isDestroyed","onblur","observer","bindBlurEvent","unbindUpdate","SVGElement","capture","textWysiwyg","elementWithHighestZIndex","hitTest","withCmdOrCtrl","scrollbars","hasBeenDuplicated","drag","hasOccurred","handlePointerMoveOverScrollbars","getDragOffsetXY","handlePointDragging","dragX","dragY","dragDistanceX","dragDistanceY","lockDirection","distanceX","distanceY","lockX","lockY","original","dragSelectedElements","elementsToAppend","duplicatedElement","originDragX","originDragY","nextSceneElements","elementsWithinSelection","selectionX1","selectionY1","selectionX2","selectionY2","getElementsWithinSelection","childEvent","handlePointerUp","idsOfSelectedElementsThatAreInGroups","prevId","_prevState","gId","includedElementIds","getEligibleElementsForBinding","elementClickedInside","getElementContainingPosition","Modal","modalRoot","useBodyRoot","createPortal","labelledBy","setDiv","isMobileRef","isDarkTheme","Dialog","islandNode","setIslandNode","lastActiveElement","focusableElements","queryFocusableElements","currentIndex","querySelectorAll","TopErrorBoundary","hasError","sentryEventId","localStorage","errorSplash","componentDidCatch","errorInfo","_localStorage","Sentry","scope","setExtras","eventId","selectTextArea","templateStrFn","default","encodeURIComponent","reload","createGithubIssue","readOnly","__webpack_public_path__","EXCALIDRAW_ASSET_PATH","pkg","InitializeApp","Excalidraw","nextProps","prevInitialData","prevUIOptions","nextInitialData","nextUIOptions","prevUIOptionsKeys","nextUIOptionsKeys","isUIOptionsSame","prevKeys","nextKeys","forwardedRefComp","BROADCAST","SCENE","byteToHex","byte","generateEncryptionKey","crypto","subtle","generateKey","exportKey","createIV","Uint8Array","getRandomValues","generateCollaborationLinkData","roomId","generateRandomID","roomKey","getImportedKey","usage","importKey","alg","ext","key_ops","kty","decryptImported","iv","encrypted","privateKey","decrypt","localDataState","response","ok","buffer","arrayBuffer","decrypted","byteLength","fixedIv","string","TextDecoder","decode","importFromBackend","firebasePromise","firestorePromise","firebseStoragePromise","_getFirebase","firebase","firebaseConfig","initializeApp","_loadFirebase","loadFirestore","firebaseSceneVersionCache","isSavedToFirebase","portal","socket","sceneVersion","saveToFirebase","ciphertext","importedKey","encoded","TextEncoder","encode","encrypt","encryptElements","nextDocData","firestore","fromUint8Array","docRef","collection","doc","didUpdate","runTransaction","transaction","exists","update","loadFromFirebase","storedScene","toUint8Array","decodedData","decryptElements","importUsernameFromLocalStorage","getItem","getElementsStorageSize","getTotalStorageSize","collab","APP_STORAGE_KEYS","appStateSize","collabSize","Portal","socketInitialized","broadcastedElementVersions","broadcastScene","sceneType","syncableElements","syncAll","INIT","syncableElement","payload","broadcastPromise","_broadcastSocketData","saveCollabRoomToFirebase","broadcastIdleChange","broadcastMouseLocation","excalidrawAPI","on","emit","getSyncableElements","clients","setCollaborators","isOpen","volatile","encryptAESGEM","getShareIcon","isAppleBrowser","vendor","isWindowsBrowser","appVersion","RoomDialog","activeRoomLink","onUsernameChange","onRoomCreate","onRoomDestroy","setErrorMessage","roomLinkInput","copyRoomLink","shareRoomLink","selectInput","onKeyPress","Context","CollabContext","Consumer","CollabContextConsumer","CollabContextProvider","initialValue","InverseConsumer","_updateProviderValue","InverseProvider","componentDidMount","createInverseContext","CollabWrapper","PureComponent","activeIntervalId","idleTimeoutId","socketInitializationTimer","lastBroadcastedOrReceivedSceneVersion","destroySocketClient","isUnload","beforeUnload","returnValue","setItem","timestamp","room","openPortal","initializeSocketClient","closePortal","pushState","existingRoomLinkData","scenePromise","socketIOClient","initializeSocket","encryptedData","decryptedData","decryptAESGEM","remoteElements","reconciledElements","reconcileElements","handleRemoteSceneUpdate","init","UPDATE","socketID","off","initializeIdleDetector","currentElements","localElementMap","setLastBroadcastedOrReceivedSceneVersion","reportIdle","setInterval","reportActive","onVisibilityChange","clearInterval","onIdleStateChange","VISIBILITY_CHANGE","getLastBroadcastedOrReceivedSceneVersion","broadcastElements","queueBroadcastAllElements","throttle","currentVersion","newVersion","saveUsernameToLocalStorage","contextValue","getContextValue","BEFORE_UNLOAD","sockets","LanguageList","i18n","currentLangCode","floating","getStorageSizes","total","CustomStats","storageSizes","setStorageSizes","sizes","excalidrawPlusIcon","exportToExcalidrawPlus","loadFirebaseStorage","encryptData","storage","put","customMetadata","created","ExportToExcalidrawPlus","onError","languageDetector","LanguageDetector","languageUtils","formatLanguageCode","isWhitelisted","checkWhitelist","saveDebounced","saveToLocalStorage","jsonBackendMatch","externalUrlMatch","savedElements","savedState","importFromLocalStorage","roomLinkData","URL","getCollaborationLinkData","once","collabAPI","PlusLinkJSX","unicodeBidi","ExcalidrawWrapper","detect","setLangCode","initialStatePromiseRef","excalidrawRefCallback","onHashChange","oldURL","titleTimeout","HASHCHANGE","cacheUserLanguage","renderLanguageList","isTinyDevice","borderRadius","payloadBlob","Response","exportedKey","method","urlString","prompt","error_class","exportToBackend","removeItem","ExcalidrawApp","isLocalhost","hostname","registerValidSW","swUrl","config","serviceWorker","registration","onupdatefound","installingWorker","installing","onstatechange","controller","info","onUpdate","onSuccess","checkValidServiceWorker","headers","contentType","status","unregister","userAgent","registerServiceWorker","waitingServiceWorker","waiting","STATE_CHANGE","postMessage","SentryEnvHostnameMap","onlineEnv","REACT_APP_DISABLE_SENTRY","dsn","environment","release","ignoreErrors","integrations","SentryIntegrations","levels","beforeSend","__EXCALIDRAW_SHA__","ReactDOM","getElementById"],"mappings":"wGAAA,6+CAIO,MAAMA,EAAW,aAEXC,EAAqB,GACrBC,EAAyB,EACzBC,EAAiC,EACjCC,EAA2B,EAC3BC,EAAgC,GAChCC,EAAsBC,KAAKC,GAAK,GAChCC,EAAc,CACzBC,KAAM,OACNC,UAAW,YACXC,SAAU,WACVC,QAAS,UACTC,KAAM,OACNC,KAAM,IAEKC,EAAiB,CAC5BC,KAAM,EACNC,MAAO,EACPC,UAAW,EACXC,OAAQ,GAGH,IAAKC,G,SAAAA,K,YAAAA,E,cAAAA,E,UAAAA,E,kBAAAA,E,cAAAA,E,uBAAAA,E,gBAAAA,E,gBAAAA,E,YAAAA,E,qBAAAA,E,YAAAA,E,yBAAAA,E,6BAAAA,E,6BAAAA,E,+BAAAA,E,2BAAAA,E,uBAAAA,E,2BAAAA,E,cAAAA,E,yBAAAA,E,qBAAAA,E,wBAAAA,E,qCAAAA,E,iBAAAA,M,KA2BL,MAAMC,EAAM,CACjBC,KAAM,OACNC,YAAa,eAGFC,EAAU,CACrBC,mBAAoB,kBAITC,EAAc,CACzBC,OAAQ,EACRC,UAAW,EACXC,SAAU,GAGCC,EAA8B,iBAE9BC,EAAoB,GACpBC,EAAwCN,EAAYC,OACpDM,EAAqB,OACrBC,EAAyB,MACzBC,EAAkB,YAIlBC,EAAY,GAEZC,EAAa,CACxBC,WAAY,kCACZC,cAAe,sCAGJC,EAAoB,CAC/BF,WAAY,aACZG,oBAAqB,uBACrBC,kBAAmB,iBAGRC,EAAgBC,OAAOC,SAASC,OAEhCC,EAAe,CAC1BC,sBAAuB,sBAIZC,EAAoB,IACpBC,EAAyB,IACzBC,EAAgB,IAChBC,EAAgB,IAChBC,EAAkB,IAClBC,EAAiB,IACjBC,EAAY,GAGZC,EAAiB,IAEjBC,EAAmB,IAEnBC,EAAQ,CACnBC,KAAM,WACNC,IAAK,UACLC,KAAM,YAGKC,EAAeC,IAAaC,YAE5BC,EAAiB,CAC5BC,WAAY,cAGDC,EAAgB,CAC3BD,WAAY,cAGDE,EAA4C,CACvDC,cAAe,CACbC,2BAA2B,EAC3BC,aAAa,EACbC,OAAQ,CAAEC,gBAAgB,GAC1BC,WAAW,EACXC,kBAAkB,EAClBC,OAAO,EACPC,aAAa,IAIJC,EAAwB,IACxBC,EAAyB,IACzBC,EAA0B,IAE1BC,EAA8B,EAE9BC,EAAgB,CAAC,EAAG,EAAG,GACvBC,EAAyB,I,0FCpJ/B,MAAMC,EACQ,qBAAZC,IAAP,UACAA,k2BADA,aACA,EAAaC,gCACK,qBAAX1C,QACPA,OAAO2C,KACH,CAACC,EAAkBC,EAAcC,EAAgBC,KAC/C/C,OAAO2C,KAAK,QAASE,EAAM,CACzBG,eAAgBJ,EAChBK,YAAaH,EACbC,YAGe,qBAAZN,IAAP,UAAkCA,k2BAAlC,OAAkC,EAAaS,gBAC/C,CAACN,EAAkBC,EAAcC,EAAgBC,U,6sZCZvDI,EAAOC,QAAU,CAAC,YAAc,mC,0BCDhC,IAAIC,EAAM,CACT,eAAgB,CACf,GACA,GAED,eAAgB,CACf,GACA,GAED,eAAgB,CACf,GACA,GAED,eAAgB,CACf,GACA,GAED,eAAgB,CACf,GACA,GAED,eAAgB,CACf,GACA,GAED,YAAa,CACZ,IAED,eAAgB,CACf,GACA,IAED,eAAgB,CACf,GACA,IAED,eAAgB,CACf,GACA,IAED,eAAgB,CACf,GACA,IAED,eAAgB,CACf,GACA,IAED,eAAgB,CACf,GACA,IAED,eAAgB,CACf,GACA,IAED,eAAgB,CACf,GACA,IAED,eAAgB,CACf,GACA,IAED,eAAgB,CACf,GACA,IAED,iBAAkB,CACjB,GACA,IAED,eAAgB,CACf,GACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,qBAAsB,CACrB,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,IAED,eAAgB,CACf,IACA,KAGF,SAASC,EAAoBC,GAC5B,IAAIC,EA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","file":"static/js/main.a9ab465b.chunk.js","sourcesContent":["import cssVariables from \"./css/variables.module.scss\";\nimport { AppProps } from \"./types\";\nimport { FontFamilyValues } from \"./element/types\";\n\nexport const APP_NAME = \"Excalidraw\";\n\nexport const DRAGGING_THRESHOLD = 10; // px\nexport const LINE_CONFIRM_THRESHOLD = 8; // px\nexport const ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;\nexport const ELEMENT_TRANSLATE_AMOUNT = 1;\nexport const TEXT_TO_CENTER_SNAP_THRESHOLD = 30;\nexport const SHIFT_LOCKING_ANGLE = Math.PI / 12;\nexport const CURSOR_TYPE = {\n  TEXT: \"text\",\n  CROSSHAIR: \"crosshair\",\n  GRABBING: \"grabbing\",\n  POINTER: \"pointer\",\n  MOVE: \"move\",\n  AUTO: \"\",\n};\nexport const POINTER_BUTTON = {\n  MAIN: 0,\n  WHEEL: 1,\n  SECONDARY: 2,\n  TOUCH: -1,\n};\n\nexport enum EVENT {\n  COPY = \"copy\",\n  PASTE = \"paste\",\n  CUT = \"cut\",\n  KEYDOWN = \"keydown\",\n  KEYUP = \"keyup\",\n  MOUSE_MOVE = \"mousemove\",\n  RESIZE = \"resize\",\n  UNLOAD = \"unload\",\n  BLUR = \"blur\",\n  DRAG_OVER = \"dragover\",\n  DROP = \"drop\",\n  GESTURE_END = \"gestureend\",\n  BEFORE_UNLOAD = \"beforeunload\",\n  GESTURE_START = \"gesturestart\",\n  GESTURE_CHANGE = \"gesturechange\",\n  POINTER_MOVE = \"pointermove\",\n  POINTER_UP = \"pointerup\",\n  STATE_CHANGE = \"statechange\",\n  WHEEL = \"wheel\",\n  TOUCH_START = \"touchstart\",\n  TOUCH_END = \"touchend\",\n  HASHCHANGE = \"hashchange\",\n  VISIBILITY_CHANGE = \"visibilitychange\",\n  SCROLL = \"scroll\",\n}\n\nexport const ENV = {\n  TEST: \"test\",\n  DEVELOPMENT: \"development\",\n};\n\nexport const CLASSES = {\n  SHAPE_ACTIONS_MENU: \"App-menu__left\",\n};\n\n// 1-based in case we ever do `if(element.fontFamily)`\nexport const FONT_FAMILY = {\n  Virgil: 1,\n  Helvetica: 2,\n  Cascadia: 3,\n};\n\nexport const WINDOWS_EMOJI_FALLBACK_FONT = \"Segoe UI Emoji\";\n\nexport const DEFAULT_FONT_SIZE = 20;\nexport const DEFAULT_FONT_FAMILY: FontFamilyValues = FONT_FAMILY.Virgil;\nexport const DEFAULT_TEXT_ALIGN = \"left\";\nexport const DEFAULT_VERTICAL_ALIGN = \"top\";\nexport const DEFAULT_VERSION = \"{version}\";\n\nexport const CANVAS_ONLY_ACTIONS = [\"selectAll\"];\n\nexport const GRID_SIZE = 20; // TODO make it configurable?\n\nexport const MIME_TYPES = {\n  excalidraw: \"application/vnd.excalidraw+json\",\n  excalidrawlib: \"application/vnd.excalidrawlib+json\",\n};\n\nexport const EXPORT_DATA_TYPES = {\n  excalidraw: \"excalidraw\",\n  excalidrawClipboard: \"excalidraw/clipboard\",\n  excalidrawLibrary: \"excalidrawlib\",\n} as const;\n\nexport const EXPORT_SOURCE = window.location.origin;\n\nexport const STORAGE_KEYS = {\n  LOCAL_STORAGE_LIBRARY: \"excalidraw-library\",\n} as const;\n\n// time in milliseconds\nexport const TAP_TWICE_TIMEOUT = 300;\nexport const TOUCH_CTX_MENU_TIMEOUT = 500;\nexport const TITLE_TIMEOUT = 10000;\nexport const TOAST_TIMEOUT = 5000;\nexport const VERSION_TIMEOUT = 30000;\nexport const SCROLL_TIMEOUT = 100;\nexport const ZOOM_STEP = 0.1;\n\n// Report a user inactive after IDLE_THRESHOLD milliseconds\nexport const IDLE_THRESHOLD = 60_000;\n// Report a user active each ACTIVE_THRESHOLD milliseconds\nexport const ACTIVE_THRESHOLD = 3_000;\n\nexport const MODES = {\n  VIEW: \"viewMode\",\n  ZEN: \"zenMode\",\n  GRID: \"gridMode\",\n};\n\nexport const THEME_FILTER = cssVariables.themeFilter;\n\nexport const URL_QUERY_KEYS = {\n  addLibrary: \"addLibrary\",\n} as const;\n\nexport const URL_HASH_KEYS = {\n  addLibrary: \"addLibrary\",\n} as const;\n\nexport const DEFAULT_UI_OPTIONS: AppProps[\"UIOptions\"] = {\n  canvasActions: {\n    changeViewBackgroundColor: true,\n    clearCanvas: true,\n    export: { saveFileToDisk: true },\n    loadScene: true,\n    saveToActiveFile: true,\n    theme: true,\n    saveAsImage: true,\n  },\n};\n\nexport const MQ_MAX_WIDTH_PORTRAIT = 730;\nexport const MQ_MAX_WIDTH_LANDSCAPE = 1000;\nexport const MQ_MAX_HEIGHT_LANDSCAPE = 500;\n\nexport const MAX_DECIMALS_FOR_SVG_EXPORT = 2;\n\nexport const EXPORT_SCALES = [1, 2, 3];\nexport const DEFAULT_EXPORT_PADDING = 10; // px\n","export const trackEvent =\n  typeof process !== \"undefined\" &&\n  process.env?.REACT_APP_GOOGLE_ANALYTICS_ID &&\n  typeof window !== \"undefined\" &&\n  window.gtag\n    ? (category: string, name: string, label?: string, value?: number) => {\n        window.gtag(\"event\", name, {\n          event_category: category,\n          event_label: label,\n          value,\n        });\n      }\n    : typeof process !== \"undefined\" && process.env?.JEST_WORKER_ID\n    ? (category: string, name: string, label?: string, value?: number) => {}\n    : (category: string, name: string, label?: string, value?: number) => {\n        // Uncomment the next line to track locally\n        // console.info(\"Track Event\", category, name, label, value);\n      };\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"themeFilter\":\"invert(93%) hue-rotate(180deg)\"};","var map = {\n\t\"./ar-SA.json\": [\n\t\t82,\n\t\t4\n\t],\n\t\"./bg-BG.json\": [\n\t\t83,\n\t\t5\n\t],\n\t\"./ca-ES.json\": [\n\t\t84,\n\t\t6\n\t],\n\t\"./cs-CZ.json\": [\n\t\t85,\n\t\t7\n\t],\n\t\"./de-DE.json\": [\n\t\t86,\n\t\t8\n\t],\n\t\"./el-GR.json\": [\n\t\t87,\n\t\t9\n\t],\n\t\"./en.json\": [\n\t\t30\n\t],\n\t\"./es-ES.json\": [\n\t\t88,\n\t\t10\n\t],\n\t\"./fa-IR.json\": [\n\t\t89,\n\t\t11\n\t],\n\t\"./fi-FI.json\": [\n\t\t90,\n\t\t12\n\t],\n\t\"./fr-FR.json\": [\n\t\t91,\n\t\t13\n\t],\n\t\"./he-IL.json\": [\n\t\t92,\n\t\t14\n\t],\n\t\"./hi-IN.json\": [\n\t\t93,\n\t\t15\n\t],\n\t\"./hu-HU.json\": [\n\t\t94,\n\t\t16\n\t],\n\t\"./id-ID.json\": [\n\t\t95,\n\t\t17\n\t],\n\t\"./it-IT.json\": [\n\t\t96,\n\t\t18\n\t],\n\t\"./ja-JP.json\": [\n\t\t97,\n\t\t19\n\t],\n\t\"./kab-KAB.json\": [\n\t\t98,\n\t\t20\n\t],\n\t\"./ko-KR.json\": [\n\t\t99,\n\t\t21\n\t],\n\t\"./lv-LV.json\": [\n\t\t100,\n\t\t22\n\t],\n\t\"./my-MM.json\": [\n\t\t101,\n\t\t23\n\t],\n\t\"./nb-NO.json\": [\n\t\t102,\n\t\t24\n\t],\n\t\"./nl-NL.json\": [\n\t\t103,\n\t\t25\n\t],\n\t\"./nn-NO.json\": [\n\t\t104,\n\t\t26\n\t],\n\t\"./oc-FR.json\": [\n\t\t105,\n\t\t27\n\t],\n\t\"./pa-IN.json\": [\n\t\t106,\n\t\t28\n\t],\n\t\"./percentages.json\": [\n\t\t31\n\t],\n\t\"./pl-PL.json\": [\n\t\t107,\n\t\t29\n\t],\n\t\"./pt-BR.json\": [\n\t\t108,\n\t\t30\n\t],\n\t\"./pt-PT.json\": [\n\t\t109,\n\t\t31\n\t],\n\t\"./ro-RO.json\": [\n\t\t110,\n\t\t32\n\t],\n\t\"./ru-RU.json\": [\n\t\t111,\n\t\t33\n\t],\n\t\"./sk-SK.json\": [\n\t\t112,\n\t\t34\n\t],\n\t\"./sv-SE.json\": [\n\t\t113,\n\t\t35\n\t],\n\t\"./tr-TR.json\": [\n\t\t114,\n\t\t36\n\t],\n\t\"./uk-UA.json\": [\n\t\t115,\n\t\t37\n\t],\n\t\"./zh-CN.json\": [\n\t\t116,\n\t\t38\n\t],\n\t\"./zh-TW.json\": [\n\t\t117,\n\t\t39\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(1).map(__webpack_require__.e)).then(function() {\n\t\treturn __webpack_require__.t(id, 3);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 47;\nmodule.exports = webpackAsyncContext;","import fallbackLangData from \"./locales/en.json\";\nimport percentages from \"./locales/percentages.json\";\nimport { ENV } from \"./constants\";\n\nconst COMPLETION_THRESHOLD = 85;\n\nexport interface Language {\n  code: string;\n  label: string;\n  rtl?: boolean;\n}\n\nexport const defaultLang = { code: \"en\", label: \"English\" };\n\nconst allLanguages: Language[] = [\n  { code: \"ar-SA\", label: \"العربية\", rtl: true },\n  { code: \"bg-BG\", label: \"Български\" },\n  { code: \"ca-ES\", label: \"Català\" },\n  { code: \"de-DE\", label: \"Deutsch\" },\n  { code: \"el-GR\", label: \"Ελληνικά\" },\n  { code: \"es-ES\", label: \"Español\" },\n  { code: \"fa-IR\", label: \"فارسی\", rtl: true },\n  { code: \"fi-FI\", label: \"Suomi\" },\n  { code: \"fr-FR\", label: \"Français\" },\n  { code: \"he-IL\", label: \"עברית\", rtl: true },\n  { code: \"hi-IN\", label: \"हिन्दी\" },\n  { code: \"hu-HU\", label: \"Magyar\" },\n  { code: \"id-ID\", label: \"Bahasa Indonesia\" },\n  { code: \"it-IT\", label: \"Italiano\" },\n  { code: \"ja-JP\", label: \"日本語\" },\n  { code: \"kab-KAB\", label: \"Taqbaylit\" },\n  { code: \"ko-KR\", label: \"한국어\" },\n  { code: \"my-MM\", label: \"Burmese\" },\n  { code: \"nb-NO\", label: \"Norsk bokmål\" },\n  { code: \"nl-NL\", label: \"Nederlands\" },\n  { code: \"nn-NO\", label: \"Norsk nynorsk\" },\n  { code: \"oc-FR\", label: \"Occitan\" },\n  { code: \"pa-IN\", label: \"ਪੰਜਾਬੀ\" },\n  { code: \"pl-PL\", label: \"Polski\" },\n  { code: \"pt-BR\", label: \"Português Brasileiro\" },\n  { code: \"pt-PT\", label: \"Português\" },\n  { code: \"ro-RO\", label: \"Română\" },\n  { code: \"ru-RU\", label: \"Русский\" },\n  { code: \"sk-SK\", label: \"Slovenčina\" },\n  { code: \"sv-SE\", label: \"Svenska\" },\n  { code: \"tr-TR\", label: \"Türkçe\" },\n  { code: \"uk-UA\", label: \"Українська\" },\n  { code: \"zh-CN\", label: \"简体中文\" },\n  { code: \"zh-TW\", label: \"繁體中文\" },\n  { code: \"lv-LV\", label: \"Latviešu\" },\n  { code: \"cs-CZ\", label: \"Česky\" },\n].concat([defaultLang]);\n\nexport const languages: Language[] = allLanguages\n  .sort((left, right) => (left.label > right.label ? 1 : -1))\n  .filter(\n    (lang) =>\n      (percentages as Record<string, number>)[lang.code] >=\n      COMPLETION_THRESHOLD,\n  );\n\nconst TEST_LANG_CODE = \"__test__\";\nif (process.env.NODE_ENV === ENV.DEVELOPMENT) {\n  languages.unshift(\n    { code: TEST_LANG_CODE, label: \"test language\" },\n    {\n      code: `${TEST_LANG_CODE}.rtl`,\n      label: \"\\u{202a}test language (rtl)\\u{202c}\",\n      rtl: true,\n    },\n  );\n}\n\nlet currentLang: Language = defaultLang;\nlet currentLangData = {};\n\nexport const setLanguage = async (lang: Language) => {\n  currentLang = lang;\n  document.documentElement.dir = currentLang.rtl ? \"rtl\" : \"ltr\";\n  document.documentElement.lang = currentLang.code;\n\n  if (lang.code.startsWith(TEST_LANG_CODE)) {\n    currentLangData = {};\n  } else {\n    currentLangData = await import(\n      /* webpackChunkName: \"i18n-[request]\" */ `./locales/${currentLang.code}.json`\n    );\n  }\n};\n\nexport const getLanguage = () => currentLang;\n\nconst findPartsForData = (data: any, parts: string[]) => {\n  for (let index = 0; index < parts.length; ++index) {\n    const part = parts[index];\n    if (data[part] === undefined) {\n      return undefined;\n    }\n    data = data[part];\n  }\n  if (typeof data !== \"string\") {\n    return undefined;\n  }\n  return data;\n};\n\nexport const t = (path: string, replacement?: { [key: string]: string }) => {\n  if (currentLang.code.startsWith(TEST_LANG_CODE)) {\n    const name = replacement\n      ? `${path}(${JSON.stringify(replacement).slice(1, -1)})`\n      : path;\n    return `\\u{202a}[[${name}]]\\u{202c}`;\n  }\n\n  const parts = path.split(\".\");\n  let translation =\n    findPartsForData(currentLangData, parts) ||\n    findPartsForData(fallbackLangData, parts);\n  if (translation === undefined) {\n    throw new Error(`Can't find translation for ${path}`);\n  }\n\n  if (replacement) {\n    for (const key in replacement) {\n      translation = translation.replace(`{{${key}}}`, replacement[key]);\n    }\n  }\n  return translation;\n};\n","import oc from \"open-color\";\n\nconst shades = (index: number) => [\n  oc.red[index],\n  oc.pink[index],\n  oc.grape[index],\n  oc.violet[index],\n  oc.indigo[index],\n  oc.blue[index],\n  oc.cyan[index],\n  oc.teal[index],\n  oc.green[index],\n  oc.lime[index],\n  oc.yellow[index],\n  oc.orange[index],\n];\n\nexport default {\n  canvasBackground: [oc.white, oc.gray[0], oc.gray[1], ...shades(0)],\n  elementBackground: [\"transparent\", oc.gray[4], oc.gray[6], ...shades(6)],\n  elementStroke: [oc.black, oc.gray[8], oc.gray[7], ...shades(9)],\n};\n","export const isDarwin = /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\nexport const isWindows = /^Win/.test(window.navigator.platform);\n\nexport const CODES = {\n  EQUAL: \"Equal\",\n  MINUS: \"Minus\",\n  NUM_ADD: \"NumpadAdd\",\n  NUM_SUBTRACT: \"NumpadSubtract\",\n  NUM_ZERO: \"Numpad0\",\n  BRACKET_RIGHT: \"BracketRight\",\n  BRACKET_LEFT: \"BracketLeft\",\n  ONE: \"Digit1\",\n  TWO: \"Digit2\",\n  NINE: \"Digit9\",\n  QUOTE: \"Quote\",\n  ZERO: \"Digit0\",\n  SLASH: \"Slash\",\n  C: \"KeyC\",\n  D: \"KeyD\",\n  G: \"KeyG\",\n  F: \"KeyF\",\n  H: \"KeyH\",\n  V: \"KeyV\",\n  X: \"KeyX\",\n  Z: \"KeyZ\",\n  R: \"KeyR\",\n} as const;\n\nexport const KEYS = {\n  ARROW_DOWN: \"ArrowDown\",\n  ARROW_LEFT: \"ArrowLeft\",\n  ARROW_RIGHT: \"ArrowRight\",\n  ARROW_UP: \"ArrowUp\",\n  BACKSPACE: \"Backspace\",\n  ALT: \"Alt\",\n  CTRL_OR_CMD: isDarwin ? \"metaKey\" : \"ctrlKey\",\n  DELETE: \"Delete\",\n  ENTER: \"Enter\",\n  ESCAPE: \"Escape\",\n  QUESTION_MARK: \"?\",\n  SPACE: \" \",\n  TAB: \"Tab\",\n\n  A: \"a\",\n  D: \"d\",\n  E: \"e\",\n  G: \"g\",\n  L: \"l\",\n  O: \"o\",\n  P: \"p\",\n  Q: \"q\",\n  R: \"r\",\n  S: \"s\",\n  T: \"t\",\n  V: \"v\",\n  X: \"x\",\n  Y: \"y\",\n  Z: \"z\",\n} as const;\n\nexport type Key = keyof typeof KEYS;\n\nexport const isArrowKey = (key: string) =>\n  key === KEYS.ARROW_LEFT ||\n  key === KEYS.ARROW_RIGHT ||\n  key === KEYS.ARROW_DOWN ||\n  key === KEYS.ARROW_UP;\n\nexport const getResizeCenterPointKey = (event: MouseEvent | KeyboardEvent) =>\n  event.altKey;\n\nexport const getResizeWithSidesSameLengthKey = (\n  event: MouseEvent | KeyboardEvent,\n) => event.shiftKey;\n\nexport const getRotateWithDiscreteAngleKey = (\n  event: MouseEvent | KeyboardEvent,\n) => event.shiftKey;\n","import colors from \"./colors\";\nimport {\n  CURSOR_TYPE,\n  DEFAULT_VERSION,\n  FONT_FAMILY,\n  WINDOWS_EMOJI_FALLBACK_FONT,\n} from \"./constants\";\nimport { FontFamilyValues, FontString } from \"./element/types\";\nimport { Zoom } from \"./types\";\nimport { unstable_batchedUpdates } from \"react-dom\";\nimport { isDarwin } from \"./keys\";\n\nexport const SVG_NS = \"http://www.w3.org/2000/svg\";\n\nlet mockDateTime: string | null = null;\n\nexport const setDateTimeForTests = (dateTime: string) => {\n  mockDateTime = dateTime;\n};\n\nexport const getDateTime = () => {\n  if (mockDateTime) {\n    return mockDateTime;\n  }\n\n  const date = new Date();\n  const year = date.getFullYear();\n  const month = `${date.getMonth() + 1}`.padStart(2, \"0\");\n  const day = `${date.getDate()}`.padStart(2, \"0\");\n  const hr = `${date.getHours()}`.padStart(2, \"0\");\n  const min = `${date.getMinutes()}`.padStart(2, \"0\");\n\n  return `${year}-${month}-${day}-${hr}${min}`;\n};\n\nexport const capitalizeString = (str: string) =>\n  str.charAt(0).toUpperCase() + str.slice(1);\n\nexport const isToolIcon = (\n  target: Element | EventTarget | null,\n): target is HTMLElement =>\n  target instanceof HTMLElement && target.className.includes(\"ToolIcon\");\n\nexport const isInputLike = (\n  target: Element | EventTarget | null,\n): target is\n  | HTMLInputElement\n  | HTMLTextAreaElement\n  | HTMLSelectElement\n  | HTMLBRElement\n  | HTMLDivElement =>\n  (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n  target instanceof HTMLBRElement || // newline in wysiwyg\n  target instanceof HTMLInputElement ||\n  target instanceof HTMLTextAreaElement ||\n  target instanceof HTMLSelectElement;\n\nexport const isWritableElement = (\n  target: Element | EventTarget | null,\n): target is\n  | HTMLInputElement\n  | HTMLTextAreaElement\n  | HTMLBRElement\n  | HTMLDivElement =>\n  (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n  target instanceof HTMLBRElement || // newline in wysiwyg\n  target instanceof HTMLTextAreaElement ||\n  (target instanceof HTMLInputElement &&\n    (target.type === \"text\" || target.type === \"number\"));\n\nexport const getFontFamilyString = ({\n  fontFamily,\n}: {\n  fontFamily: FontFamilyValues;\n}) => {\n  for (const [fontFamilyString, id] of Object.entries(FONT_FAMILY)) {\n    if (id === fontFamily) {\n      return `${fontFamilyString}, ${WINDOWS_EMOJI_FALLBACK_FONT}`;\n    }\n  }\n  return WINDOWS_EMOJI_FALLBACK_FONT;\n};\n\n/** returns fontSize+fontFamily string for assignment to DOM elements */\nexport const getFontString = ({\n  fontSize,\n  fontFamily,\n}: {\n  fontSize: number;\n  fontFamily: FontFamilyValues;\n}) => {\n  return `${fontSize}px ${getFontFamilyString({ fontFamily })}` as FontString;\n};\n\n// https://github.com/grassator/canvas-text-editor/blob/master/lib/FontMetrics.js\nexport const measureText = (text: string, font: FontString) => {\n  const line = document.createElement(\"div\");\n  const body = document.body;\n  line.style.position = \"absolute\";\n  line.style.whiteSpace = \"pre\";\n  line.style.font = font;\n  body.appendChild(line);\n  line.innerText = text\n    .split(\"\\n\")\n    // replace empty lines with single space because leading/trailing empty\n    // lines would be stripped from computation\n    .map((x) => x || \" \")\n    .join(\"\\n\");\n  const width = line.offsetWidth;\n  const height = line.offsetHeight;\n  // Now creating 1px sized item that will be aligned to baseline\n  // to calculate baseline shift\n  const span = document.createElement(\"span\");\n  span.style.display = \"inline-block\";\n  span.style.overflow = \"hidden\";\n  span.style.width = \"1px\";\n  span.style.height = \"1px\";\n  line.appendChild(span);\n  // Baseline is important for positioning text on canvas\n  const baseline = span.offsetTop + span.offsetHeight;\n  document.body.removeChild(line);\n\n  return { width, height, baseline };\n};\n\nexport const debounce = <T extends any[]>(\n  fn: (...args: T) => void,\n  timeout: number,\n) => {\n  let handle = 0;\n  let lastArgs: T | null = null;\n  const ret = (...args: T) => {\n    lastArgs = args;\n    clearTimeout(handle);\n    handle = window.setTimeout(() => {\n      lastArgs = null;\n      fn(...args);\n    }, timeout);\n  };\n  ret.flush = () => {\n    clearTimeout(handle);\n    if (lastArgs) {\n      const _lastArgs = lastArgs;\n      lastArgs = null;\n      fn(..._lastArgs);\n    }\n  };\n  ret.cancel = () => {\n    lastArgs = null;\n    clearTimeout(handle);\n  };\n  return ret;\n};\n\nexport const selectNode = (node: Element) => {\n  const selection = window.getSelection();\n  if (selection) {\n    const range = document.createRange();\n    range.selectNodeContents(node);\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n};\n\nexport const removeSelection = () => {\n  const selection = window.getSelection();\n  if (selection) {\n    selection.removeAllRanges();\n  }\n};\n\nexport const distance = (x: number, y: number) => Math.abs(x - y);\n\nexport const resetCursor = (canvas: HTMLCanvasElement | null) => {\n  if (canvas) {\n    canvas.style.cursor = \"\";\n  }\n};\n\nexport const setCursor = (canvas: HTMLCanvasElement | null, cursor: string) => {\n  if (canvas) {\n    canvas.style.cursor = cursor;\n  }\n};\n\nexport const setCursorForShape = (\n  canvas: HTMLCanvasElement | null,\n  shape: string,\n) => {\n  if (!canvas) {\n    return;\n  }\n  if (shape === \"selection\") {\n    resetCursor(canvas);\n  } else {\n    canvas.style.cursor = CURSOR_TYPE.CROSSHAIR;\n  }\n};\n\nexport const isFullScreen = () =>\n  document.fullscreenElement?.nodeName === \"HTML\";\n\nexport const allowFullScreen = () =>\n  document.documentElement.requestFullscreen();\n\nexport const exitFullScreen = () => document.exitFullscreen();\n\nexport const getShortcutKey = (shortcut: string): string => {\n  shortcut = shortcut\n    .replace(/\\bAlt\\b/i, \"Alt\")\n    .replace(/\\bShift\\b/i, \"Shift\")\n    .replace(/\\b(Enter|Return)\\b/i, \"Enter\")\n    .replace(/\\bDel\\b/i, \"Delete\");\n\n  if (isDarwin) {\n    return shortcut\n      .replace(/\\bCtrlOrCmd\\b/i, \"Cmd\")\n      .replace(/\\bAlt\\b/i, \"Option\");\n  }\n  return shortcut.replace(/\\bCtrlOrCmd\\b/i, \"Ctrl\");\n};\n\nexport const viewportCoordsToSceneCoords = (\n  { clientX, clientY }: { clientX: number; clientY: number },\n  {\n    zoom,\n    offsetLeft,\n    offsetTop,\n    scrollX,\n    scrollY,\n  }: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const invScale = 1 / zoom.value;\n  const x = (clientX - zoom.translation.x - offsetLeft) * invScale - scrollX;\n  const y = (clientY - zoom.translation.y - offsetTop) * invScale - scrollY;\n  return { x, y };\n};\n\nexport const sceneCoordsToViewportCoords = (\n  { sceneX, sceneY }: { sceneX: number; sceneY: number },\n  {\n    zoom,\n    offsetLeft,\n    offsetTop,\n    scrollX,\n    scrollY,\n  }: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const x = (sceneX + scrollX + offsetLeft) * zoom.value + zoom.translation.x;\n  const y = (sceneY + scrollY + offsetTop) * zoom.value + zoom.translation.y;\n  return { x, y };\n};\n\nexport const getGlobalCSSVariable = (name: string) =>\n  getComputedStyle(document.documentElement).getPropertyValue(`--${name}`);\n\nconst RS_LTR_CHARS =\n  \"A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\" +\n  \"\\u2C00-\\uFB1C\\uFDFE-\\uFE6F\\uFEFD-\\uFFFF\";\nconst RS_RTL_CHARS = \"\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC\";\nconst RE_RTL_CHECK = new RegExp(`^[^${RS_LTR_CHARS}]*[${RS_RTL_CHARS}]`);\n/**\n * Checks whether first directional character is RTL. Meaning whether it starts\n *  with RTL characters, or indeterminate (numbers etc.) characters followed by\n *  RTL.\n * See https://github.com/excalidraw/excalidraw/pull/1722#discussion_r436340171\n */\nexport const isRTL = (text: string) => RE_RTL_CHECK.test(text);\n\nexport const tupleToCoors = (\n  xyTuple: readonly [number, number],\n): { x: number; y: number } => {\n  const [x, y] = xyTuple;\n  return { x, y };\n};\n\n/** use as a rejectionHandler to mute filesystem Abort errors */\nexport const muteFSAbortError = (error?: Error) => {\n  if (error?.name === \"AbortError\") {\n    return;\n  }\n  throw error;\n};\n\nexport const findIndex = <T>(\n  array: readonly T[],\n  cb: (element: T, index: number, array: readonly T[]) => boolean,\n  fromIndex: number = 0,\n) => {\n  if (fromIndex < 0) {\n    fromIndex = array.length + fromIndex;\n  }\n  fromIndex = Math.min(array.length, Math.max(fromIndex, 0));\n  let index = fromIndex - 1;\n  while (++index < array.length) {\n    if (cb(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n};\n\nexport const findLastIndex = <T>(\n  array: readonly T[],\n  cb: (element: T, index: number, array: readonly T[]) => boolean,\n  fromIndex: number = array.length - 1,\n) => {\n  if (fromIndex < 0) {\n    fromIndex = array.length + fromIndex;\n  }\n  fromIndex = Math.min(array.length - 1, Math.max(fromIndex, 0));\n  let index = fromIndex + 1;\n  while (--index > -1) {\n    if (cb(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n};\n\nexport const isTransparent = (color: string) => {\n  const isRGBTransparent = color.length === 5 && color.substr(4, 1) === \"0\";\n  const isRRGGBBTransparent = color.length === 9 && color.substr(7, 2) === \"00\";\n  return (\n    isRGBTransparent ||\n    isRRGGBBTransparent ||\n    color === colors.elementBackground[0]\n  );\n};\n\nexport type ResolvablePromise<T> = Promise<T> & {\n  resolve: [T] extends [undefined] ? (value?: T) => void : (value: T) => void;\n  reject: (error: Error) => void;\n};\nexport const resolvablePromise = <T>() => {\n  let resolve!: any;\n  let reject!: any;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  (promise as any).resolve = resolve;\n  (promise as any).reject = reject;\n  return promise as ResolvablePromise<T>;\n};\n\n/**\n * @param func handler taking at most single parameter (event).\n */\nexport const withBatchedUpdates = <\n  TFunction extends ((event: any) => void) | (() => void)\n>(\n  func: Parameters<TFunction>[\"length\"] extends 0 | 1 ? TFunction : never,\n) =>\n  ((event) => {\n    unstable_batchedUpdates(func as TFunction, event);\n  }) as TFunction;\n\n//https://stackoverflow.com/a/9462382/8418\nexport const nFormatter = (num: number, digits: number): string => {\n  const si = [\n    { value: 1, symbol: \"b\" },\n    { value: 1e3, symbol: \"k\" },\n    { value: 1e6, symbol: \"M\" },\n    { value: 1e9, symbol: \"G\" },\n  ];\n  const rx = /\\.0+$|(\\.[0-9]*[1-9])0+$/;\n  let index;\n  for (index = si.length - 1; index > 0; index--) {\n    if (num >= si[index].value) {\n      break;\n    }\n  }\n  return (\n    (num / si[index].value).toFixed(digits).replace(rx, \"$1\") + si[index].symbol\n  );\n};\n\nexport const getVersion = () => {\n  return (\n    document.querySelector<HTMLMetaElement>('meta[name=\"version\"]')?.content ||\n    DEFAULT_VERSION\n  );\n};\n\n// Adapted from https://github.com/Modernizr/Modernizr/blob/master/feature-detects/emoji.js\nexport const supportsEmoji = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    return false;\n  }\n  const offset = 12;\n  ctx.fillStyle = \"#f00\";\n  ctx.textBaseline = \"top\";\n  ctx.font = \"32px Arial\";\n  // Modernizr used 🐨, but it is sort of supported on Windows 7.\n  // Luckily 😀 isn't supported.\n  ctx.fillText(\"😀\", 0, 0);\n  return ctx.getImageData(offset, offset, 1, 1).data[0] !== 0;\n};\n\nexport const getNearestScrollableContainer = (\n  element: HTMLElement,\n): HTMLElement | Document => {\n  let parent = element.parentElement;\n  while (parent) {\n    if (parent === document.body) {\n      return document;\n    }\n    const { overflowY } = window.getComputedStyle(parent);\n    const hasScrollableContent = parent.scrollHeight > parent.clientHeight;\n    if (\n      hasScrollableContent &&\n      (overflowY === \"auto\" || overflowY === \"scroll\")\n    ) {\n      return parent;\n    }\n    parent = parent.parentElement;\n  }\n  return document;\n};\n\nexport const focusNearestParent = (element: HTMLInputElement) => {\n  let parent = element.parentElement;\n  while (parent) {\n    if (parent.tabIndex > -1) {\n      parent.focus();\n      return;\n    }\n    parent = parent.parentElement;\n  }\n};\n","import oc from \"open-color\";\nimport {\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_TEXT_ALIGN,\n  EXPORT_SCALES,\n} from \"./constants\";\nimport { t } from \"./i18n\";\nimport { AppState, NormalizedZoomValue } from \"./types\";\nimport { getDateTime } from \"./utils\";\n\nconst defaultExportScale = EXPORT_SCALES.includes(devicePixelRatio)\n  ? devicePixelRatio\n  : 1;\n\nexport const getDefaultAppState = (): Omit<\n  AppState,\n  \"offsetTop\" | \"offsetLeft\" | \"width\" | \"height\"\n> => {\n  return {\n    theme: \"light\",\n    collaborators: new Map(),\n    currentChartType: \"bar\",\n    currentItemBackgroundColor: \"transparent\",\n    currentItemEndArrowhead: \"arrow\",\n    currentItemFillStyle: \"hachure\",\n    currentItemFontFamily: DEFAULT_FONT_FAMILY,\n    currentItemFontSize: DEFAULT_FONT_SIZE,\n    currentItemLinearStrokeSharpness: \"round\",\n    currentItemOpacity: 100,\n    currentItemRoughness: 1,\n    currentItemStartArrowhead: null,\n    currentItemStrokeColor: oc.black,\n    currentItemStrokeSharpness: \"sharp\",\n    currentItemStrokeStyle: \"solid\",\n    currentItemStrokeWidth: 1,\n    currentItemTextAlign: DEFAULT_TEXT_ALIGN,\n    cursorButton: \"up\",\n    draggingElement: null,\n    editingElement: null,\n    editingGroupId: null,\n    editingLinearElement: null,\n    elementLocked: false,\n    elementType: \"selection\",\n    errorMessage: null,\n    exportBackground: true,\n    exportScale: defaultExportScale,\n    exportEmbedScene: false,\n    exportWithDarkMode: false,\n    fileHandle: null,\n    gridSize: null,\n    isBindingEnabled: true,\n    isLibraryOpen: false,\n    isLoading: false,\n    isResizing: false,\n    isRotating: false,\n    lastPointerDownWith: \"mouse\",\n    multiElement: null,\n    name: `${t(\"labels.untitled\")}-${getDateTime()}`,\n    openMenu: null,\n    openPopup: null,\n    pasteDialog: { shown: false, data: null },\n    previousSelectedElementIds: {},\n    resizingElement: null,\n    scrolledOutside: false,\n    scrollX: 0,\n    scrollY: 0,\n    selectedElementIds: {},\n    selectedGroupIds: {},\n    selectionElement: null,\n    shouldCacheIgnoreZoom: false,\n    showHelpDialog: false,\n    showStats: false,\n    startBoundElement: null,\n    suggestedBindings: [],\n    toastMessage: null,\n    viewBackgroundColor: oc.white,\n    zenModeEnabled: false,\n    zoom: { value: 1 as NormalizedZoomValue, translation: { x: 0, y: 0 } },\n    viewModeEnabled: false,\n  };\n};\n\n/**\n * Config containing all AppState keys. Used to determine whether given state\n *  prop should be stripped when exporting to given storage type.\n */\nconst APP_STATE_STORAGE_CONF = (<\n  Values extends {\n    /** whether to keep when storing to browser storage (localStorage/IDB) */\n    browser: boolean;\n    /** whether to keep when exporting to file/database */\n    export: boolean;\n  },\n  T extends Record<keyof AppState, Values>\n>(\n  config: { [K in keyof T]: K extends keyof AppState ? T[K] : never },\n) => config)({\n  theme: { browser: true, export: false },\n  collaborators: { browser: false, export: false },\n  currentChartType: { browser: true, export: false },\n  currentItemBackgroundColor: { browser: true, export: false },\n  currentItemEndArrowhead: { browser: true, export: false },\n  currentItemFillStyle: { browser: true, export: false },\n  currentItemFontFamily: { browser: true, export: false },\n  currentItemFontSize: { browser: true, export: false },\n  currentItemLinearStrokeSharpness: { browser: true, export: false },\n  currentItemOpacity: { browser: true, export: false },\n  currentItemRoughness: { browser: true, export: false },\n  currentItemStartArrowhead: { browser: true, export: false },\n  currentItemStrokeColor: { browser: true, export: false },\n  currentItemStrokeSharpness: { browser: true, export: false },\n  currentItemStrokeStyle: { browser: true, export: false },\n  currentItemStrokeWidth: { browser: true, export: false },\n  currentItemTextAlign: { browser: true, export: false },\n  cursorButton: { browser: true, export: false },\n  draggingElement: { browser: false, export: false },\n  editingElement: { browser: false, export: false },\n  editingGroupId: { browser: true, export: false },\n  editingLinearElement: { browser: false, export: false },\n  elementLocked: { browser: true, export: false },\n  elementType: { browser: true, export: false },\n  errorMessage: { browser: false, export: false },\n  exportBackground: { browser: true, export: false },\n  exportEmbedScene: { browser: true, export: false },\n  exportScale: { browser: true, export: false },\n  exportWithDarkMode: { browser: true, export: false },\n  fileHandle: { browser: false, export: false },\n  gridSize: { browser: true, export: true },\n  height: { browser: false, export: false },\n  isBindingEnabled: { browser: false, export: false },\n  isLibraryOpen: { browser: false, export: false },\n  isLoading: { browser: false, export: false },\n  isResizing: { browser: false, export: false },\n  isRotating: { browser: false, export: false },\n  lastPointerDownWith: { browser: true, export: false },\n  multiElement: { browser: false, export: false },\n  name: { browser: true, export: false },\n  offsetLeft: { browser: false, export: false },\n  offsetTop: { browser: false, export: false },\n  openMenu: { browser: true, export: false },\n  openPopup: { browser: false, export: false },\n  pasteDialog: { browser: false, export: false },\n  previousSelectedElementIds: { browser: true, export: false },\n  resizingElement: { browser: false, export: false },\n  scrolledOutside: { browser: true, export: false },\n  scrollX: { browser: true, export: false },\n  scrollY: { browser: true, export: false },\n  selectedElementIds: { browser: true, export: false },\n  selectedGroupIds: { browser: true, export: false },\n  selectionElement: { browser: false, export: false },\n  shouldCacheIgnoreZoom: { browser: true, export: false },\n  showHelpDialog: { browser: false, export: false },\n  showStats: { browser: true, export: false },\n  startBoundElement: { browser: false, export: false },\n  suggestedBindings: { browser: false, export: false },\n  toastMessage: { browser: false, export: false },\n  viewBackgroundColor: { browser: true, export: true },\n  width: { browser: false, export: false },\n  zenModeEnabled: { browser: true, export: false },\n  zoom: { browser: true, export: false },\n  viewModeEnabled: { browser: false, export: false },\n});\n\nconst _clearAppStateForStorage = <ExportType extends \"export\" | \"browser\">(\n  appState: Partial<AppState>,\n  exportType: ExportType,\n) => {\n  type ExportableKeys = {\n    [K in keyof typeof APP_STATE_STORAGE_CONF]: typeof APP_STATE_STORAGE_CONF[K][ExportType] extends true\n      ? K\n      : never;\n  }[keyof typeof APP_STATE_STORAGE_CONF];\n  const stateForExport = {} as { [K in ExportableKeys]?: typeof appState[K] };\n  for (const key of Object.keys(appState) as (keyof typeof appState)[]) {\n    const propConfig = APP_STATE_STORAGE_CONF[key];\n    if (propConfig?.[exportType]) {\n      // @ts-ignore see https://github.com/microsoft/TypeScript/issues/31445\n      stateForExport[key] = appState[key];\n    }\n  }\n  return stateForExport;\n};\n\nexport const clearAppStateForLocalStorage = (appState: Partial<AppState>) => {\n  return _clearAppStateForStorage(appState, \"browser\");\n};\n\nexport const cleanAppStateForExport = (appState: Partial<AppState>) => {\n  return _clearAppStateForStorage(appState, \"export\");\n};\n","import { useCallback, useState } from \"react\";\n\nexport const useCallbackRefState = <T>() => {\n  const [refValue, setRefValue] = useState<T | null>(null);\n  const refCallback = useCallback((value: T | null) => setRefValue(value), []);\n  return [refValue, refCallback] as const;\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  ExcalidrawGenericElement,\n  ExcalidrawFreeDrawElement,\n} from \"./types\";\n\nexport const isGenericElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawGenericElement => {\n  return (\n    element != null &&\n    (element.type === \"selection\" ||\n      element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\")\n  );\n};\n\nexport const isTextElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawTextElement => {\n  return element != null && element.type === \"text\";\n};\n\nexport const isFreeDrawElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawFreeDrawElement => {\n  return element != null && isFreeDrawElementType(element.type);\n};\n\nexport const isFreeDrawElementType = (\n  elementType: ExcalidrawElement[\"type\"],\n): boolean => {\n  return elementType === \"freedraw\";\n};\n\nexport const isLinearElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return element != null && isLinearElementType(element.type);\n};\n\nexport const isLinearElementType = (\n  elementType: ExcalidrawElement[\"type\"],\n): boolean => {\n  return (\n    elementType === \"arrow\" || elementType === \"line\" // || elementType === \"freedraw\"\n  );\n};\n\nexport const isBindingElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return element != null && isBindingElementType(element.type);\n};\n\nexport const isBindingElementType = (\n  elementType: ExcalidrawElement[\"type\"],\n): boolean => {\n  return elementType === \"arrow\";\n};\n\nexport const isBindableElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\" ||\n      element.type === \"text\")\n  );\n};\n\nexport const isExcalidrawElement = (element: any): boolean => {\n  return (\n    element?.type === \"text\" ||\n    element?.type === \"diamond\" ||\n    element?.type === \"rectangle\" ||\n    element?.type === \"ellipse\" ||\n    element?.type === \"arrow\" ||\n    element?.type === \"freedraw\" ||\n    element?.type === \"line\"\n  );\n};\n","import { NormalizedZoomValue, Point, Zoom } from \"./types\";\nimport { LINE_CONFIRM_THRESHOLD } from \"./constants\";\nimport { ExcalidrawLinearElement } from \"./element/types\";\n\nexport const rotate = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number,\n): [number, number] =>\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n\nexport const rotatePoint = (\n  point: Point,\n  center: Point,\n  angle: number,\n): [number, number] => rotate(point[0], point[1], center[0], center[1], angle);\n\nexport const adjustXYWithRotation = (\n  sides: {\n    n?: boolean;\n    e?: boolean;\n    s?: boolean;\n    w?: boolean;\n  },\n  x: number,\n  y: number,\n  angle: number,\n  deltaX1: number,\n  deltaY1: number,\n  deltaX2: number,\n  deltaY2: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n  return [x, y];\n};\n\nexport const getPointOnAPath = (point: Point, path: Point[]) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine: number = 0;\n  let idx: number = 0;\n\n  // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n\n    lastX = x2;\n    lastY = y2;\n\n    // if a point is not within the domain of the line segment\n    // it is not on the line segment\n    if (px < x1 || px > x2) {\n      return false;\n    }\n\n    // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n\n    // coefficient for the line (p0, p1)\n    const kL = (y2 - y1) / (x2 - x1);\n\n    // coefficient for the line segment (p0, point)\n    const kP1 = (py - y1) / (px - x1);\n\n    // coefficient for the line segment (point, p1)\n    const kP2 = (py - y2) / (px - x2);\n\n    // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n\n    // using it for floating point comparisons\n    const epsilon = 0.3;\n\n    // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    }\n\n    // store the coefficient because we are goint to need it\n    kLine = kL;\n    idx = i;\n\n    return true;\n  });\n\n  // Return a coordinate that is always on the line segment\n  if (retVal === true) {\n    return { x: point[0], y: kLine * point[0], segment: idx };\n  }\n\n  return null;\n};\n\nexport const distance2d = (x1: number, y1: number, x2: number, y2: number) => {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n};\n\nexport const centerPoint = (a: Point, b: Point): Point => {\n  return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n};\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = (\n  points: ExcalidrawLinearElement[\"points\"],\n  /** supply if you want the loop detection to account for current zoom */\n  zoomValue: Zoom[\"value\"] = 1 as NormalizedZoomValue,\n): boolean => {\n  if (points.length >= 3) {\n    const [first, last] = [points[0], points[points.length - 1]];\n    const distance = distance2d(first[0], first[1], last[0], last[1]);\n\n    // Adjusting LINE_CONFIRM_THRESHOLD to current zoom so that when zoomed in\n    // really close we make the threshold smaller, and vice versa.\n    return distance <= LINE_CONFIRM_THRESHOLD / zoomValue;\n  }\n  return false;\n};\n\n// Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\nexport const isPointInPolygon = (\n  points: Point[],\n  x: number,\n  y: number,\n): boolean => {\n  const vertices = points.length;\n\n  // There must be at least 3 vertices in polygon\n  if (vertices < 3) {\n    return false;\n  }\n  const extreme: Point = [Number.MAX_SAFE_INTEGER, y];\n  const p: Point = [x, y];\n  let count = 0;\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n    if (doSegmentsIntersect(current, next, p, extreme)) {\n      if (orderedColinearOrientation(current, p, next) === 0) {\n        return isPointWithinBounds(current, p, next);\n      }\n      count++;\n    }\n  }\n  // true if count is off\n  return count % 2 === 1;\n};\n\n// Returns whether `q` lies inside the segment/rectangle defined by `p` and `r`.\n// This is an approximation to \"does `q` lie on a segment `pr`\" check.\nconst isPointWithinBounds = (p: Point, q: Point, r: Point) => {\n  return (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  );\n};\n\n// For the ordered points p, q, r, return\n// 0 if p, q, r are colinear\n// 1 if Clockwise\n// 2 if counterclickwise\nconst orderedColinearOrientation = (p: Point, q: Point, r: Point) => {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  if (val === 0) {\n    return 0;\n  }\n  return val > 0 ? 1 : 2;\n};\n\n// Check is p1q1 intersects with p2q2\nconst doSegmentsIntersect = (p1: Point, q1: Point, p2: Point, q2: Point) => {\n  const o1 = orderedColinearOrientation(p1, q1, p2);\n  const o2 = orderedColinearOrientation(p1, q1, q2);\n  const o3 = orderedColinearOrientation(p2, q2, p1);\n  const o4 = orderedColinearOrientation(p2, q2, q1);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n  if (o1 === 0 && isPointWithinBounds(p1, p2, q1)) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n  if (o2 === 0 && isPointWithinBounds(p1, q2, q1)) {\n    return true;\n  }\n\n  // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n  if (o3 === 0 && isPointWithinBounds(p2, p1, q2)) {\n    return true;\n  }\n\n  // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n  if (o4 === 0 && isPointWithinBounds(p2, q1, q2)) {\n    return true;\n  }\n\n  return false;\n};\n\n// TODO: Rounding this point causes some shake when free drawing\nexport const getGridPoint = (\n  x: number,\n  y: number,\n  gridSize: number | null,\n): [number, number] => {\n  if (gridSize) {\n    return [\n      Math.round(x / gridSize) * gridSize,\n      Math.round(y / gridSize) * gridSize,\n    ];\n  }\n  return [x, y];\n};\n","import { Point } from \"./types\";\n\nexport const getSizeFromPoints = (points: readonly Point[]) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\n\nexport const rescalePoints = (\n  dimension: 0 | 1,\n  nextDimensionSize: number,\n  prevPoints: readonly Point[],\n): Point[] => {\n  const prevDimValues = prevPoints.map((point) => point[dimension]);\n  const prevMaxDimension = Math.max(...prevDimValues);\n  const prevMinDimension = Math.min(...prevDimValues);\n  const prevDimensionSize = prevMaxDimension - prevMinDimension;\n\n  const dimensionScaleFactor =\n    prevDimensionSize === 0 ? 1 : nextDimensionSize / prevDimensionSize;\n\n  let nextMinDimension = Infinity;\n\n  const scaledPoints = prevPoints.map(\n    (prevPoint) =>\n      prevPoint.map((value, currentDimension) => {\n        if (currentDimension !== dimension) {\n          return value;\n        }\n        const scaledValue = value * dimensionScaleFactor;\n        nextMinDimension = Math.min(scaledValue, nextMinDimension);\n        return scaledValue;\n      }) as [number, number],\n  );\n\n  if (scaledPoints.length === 2) {\n    // we don't tranlate two-point lines\n    return scaledPoints;\n  }\n\n  const translation = prevMinDimension - nextMinDimension;\n\n  const nextPoints = scaledPoints.map(\n    (scaledPoint) =>\n      scaledPoint.map((value, currentDimension) => {\n        return currentDimension === dimension ? value + translation : value;\n      }) as [number, number],\n  );\n\n  return nextPoints;\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n} from \"./types\";\nimport { distance2d, rotate } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Drawable, Op } from \"roughjs/bin/core\";\nimport { Point } from \"../types\";\nimport {\n  getShapeForElement,\n  generateRoughOptions,\n} from \"../renderer/renderElement\";\nimport { isFreeDrawElement, isLinearElement } from \"./typeChecks\";\nimport { rescalePoints } from \"../points\";\n\n// x and y position of top left corner, x and y position of bottom right corner\nexport type Bounds = readonly [number, number, number, number];\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n): Bounds => {\n  if (isFreeDrawElement(element)) {\n    return getFreeDrawElementAbsoluteCoords(element);\n  } else if (isLinearElement(element)) {\n    return getLinearElementAbsoluteCoords(element);\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n  ];\n};\n\nexport const pointRelativeTo = (\n  element: ExcalidrawElement,\n  absoluteCoords: Point,\n): Point => {\n  return [absoluteCoords[0] - element.x, absoluteCoords[1] - element.y];\n};\n\nexport const getDiamondPoints = (element: ExcalidrawElement) => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = 0;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\n\nexport const getCurvePathOps = (shape: Drawable): Op[] => {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\nconst getMinMaxXYFromCurvePathOps = (\n  ops: Op[],\n  transformXY?: (x: number, y: number) => [number, number],\n): [number, number, number, number] => {\n  let currentP: Point = [0, 0];\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        currentP = (data as unknown) as Point;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        // create points from bezier curve\n        // bezier curve stores data as a flattened array of three positions\n        // [x1, y1, x2, y2, x3, y3]\n        const p1 = [data[0], data[1]] as Point;\n        const p2 = [data[2], data[3]] as Point;\n        const p3 = [data[4], data[5]] as Point;\n\n        const p0 = currentP;\n        currentP = p3;\n\n        const equation = (t: number, idx: number) =>\n          Math.pow(1 - t, 3) * p3[idx] +\n          3 * t * Math.pow(1 - t, 2) * p2[idx] +\n          3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n          p0[idx] * Math.pow(t, 3);\n\n        let t = 0;\n        while (t <= 1.0) {\n          let x = equation(t, 0);\n          let y = equation(t, 1);\n          if (transformXY) {\n            [x, y] = transformXY(x, y);\n          }\n\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          t += 0.1;\n        }\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getBoundsFromPoints = (\n  points: ExcalidrawFreeDrawElement[\"points\"],\n): [number, number, number, number] => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getFreeDrawElementAbsoluteCoords = (\n  element: ExcalidrawFreeDrawElement,\n): [number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);\n\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nconst getLinearElementAbsoluteCoords = (\n  element: ExcalidrawLinearElement,\n): [number, number, number, number] => {\n  let coords: [number, number, number, number];\n\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    coords = [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  } else {\n    const shape = getShapeForElement(element) as Drawable[];\n\n    // first element is always the curve\n    const ops = getCurvePathOps(shape[0]);\n\n    const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n\n    coords = [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  }\n\n  return coords;\n};\n\nexport const getArrowheadPoints = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n) => {\n  const ops = getCurvePathOps(shape[0]);\n  if (ops.length < 1) {\n    return null;\n  }\n\n  // The index of the bCurve operation to examine.\n  const index = position === \"start\" ? 1 : ops.length - 1;\n\n  const data = ops[index].data;\n  const p3 = [data[4], data[5]] as Point;\n  const p2 = [data[2], data[3]] as Point;\n  const p1 = [data[0], data[1]] as Point;\n\n  // We need to find p0 of the bezier curve.\n  // It is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation.\n  const prevOp = ops[index - 1];\n  let p0: Point = [0, 0];\n  if (prevOp.op === \"move\") {\n    p0 = (prevOp.data as unknown) as Point;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // Ee know the last point of the arrow (or the first, if start arrowhead).\n  const [x2, y2] = position === \"start\" ? p0 : p3;\n\n  // By using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point.\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases.\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // Find the normalized direction vector based on the\n  // previously calculated points.\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = {\n    arrow: 30,\n    bar: 15,\n    dot: 15,\n  }[arrowhead]; // pixels (will differ for each arrowhead)\n\n  let length = 0;\n\n  if (arrowhead === \"arrow\") {\n    // Length for -> arrows is based on the length of the last section\n    const [cx, cy] = element.points[element.points.length - 1];\n    const [px, py] =\n      element.points.length > 1\n        ? element.points[element.points.length - 2]\n        : [0, 0];\n\n    length = Math.hypot(cx - px, cy - py);\n  } else {\n    // Length for other arrowhead types is based on the total length of the line\n    for (let i = 0; i < element.points.length; i++) {\n      const [px, py] = element.points[i - 1] || [0, 0];\n      const [cx, cy] = element.points[i];\n      length += Math.hypot(cx - px, cy - py);\n    }\n  }\n\n  // Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n  // This value is selected by minimizing a minimum size with the last segment of the arrowhead\n  const minSize = Math.min(size, length / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  if (arrowhead === \"dot\") {\n    const r = Math.hypot(ys - y2, xs - x2) + element.strokeWidth;\n    return [x2, y2, r];\n  }\n\n  const angle = {\n    arrow: 20,\n    bar: 90,\n  }[arrowhead]; // degrees\n\n  // Return points\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n  return [x2, y2, x3, y3, x4, y4];\n};\n\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n): [number, number, number, number] => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        [x, y] = rotate(element.x + x, element.y + y, cx, cy, element.angle);\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [minX, minY, maxX, maxY];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  const transformXY = (x: number, y: number) =>\n    rotate(element.x + x, element.y + y, cx, cy, element.angle);\n  return getMinMaxXYFromCurvePathOps(ops, transformXY);\n};\n\n// We could cache this stuff\nexport const getElementBounds = (\n  element: ExcalidrawElement,\n): [number, number, number, number] => {\n  let bounds: [number, number, number, number];\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  if (isFreeDrawElement(element)) {\n    const [minX, minY, maxX, maxY] = getBoundsFromPoints(\n      element.points.map(([x, y]) =>\n        rotate(x, y, cx - element.x, cy - element.y, element.angle),\n      ),\n    );\n\n    return [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  } else if (isLinearElement(element)) {\n    bounds = getLinearElementRotatedBounds(element, cx, cy);\n  } else if (element.type === \"diamond\") {\n    const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x1, cy, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    bounds = [minX, minY, maxX, maxY];\n  } else if (element.type === \"ellipse\") {\n    const w = (x2 - x1) / 2;\n    const h = (y2 - y1) / 2;\n    const cos = Math.cos(element.angle);\n    const sin = Math.sin(element.angle);\n    const ww = Math.hypot(w * cos, h * sin);\n    const hh = Math.hypot(h * cos, w * sin);\n    bounds = [cx - ww, cy - hh, cx + ww, cy + hh];\n  } else {\n    const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    bounds = [minX, minY, maxX, maxY];\n  }\n\n  return bounds;\n};\n\nexport const getCommonBounds = (\n  elements: readonly ExcalidrawElement[],\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getResizedElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  nextWidth: number,\n  nextHeight: number,\n): [number, number, number, number] => {\n  if (!(isLinearElement(element) || isFreeDrawElement(element))) {\n    return [\n      element.x,\n      element.y,\n      element.x + nextWidth,\n      element.y + nextHeight,\n    ];\n  }\n\n  const points = rescalePoints(\n    0,\n    nextWidth,\n    rescalePoints(1, nextHeight, element.points),\n  );\n\n  let bounds: [number, number, number, number];\n\n  if (isFreeDrawElement(element)) {\n    // Free Draw\n    bounds = getBoundsFromPoints(points);\n  } else {\n    // Line\n    const gen = rough.generator();\n    const curve =\n      element.strokeSharpness === \"sharp\"\n        ? gen.linearPath(\n            points as [number, number][],\n            generateRoughOptions(element),\n          )\n        : gen.curve(\n            points as [number, number][],\n            generateRoughOptions(element),\n          );\n    const ops = getCurvePathOps(curve);\n    bounds = getMinMaxXYFromCurvePathOps(ops);\n  }\n\n  const [minX, minY, maxX, maxY] = bounds;\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getElementPointsCoords = (\n  element: ExcalidrawLinearElement,\n  points: readonly (readonly [number, number])[],\n  sharpness: ExcalidrawElement[\"strokeSharpness\"],\n): [number, number, number, number] => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve =\n    sharpness === \"sharp\"\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getClosestElementBounds = (\n  elements: readonly ExcalidrawElement[],\n  from: { x: number; y: number },\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    const distance = distance2d((x1 + x2) / 2, (y1 + y2) / 2, from.x, from.y);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n\n  return getElementBounds(closestElement);\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  Arrowhead,\n  NonDeletedExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n} from \"../element/types\";\nimport {\n  isTextElement,\n  isLinearElement,\n  isFreeDrawElement,\n} from \"../element/typeChecks\";\nimport {\n  getDiamondPoints,\n  getElementAbsoluteCoords,\n  getArrowheadPoints,\n} from \"../element/bounds\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { Drawable, Options } from \"roughjs/bin/core\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport { RoughGenerator } from \"roughjs/bin/generator\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  SVG_NS,\n  distance,\n  getFontString,\n  getFontFamilyString,\n  isRTL,\n} from \"../utils\";\nimport { isPathALoop } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Zoom } from \"../types\";\nimport { getDefaultAppState } from \"../appState\";\nimport getFreeDrawShape from \"perfect-freehand\";\nimport { MAX_DECIMALS_FOR_SVG_EXPORT } from \"../constants\";\n\nconst defaultAppState = getDefaultAppState();\n\nconst getDashArrayDashed = (strokeWidth: number) => [8, 8 + strokeWidth];\n\nconst getDashArrayDotted = (strokeWidth: number) => [1.5, 6 + strokeWidth];\n\nconst getCanvasPadding = (element: ExcalidrawElement) =>\n  element.type === \"freedraw\" ? element.strokeWidth * 12 : 20;\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  canvasZoom: Zoom[\"value\"];\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n}\n\nconst generateElementCanvas = (\n  element: NonDeletedExcalidrawElement,\n  zoom: Zoom,\n): ExcalidrawElementWithCanvas => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n  const padding = getCanvasPadding(element);\n\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    let [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    x1 = Math.floor(x1);\n    x2 = Math.ceil(x2);\n    y1 = Math.floor(y1);\n    y2 = Math.ceil(y2);\n\n    canvas.width =\n      distance(x1, x2) * window.devicePixelRatio * zoom.value +\n      padding * zoom.value * 2;\n    canvas.height =\n      distance(y1, y2) * window.devicePixelRatio * zoom.value +\n      padding * zoom.value * 2;\n\n    canvasOffsetX =\n      element.x > x1\n        ? Math.floor(distance(element.x, x1)) *\n          window.devicePixelRatio *\n          zoom.value\n        : 0;\n\n    canvasOffsetY =\n      element.y > y1\n        ? Math.floor(distance(element.y, y1)) *\n          window.devicePixelRatio *\n          zoom.value\n        : 0;\n\n    context.translate(canvasOffsetX, canvasOffsetY);\n  } else {\n    canvas.width =\n      element.width * window.devicePixelRatio * zoom.value +\n      padding * zoom.value * 2;\n    canvas.height =\n      element.height * window.devicePixelRatio * zoom.value +\n      padding * zoom.value * 2;\n  }\n\n  context.translate(padding * zoom.value, padding * zoom.value);\n\n  context.scale(\n    window.devicePixelRatio * zoom.value,\n    window.devicePixelRatio * zoom.value,\n  );\n\n  const rc = rough.canvas(canvas);\n\n  drawElementOnCanvas(element, rc, context);\n\n  context.translate(-(padding * zoom.value), -(padding * zoom.value));\n  context.scale(\n    1 / (window.devicePixelRatio * zoom.value),\n    1 / (window.devicePixelRatio * zoom.value),\n  );\n  return {\n    element,\n    canvas,\n    canvasZoom: zoom.value,\n    canvasOffsetX,\n    canvasOffsetY,\n  };\n};\n\nconst drawElementOnCanvas = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n) => {\n  context.globalAlpha = element.opacity / 100;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n      rc.draw(getShapeForElement(element) as Drawable);\n      break;\n    }\n    case \"arrow\":\n    case \"line\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        rc.draw(shape);\n      });\n      break;\n    }\n    case \"freedraw\": {\n      // Draw directly to canvas\n      context.save();\n      context.fillStyle = element.strokeColor;\n\n      const path = getFreeDrawPath2D(element) as Path2D;\n\n      context.fillStyle = element.strokeColor;\n      context.fill(path);\n\n      context.restore();\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const rtl = isRTL(element.text);\n        const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n        if (shouldTemporarilyAttach) {\n          // to correctly render RTL text mixed with LTR, we have to append it\n          // to the DOM\n          document.body.appendChild(context.canvas);\n        }\n        context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n        const font = context.font;\n        context.font = getFontString(element);\n        const fillStyle = context.fillStyle;\n        context.fillStyle = element.strokeColor;\n        const textAlign = context.textAlign;\n        context.textAlign = element.textAlign as CanvasTextAlign;\n\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        for (let index = 0; index < lines.length; index++) {\n          context.fillText(\n            lines[index],\n            horizontalOffset,\n            (index + 1) * lineHeight - verticalOffset,\n          );\n        }\n        context.fillStyle = fillStyle;\n        context.font = font;\n        context.textAlign = textAlign;\n        if (shouldTemporarilyAttach) {\n          context.canvas.remove();\n        }\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n  context.globalAlpha = 1;\n};\n\nconst elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst shapeCache = new WeakMap<\n  ExcalidrawElement,\n  Drawable | Drawable[] | null\n>();\n\nexport const getShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.get(element);\n\nexport const invalidateShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.delete(element);\n\nexport const generateRoughOptions = (\n  element: ExcalidrawElement,\n  continuousPath = false,\n): Options => {\n  const options: Options = {\n    seed: element.seed,\n    strokeLineDash:\n      element.strokeStyle === \"dashed\"\n        ? getDashArrayDashed(element.strokeWidth)\n        : element.strokeStyle === \"dotted\"\n        ? getDashArrayDotted(element.strokeWidth)\n        : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    // dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    // similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth:\n      element.strokeStyle !== \"solid\"\n        ? element.strokeWidth + 0.5\n        : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    // hachureGap because if not specified, roughjs uses strokeWidth to\n    // calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: element.roughness,\n    stroke: element.strokeColor,\n    preserveVertices: continuousPath,\n  };\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      options.fillStyle = element.fillStyle;\n      options.fill =\n        element.backgroundColor === \"transparent\"\n          ? undefined\n          : element.backgroundColor;\n      if (element.type === \"ellipse\") {\n        options.curveFitting = 1;\n      }\n      return options;\n    }\n    case \"line\": {\n      if (isPathALoop(element.points)) {\n        options.fillStyle = element.fillStyle;\n        options.fill =\n          element.backgroundColor === \"transparent\"\n            ? undefined\n            : element.backgroundColor;\n      }\n      return options;\n    }\n    case \"freedraw\":\n    case \"arrow\":\n      return options;\n    default: {\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\n/**\n * Generates the element's shape and puts it into the cache.\n * @param element\n * @param generator\n */\nconst generateElementShape = (\n  element: NonDeletedExcalidrawElement,\n  generator: RoughGenerator,\n) => {\n  let shape = shapeCache.get(element) || null;\n\n  if (!shape) {\n    elementWithCanvasCache.delete(element);\n\n    switch (element.type) {\n      case \"rectangle\":\n        if (element.strokeSharpness === \"round\") {\n          const w = element.width;\n          const h = element.height;\n          const r = Math.min(w, h) * 0.25;\n          shape = generator.path(\n            `M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${\n              h - r\n            } Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${\n              h - r\n            } L 0 ${r} Q 0 0, ${r} 0`,\n            generateRoughOptions(element, true),\n          );\n        } else {\n          shape = generator.rectangle(\n            0,\n            0,\n            element.width,\n            element.height,\n            generateRoughOptions(element),\n          );\n        }\n        break;\n      case \"diamond\": {\n        const [\n          topX,\n          topY,\n          rightX,\n          rightY,\n          bottomX,\n          bottomY,\n          leftX,\n          leftY,\n        ] = getDiamondPoints(element);\n        shape = generator.polygon(\n          [\n            [topX, topY],\n            [rightX, rightY],\n            [bottomX, bottomY],\n            [leftX, leftY],\n          ],\n          generateRoughOptions(element),\n        );\n        break;\n      }\n      case \"ellipse\":\n        shape = generator.ellipse(\n          element.width / 2,\n          element.height / 2,\n          element.width,\n          element.height,\n          generateRoughOptions(element),\n        );\n        break;\n      case \"line\":\n      case \"arrow\": {\n        const options = generateRoughOptions(element);\n\n        // points array can be empty in the beginning, so it is important to add\n        // initial position to it\n        const points = element.points.length ? element.points : [[0, 0]];\n\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        if (element.strokeSharpness === \"sharp\") {\n          if (options.fill) {\n            shape = [generator.polygon(points as [number, number][], options)];\n          } else {\n            shape = [\n              generator.linearPath(points as [number, number][], options),\n            ];\n          }\n        } else {\n          shape = [generator.curve(points as [number, number][], options)];\n        }\n\n        // add lines only in arrow\n        if (element.type === \"arrow\") {\n          const { startArrowhead = null, endArrowhead = \"arrow\" } = element;\n\n          const getArrowheadShapes = (\n            element: ExcalidrawLinearElement,\n            shape: Drawable[],\n            position: \"start\" | \"end\",\n            arrowhead: Arrowhead,\n          ) => {\n            const arrowheadPoints = getArrowheadPoints(\n              element,\n              shape,\n              position,\n              arrowhead,\n            );\n\n            if (arrowheadPoints === null) {\n              return [];\n            }\n\n            // Other arrowheads here...\n            if (arrowhead === \"dot\") {\n              const [x, y, r] = arrowheadPoints;\n\n              return [\n                generator.circle(x, y, r, {\n                  ...options,\n                  fill: element.strokeColor,\n                  fillStyle: \"solid\",\n                  stroke: \"none\",\n                }),\n              ];\n            }\n\n            // Arrow arrowheads\n            const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n\n            if (element.strokeStyle === \"dotted\") {\n              // for dotted arrows caps, reduce gap to make it more legible\n              const dash = getDashArrayDotted(element.strokeWidth - 1);\n              options.strokeLineDash = [dash[0], dash[1] - 1];\n            } else {\n              // for solid/dashed, keep solid arrow cap\n              delete options.strokeLineDash;\n            }\n            return [\n              generator.line(x3, y3, x2, y2, options),\n              generator.line(x4, y4, x2, y2, options),\n            ];\n          };\n\n          if (startArrowhead !== null) {\n            const shapes = getArrowheadShapes(\n              element,\n              shape,\n              \"start\",\n              startArrowhead,\n            );\n            shape.push(...shapes);\n          }\n\n          if (endArrowhead !== null) {\n            if (endArrowhead === undefined) {\n              // Hey, we have an old arrow here!\n            }\n\n            const shapes = getArrowheadShapes(\n              element,\n              shape,\n              \"end\",\n              endArrowhead,\n            );\n            shape.push(...shapes);\n          }\n        }\n\n        break;\n      }\n      case \"freedraw\": {\n        generateFreeDrawShape(element);\n        shape = [];\n        break;\n      }\n      case \"text\": {\n        // just to ensure we don't regenerate element.canvas on rerenders\n        shape = [];\n        break;\n      }\n    }\n    shapeCache.set(element, shape);\n  }\n};\n\nconst generateElementWithCanvas = (\n  element: NonDeletedExcalidrawElement,\n  sceneState?: SceneState,\n) => {\n  const zoom: Zoom = sceneState ? sceneState.zoom : defaultAppState.zoom;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom =\n    prevElementWithCanvas &&\n    prevElementWithCanvas.canvasZoom !== zoom.value &&\n    !sceneState?.shouldCacheIgnoreZoom;\n  if (!prevElementWithCanvas || shouldRegenerateBecauseZoom) {\n    const elementWithCanvas = generateElementCanvas(element, zoom);\n\n    elementWithCanvasCache.set(element, elementWithCanvas);\n\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n};\n\nconst drawElementFromCanvas = (\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n) => {\n  const element = elementWithCanvas.element;\n  const padding = getCanvasPadding(element);\n  let [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n  // Free draw elements will otherwise \"shuffle\" as the min x and y change\n  if (isFreeDrawElement(element)) {\n    x1 = Math.floor(x1);\n    x2 = Math.ceil(x2);\n    y1 = Math.floor(y1);\n    y2 = Math.ceil(y2);\n  }\n\n  const cx = ((x1 + x2) / 2 + sceneState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + sceneState.scrollY) * window.devicePixelRatio;\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  context.translate(cx, cy);\n  context.rotate(element.angle);\n\n  context.drawImage(\n    elementWithCanvas.canvas!,\n    (-(x2 - x1) / 2) * window.devicePixelRatio -\n      (padding * elementWithCanvas.canvasZoom) / elementWithCanvas.canvasZoom,\n    (-(y2 - y1) / 2) * window.devicePixelRatio -\n      (padding * elementWithCanvas.canvasZoom) / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.width / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.height / elementWithCanvas.canvasZoom,\n  );\n  context.rotate(-element.angle);\n  context.translate(-cx, -cy);\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n\n  // Clear the nested element we appended to the DOM\n};\n\nexport const renderElement = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderOptimizations: boolean,\n  sceneState: SceneState,\n) => {\n  const generator = rc.generator;\n  switch (element.type) {\n    case \"selection\": {\n      context.translate(\n        element.x + sceneState.scrollX,\n        element.y + sceneState.scrollY,\n      );\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(0, 0, element.width, element.height);\n      context.fillStyle = fillStyle;\n      context.translate(\n        -element.x - sceneState.scrollX,\n        -element.y - sceneState.scrollY,\n      );\n      break;\n    }\n    case \"freedraw\": {\n      generateElementShape(element, generator);\n\n      if (renderOptimizations) {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          sceneState,\n        );\n        drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n      } else {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + sceneState.scrollX;\n        const cy = (y1 + y2) / 2 + sceneState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context);\n        context.translate(shiftX, shiftY);\n        context.rotate(-element.angle);\n        context.translate(-cx, -cy);\n      }\n\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"arrow\":\n    case \"text\": {\n      generateElementShape(element, generator);\n      if (renderOptimizations) {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          sceneState,\n        );\n        drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n      } else {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + sceneState.scrollX;\n        const cy = (y1 + y2) / 2 + sceneState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context);\n        context.translate(shiftX, shiftY);\n        context.rotate(-element.angle);\n        context.translate(-cx, -cy);\n      }\n      break;\n    }\n    default: {\n      // @ts-ignore\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nconst roughSVGDrawWithPrecision = (\n  rsvg: RoughSVG,\n  drawable: Drawable,\n  precision?: number,\n) => {\n  if (typeof precision === \"undefined\") {\n    return rsvg.draw(drawable);\n  }\n  const pshape: Drawable = {\n    sets: drawable.sets,\n    shape: drawable.shape,\n    options: { ...drawable.options, fixedDecimalPlaceDigits: precision },\n  };\n  return rsvg.draw(pshape);\n};\n\nexport const renderElementToSvg = (\n  element: NonDeletedExcalidrawElement,\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  offsetX?: number,\n  offsetY?: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2 - (element.x - x1);\n  const cy = (y2 - y1) / 2 - (element.y - y1);\n  const degree = (180 * element.angle) / Math.PI;\n  const generator = rsvg.generator;\n  switch (element.type) {\n    case \"selection\": {\n      // Since this is used only during editing experience, which is canvas based,\n      // this should not happen\n      throw new Error(\"Selection rendering is not supported for SVG\");\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      generateElementShape(element, generator);\n      const node = roughSVGDrawWithPrecision(\n        rsvg,\n        getShapeForElement(element) as Drawable,\n        MAX_DECIMALS_FOR_SVG_EXPORT,\n      );\n      const opacity = element.opacity / 100;\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\"stroke-linecap\", \"round\");\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n      svgRoot.appendChild(node);\n      break;\n    }\n    case \"line\":\n    case \"arrow\": {\n      generateElementShape(element, generator);\n      const group = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      const opacity = element.opacity / 100;\n      group.setAttribute(\"stroke-linecap\", \"round\");\n\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        const node = roughSVGDrawWithPrecision(\n          rsvg,\n          shape,\n          MAX_DECIMALS_FOR_SVG_EXPORT,\n        );\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        if (\n          element.type === \"line\" &&\n          isPathALoop(element.points) &&\n          element.backgroundColor !== \"transparent\"\n        ) {\n          node.setAttribute(\"fill-rule\", \"evenodd\");\n        }\n        group.appendChild(node);\n      });\n      svgRoot.appendChild(group);\n      break;\n    }\n    case \"freedraw\": {\n      generateFreeDrawShape(element);\n      const opacity = element.opacity / 100;\n      const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n      const path = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"path\");\n      node.setAttribute(\"stroke\", \"none\");\n      node.setAttribute(\"fill\", element.strokeColor);\n      path.setAttribute(\"d\", getFreeDrawSvgPath(element));\n      node.appendChild(path);\n      svgRoot.appendChild(node);\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const opacity = element.opacity / 100;\n        const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        const direction = isRTL(element.text) ? \"rtl\" : \"ltr\";\n        const textAnchor =\n          element.textAlign === \"center\"\n            ? \"middle\"\n            : element.textAlign === \"right\" || direction === \"rtl\"\n            ? \"end\"\n            : \"start\";\n        for (let i = 0; i < lines.length; i++) {\n          const text = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"text\");\n          text.textContent = lines[i];\n          text.setAttribute(\"x\", `${horizontalOffset}`);\n          text.setAttribute(\"y\", `${(i + 1) * lineHeight - verticalOffset}`);\n          text.setAttribute(\"font-family\", getFontFamilyString(element));\n          text.setAttribute(\"font-size\", `${element.fontSize}px`);\n          text.setAttribute(\"fill\", element.strokeColor);\n          text.setAttribute(\"text-anchor\", textAnchor);\n          text.setAttribute(\"style\", \"white-space: pre;\");\n          text.setAttribute(\"direction\", direction);\n          node.appendChild(text);\n        }\n        svgRoot.appendChild(node);\n      } else {\n        // @ts-ignore\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n};\n\nexport const pathsCache = new WeakMap<ExcalidrawFreeDrawElement, Path2D>([]);\n\nexport function generateFreeDrawShape(element: ExcalidrawFreeDrawElement) {\n  const svgPathData = getFreeDrawSvgPath(element);\n  const path = new Path2D(svgPathData);\n  pathsCache.set(element, path);\n  return path;\n}\n\nexport function getFreeDrawPath2D(element: ExcalidrawFreeDrawElement) {\n  return pathsCache.get(element);\n}\n\nexport function getFreeDrawSvgPath(element: ExcalidrawFreeDrawElement) {\n  const inputPoints = element.simulatePressure\n    ? element.points\n    : element.points.length\n    ? element.points.map(([x, y], i) => [x, y, element.pressures[i]])\n    : [[0, 0, 0]];\n\n  // Consider changing the options for simulated pressure vs real pressure\n  const options = {\n    simulatePressure: element.simulatePressure,\n    size: element.strokeWidth * 6,\n    thinning: 0.5,\n    smoothing: 0.5,\n    streamline: 0.5,\n    easing: (t: number) => t * (2 - t),\n    last: true,\n  };\n\n  const points = getFreeDrawShape(inputPoints as number[][], options);\n  const d: (string | number)[] = [];\n\n  let [p0, p1] = points;\n\n  d.push(\"M\", p0[0], p0[1], \"Q\");\n\n  for (let i = 0; i < points.length; i++) {\n    d.push(p0[0], p0[1], (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2);\n    p0 = p1;\n    p1 = points[i];\n  }\n\n  p1 = points[0];\n  d.push(p0[0], p0[1], (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2);\n\n  d.push(\"Z\");\n\n  return d.join(\" \");\n}\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"../element/types\";\nimport { getNonDeletedElements, isNonDeletedElement } from \"../element\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\n\ntype ElementIdKey = InstanceType<typeof LinearElementEditor>[\"elementId\"];\ntype ElementKey = ExcalidrawElement | ElementIdKey;\n\ntype SceneStateCallback = () => void;\ntype SceneStateCallbackRemover = () => void;\n\nconst isIdKey = (elementKey: ElementKey): elementKey is ElementIdKey => {\n  if (typeof elementKey === \"string\") {\n    return true;\n  }\n  return false;\n};\n\nclass Scene {\n  // ---------------------------------------------------------------------------\n  // static methods/props\n  // ---------------------------------------------------------------------------\n\n  private static sceneMapByElement = new WeakMap<ExcalidrawElement, Scene>();\n  private static sceneMapById = new Map<string, Scene>();\n\n  static mapElementToScene(elementKey: ElementKey, scene: Scene) {\n    if (isIdKey(elementKey)) {\n      this.sceneMapById.set(elementKey, scene);\n    } else {\n      this.sceneMapByElement.set(elementKey, scene);\n    }\n  }\n\n  static getScene(elementKey: ElementKey): Scene | null {\n    if (isIdKey(elementKey)) {\n      return this.sceneMapById.get(elementKey) || null;\n    }\n    return this.sceneMapByElement.get(elementKey) || null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // instance methods/props\n  // ---------------------------------------------------------------------------\n\n  private callbacks: Set<SceneStateCallback> = new Set();\n\n  private nonDeletedElements: readonly NonDeletedExcalidrawElement[] = [];\n  private elements: readonly ExcalidrawElement[] = [];\n  private elementsMap = new Map<ExcalidrawElement[\"id\"], ExcalidrawElement>();\n\n  // TODO: getAllElementsIncludingDeleted\n  getElementsIncludingDeleted() {\n    return this.elements;\n  }\n\n  // TODO: getAllNonDeletedElements\n  getElements(): readonly NonDeletedExcalidrawElement[] {\n    return this.nonDeletedElements;\n  }\n\n  getElement(id: ExcalidrawElement[\"id\"]): ExcalidrawElement | null {\n    return this.elementsMap.get(id) || null;\n  }\n\n  getNonDeletedElement(\n    id: ExcalidrawElement[\"id\"],\n  ): NonDeleted<ExcalidrawElement> | null {\n    const element = this.getElement(id);\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n    return null;\n  }\n\n  // TODO: Rename methods here, this is confusing\n  getNonDeletedElements(\n    ids: readonly ExcalidrawElement[\"id\"][],\n  ): NonDeleted<ExcalidrawElement>[] {\n    const result: NonDeleted<ExcalidrawElement>[] = [];\n    ids.forEach((id) => {\n      const element = this.getNonDeletedElement(id);\n      if (element != null) {\n        result.push(element);\n      }\n    });\n    return result;\n  }\n\n  replaceAllElements(nextElements: readonly ExcalidrawElement[]) {\n    this.elements = nextElements;\n    this.elementsMap.clear();\n    nextElements.forEach((element) => {\n      this.elementsMap.set(element.id, element);\n      Scene.mapElementToScene(element, this);\n    });\n    this.nonDeletedElements = getNonDeletedElements(this.elements);\n    this.informMutation();\n  }\n\n  informMutation() {\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n\n  addCallback(cb: SceneStateCallback): SceneStateCallbackRemover {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n\n    this.callbacks.add(cb);\n\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n      this.callbacks.delete(cb);\n    };\n  }\n\n  destroy() {\n    Scene.sceneMapById.forEach((scene, elementKey) => {\n      if (scene === this) {\n        Scene.sceneMapById.delete(elementKey);\n      }\n    });\n    // done not for memory leaks, but to guard against possible late fires\n    // (I guess?)\n    this.callbacks.clear();\n  }\n}\n\nexport default Scene;\n","import { Random } from \"roughjs/bin/math\";\nimport { nanoid } from \"nanoid\";\n\nlet random = new Random(Date.now());\nlet testIdBase = 0;\n\nexport const randomInteger = () => Math.floor(random.next() * 2 ** 31);\n\nexport const reseed = (seed: number) => {\n  random = new Random(seed);\n  testIdBase = 0;\n};\n\nexport const randomId = () =>\n  process.env.NODE_ENV === \"test\" ? `id${testIdBase++}` : nanoid();\n","import { ExcalidrawElement } from \"./types\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport Scene from \"../scene/Scene\";\nimport { getSizeFromPoints } from \"../points\";\nimport { randomInteger } from \"../random\";\nimport { Point } from \"../types\";\n\ntype ElementUpdate<TElement extends ExcalidrawElement> = Omit<\n  Partial<TElement>,\n  \"id\" | \"version\" | \"versionNonce\"\n>;\n\n// This function tracks updates of text elements for the purposes for collaboration.\n// The version is used to compare updates when more than one user is working in\n// the same drawing. Note: this will trigger the component to update. Make sure you\n// are calling it either from a React event handler or within unstable_batchedUpdates().\nexport const mutateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n) => {\n  let didChange = false;\n\n  // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n  const { points } = updates as any;\n\n  if (typeof points !== \"undefined\") {\n    updates = { ...getSizeFromPoints(points), ...updates };\n  }\n\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update in case its deep prop was mutated\n        (typeof value !== \"object\" || value === null || key === \"groupIds\")\n      ) {\n        continue;\n      }\n\n      if (key === \"points\") {\n        const prevPoints = (element as any)[key];\n        const nextPoints = value;\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let index = prevPoints.length;\n          while (--index) {\n            const prevPoint: Point = prevPoints[index];\n            const nextPoint: Point = nextPoints[index];\n            if (\n              prevPoint[0] !== nextPoint[0] ||\n              prevPoint[1] !== nextPoint[1]\n            ) {\n              didChangePoints = true;\n              break;\n            }\n          }\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n\n      (element as any)[key] = value;\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return;\n  }\n\n  if (\n    typeof updates.height !== \"undefined\" ||\n    typeof updates.width !== \"undefined\" ||\n    typeof points !== \"undefined\"\n  ) {\n    invalidateShapeForElement(element);\n  }\n\n  element.version++;\n  element.versionNonce = randomInteger();\n  Scene.getScene(element)?.informMutation();\n};\n\nexport const newElementWith = <TElement extends ExcalidrawElement>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n): TElement => {\n  let didChange = false;\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update in case its deep prop was mutated\n        (typeof value !== \"object\" || value === null || key === \"groupIds\")\n      ) {\n        continue;\n      }\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return element;\n  }\n\n  return {\n    ...element,\n    ...updates,\n    version: element.version + 1,\n    versionNonce: randomInteger(),\n  };\n};\n\n/**\n * Mutates element and updates `version` & `versionNonce`.\n *\n * NOTE: does not trigger re-render.\n */\nexport const bumpVersion = (\n  element: Mutable<ExcalidrawElement>,\n  version?: ExcalidrawElement[\"version\"],\n) => {\n  element.version = (version ?? element.version) + 1;\n  element.versionNonce = randomInteger();\n  return element;\n};\n","import { ExcalidrawElement } from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { isFreeDrawElement, isLinearElement } from \"./typeChecks\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\n\nexport const isInvisiblySmallElement = (\n  element: ExcalidrawElement,\n): boolean => {\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    return element.points.length < 2;\n  }\n  return element.width === 0 && element.height === 0;\n};\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport const getPerfectElementSize = (\n  elementType: string,\n  width: number,\n  height: number,\n): { width: number; height: number } => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (\n    elementType === \"line\" ||\n    elementType === \"arrow\" ||\n    elementType === \"freedraw\"\n  ) {\n    const lockedAngle =\n      Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height =\n        Math.round(absWidth * Math.tan(lockedAngle)) * Math.sign(height) ||\n        height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return { width, height };\n};\n\nexport const resizePerfectLineForNWHandler = (\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n) => {\n  const anchorX = element.x + element.width;\n  const anchorY = element.y + element.height;\n  const distanceToAnchorX = x - anchorX;\n  const distanceToAnchorY = y - anchorY;\n  if (Math.abs(distanceToAnchorX) < Math.abs(distanceToAnchorY) / 2) {\n    mutateElement(element, {\n      x: anchorX,\n      width: 0,\n      y,\n      height: -distanceToAnchorY,\n    });\n  } else if (Math.abs(distanceToAnchorY) < Math.abs(element.width) / 2) {\n    mutateElement(element, {\n      y: anchorY,\n      height: 0,\n    });\n  } else {\n    const nextHeight =\n      Math.sign(distanceToAnchorY) *\n      Math.sign(distanceToAnchorX) *\n      element.width;\n    mutateElement(element, {\n      x,\n      y: anchorY - nextHeight,\n      width: -distanceToAnchorX,\n      height: nextHeight,\n    });\n  }\n};\n\nexport const getNormalizedDimensions = (\n  element: Pick<ExcalidrawElement, \"width\" | \"height\" | \"x\" | \"y\">,\n): {\n  width: ExcalidrawElement[\"width\"];\n  height: ExcalidrawElement[\"height\"];\n  x: ExcalidrawElement[\"x\"];\n  y: ExcalidrawElement[\"y\"];\n} => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y,\n  };\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n\n  return ret;\n};\n","import { GroupId, ExcalidrawElement, NonDeleted } from \"./element/types\";\nimport { AppState } from \"./types\";\nimport { getSelectedElements } from \"./scene\";\n\nexport const selectGroup = (\n  groupId: GroupId,\n  appState: AppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): AppState => {\n  const elementsInGroup = elements.filter((element) =>\n    element.groupIds.includes(groupId),\n  );\n\n  if (elementsInGroup.length < 2) {\n    if (\n      appState.selectedGroupIds[groupId] ||\n      appState.editingGroupId === groupId\n    ) {\n      return {\n        ...appState,\n        selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: false },\n        editingGroupId: null,\n      };\n    }\n    return appState;\n  }\n\n  return {\n    ...appState,\n    selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: true },\n    selectedElementIds: {\n      ...appState.selectedElementIds,\n      ...Object.fromEntries(\n        elementsInGroup.map((element) => [element.id, true]),\n      ),\n    },\n  };\n};\n\n/**\n * If the element's group is selected, don't render an individual\n * selection border around it.\n */\nexport const isSelectedViaGroup = (\n  appState: AppState,\n  element: ExcalidrawElement,\n) => getSelectedGroupForElement(appState, element) != null;\n\nexport const getSelectedGroupForElement = (\n  appState: AppState,\n  element: ExcalidrawElement,\n) =>\n  element.groupIds\n    .filter((groupId) => groupId !== appState.editingGroupId)\n    .find((groupId) => appState.selectedGroupIds[groupId]);\n\nexport const getSelectedGroupIds = (appState: AppState): GroupId[] =>\n  Object.entries(appState.selectedGroupIds)\n    .filter(([groupId, isSelected]) => isSelected)\n    .map(([groupId, isSelected]) => groupId);\n\n/**\n * When you select an element, you often want to actually select the whole group it's in, unless\n * you're currently editing that group.\n */\nexport const selectGroupsForSelectedElements = (\n  appState: AppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): AppState => {\n  let nextAppState: AppState = { ...appState, selectedGroupIds: {} };\n\n  const selectedElements = getSelectedElements(elements, appState);\n\n  if (!selectedElements.length) {\n    return { ...nextAppState, editingGroupId: null };\n  }\n\n  for (const selectedElement of selectedElements) {\n    let groupIds = selectedElement.groupIds;\n    if (appState.editingGroupId) {\n      // handle the case where a group is nested within a group\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = selectGroup(groupId, nextAppState, elements);\n    }\n  }\n\n  return nextAppState;\n};\n\nexport const editGroupForSelectedElement = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n): AppState => {\n  return {\n    ...appState,\n    editingGroupId: element.groupIds.length ? element.groupIds[0] : null,\n    selectedGroupIds: {},\n    selectedElementIds: {\n      [element.id]: true,\n    },\n  };\n};\n\nexport const isElementInGroup = (element: ExcalidrawElement, groupId: string) =>\n  element.groupIds.includes(groupId);\n\nexport const getElementsInGroup = (\n  elements: readonly ExcalidrawElement[],\n  groupId: string,\n) => elements.filter((element) => isElementInGroup(element, groupId));\n\nexport const getSelectedGroupIdForElement = (\n  element: ExcalidrawElement,\n  selectedGroupIds: { [groupId: string]: boolean },\n) => element.groupIds.find((groupId) => selectedGroupIds[groupId]);\n\nexport const getNewGroupIdsForDuplication = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  editingGroupId: AppState[\"editingGroupId\"],\n  mapper: (groupId: GroupId) => GroupId,\n) => {\n  const copy = [...groupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const endIndex =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  for (let index = 0; index < endIndex; index++) {\n    copy[index] = mapper(copy[index]);\n  }\n\n  return copy;\n};\n\nexport const addToGroup = (\n  prevGroupIds: ExcalidrawElement[\"groupIds\"],\n  newGroupId: GroupId,\n  editingGroupId: AppState[\"editingGroupId\"],\n) => {\n  // insert before the editingGroupId, or push to the end.\n  const groupIds = [...prevGroupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const positionToInsert =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  groupIds.splice(positionToInsert, 0, newGroupId);\n  return groupIds;\n};\n\nexport const removeFromSelectedGroups = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  selectedGroupIds: { [groupId: string]: boolean },\n) => groupIds.filter((groupId) => !selectedGroupIds[groupId]);\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawGenericElement,\n  NonDeleted,\n  TextAlign,\n  GroupId,\n  VerticalAlign,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n  FontFamilyValues,\n} from \"../element/types\";\nimport { measureText, getFontString } from \"../utils\";\nimport { randomInteger, randomId } from \"../random\";\nimport { newElementWith } from \"./mutateElement\";\nimport { getNewGroupIdsForDuplication } from \"../groups\";\nimport { AppState } from \"../types\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { adjustXYWithRotation } from \"../math\";\nimport { getResizedElementAbsoluteCoords } from \"./bounds\";\n\ntype ElementConstructorOpts = MarkOptional<\n  Omit<ExcalidrawGenericElement, \"id\" | \"type\" | \"isDeleted\">,\n  | \"width\"\n  | \"height\"\n  | \"angle\"\n  | \"groupIds\"\n  | \"boundElementIds\"\n  | \"seed\"\n  | \"version\"\n  | \"versionNonce\"\n>;\n\nconst _newElementBase = <T extends ExcalidrawElement>(\n  type: T[\"type\"],\n  {\n    x,\n    y,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    width = 0,\n    height = 0,\n    angle = 0,\n    groupIds = [],\n    strokeSharpness,\n    boundElementIds = null,\n    ...rest\n  }: ElementConstructorOpts & Omit<Partial<ExcalidrawGenericElement>, \"type\">,\n) => ({\n  id: rest.id || randomId(),\n  type,\n  x,\n  y,\n  width,\n  height,\n  angle,\n  strokeColor,\n  backgroundColor,\n  fillStyle,\n  strokeWidth,\n  strokeStyle,\n  roughness,\n  opacity,\n  groupIds,\n  strokeSharpness,\n  seed: rest.seed ?? randomInteger(),\n  version: rest.version || 1,\n  versionNonce: rest.versionNonce ?? 0,\n  isDeleted: false as false,\n  boundElementIds,\n});\n\nexport const newElement = (\n  opts: {\n    type: ExcalidrawGenericElement[\"type\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawGenericElement> =>\n  _newElementBase<ExcalidrawGenericElement>(opts.type, opts);\n\n/** computes element x/y offset based on textAlign/verticalAlign */\nconst getTextElementPositionOffsets = (\n  opts: {\n    textAlign: ExcalidrawTextElement[\"textAlign\"];\n    verticalAlign: ExcalidrawTextElement[\"verticalAlign\"];\n  },\n  metrics: {\n    width: number;\n    height: number;\n  },\n) => {\n  return {\n    x:\n      opts.textAlign === \"center\"\n        ? metrics.width / 2\n        : opts.textAlign === \"right\"\n        ? metrics.width\n        : 0,\n    y: opts.verticalAlign === \"middle\" ? metrics.height / 2 : 0,\n  };\n};\n\nexport const newTextElement = (\n  opts: {\n    text: string;\n    fontSize: number;\n    fontFamily: FontFamilyValues;\n    textAlign: TextAlign;\n    verticalAlign: VerticalAlign;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawTextElement> => {\n  const metrics = measureText(opts.text, getFontString(opts));\n  const offsets = getTextElementPositionOffsets(opts, metrics);\n  const textElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawTextElement>(\"text\", opts),\n      text: opts.text,\n      fontSize: opts.fontSize,\n      fontFamily: opts.fontFamily,\n      textAlign: opts.textAlign,\n      verticalAlign: opts.verticalAlign,\n      x: opts.x - offsets.x,\n      y: opts.y - offsets.y,\n      width: metrics.width,\n      height: metrics.height,\n      baseline: metrics.baseline,\n    },\n    {},\n  );\n  return textElement;\n};\n\nconst getAdjustedDimensions = (\n  element: ExcalidrawTextElement,\n  nextText: string,\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  baseline: number;\n} => {\n  const {\n    width: nextWidth,\n    height: nextHeight,\n    baseline: nextBaseline,\n  } = measureText(nextText, getFontString(element));\n  const { textAlign, verticalAlign } = element;\n\n  let x: number;\n  let y: number;\n\n  if (textAlign === \"center\" && verticalAlign === \"middle\") {\n    const prevMetrics = measureText(element.text, getFontString(element));\n    const offsets = getTextElementPositionOffsets(element, {\n      width: nextWidth - prevMetrics.width,\n      height: nextHeight - prevMetrics.height,\n    });\n\n    x = element.x - offsets.x;\n    y = element.y - offsets.y;\n  } else {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n\n    [x, y] = adjustXYWithRotation(\n      {\n        s: true,\n        e: textAlign === \"center\" || textAlign === \"left\",\n        w: textAlign === \"center\" || textAlign === \"right\",\n      },\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    x: Number.isFinite(x) ? x : element.x,\n    y: Number.isFinite(y) ? y : element.y,\n    baseline: nextBaseline,\n  };\n};\n\nexport const updateTextElement = (\n  element: ExcalidrawTextElement,\n  { text, isDeleted }: { text: string; isDeleted?: boolean },\n): ExcalidrawTextElement => {\n  return newElementWith(element, {\n    text,\n    isDeleted: isDeleted ?? element.isDeleted,\n    ...getAdjustedDimensions(element, text),\n  });\n};\n\nexport const newFreeDrawElement = (\n  opts: {\n    type: \"freedraw\";\n    points?: ExcalidrawFreeDrawElement[\"points\"];\n    simulatePressure: boolean;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawFreeDrawElement> => {\n  return {\n    ..._newElementBase<ExcalidrawFreeDrawElement>(opts.type, opts),\n    points: opts.points || [],\n    pressures: [],\n    simulatePressure: opts.simulatePressure,\n    lastCommittedPoint: null,\n  };\n};\n\nexport const newLinearElement = (\n  opts: {\n    type: ExcalidrawLinearElement[\"type\"];\n    startArrowhead: Arrowhead | null;\n    endArrowhead: Arrowhead | null;\n    points?: ExcalidrawLinearElement[\"points\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawLinearElement> => {\n  return {\n    ..._newElementBase<ExcalidrawLinearElement>(opts.type, opts),\n    points: opts.points || [],\n    lastCommittedPoint: null,\n    startBinding: null,\n    endBinding: null,\n    startArrowhead: opts.startArrowhead,\n    endArrowhead: opts.endArrowhead,\n  };\n};\n\n// Simplified deep clone for the purpose of cloning ExcalidrawElement only\n// (doesn't clone Date, RegExp, Map, Set, Typed arrays etc.)\n//\n// Adapted from https://github.com/lukeed/klona\nexport const deepCopyElement = (val: any, depth: number = 0) => {\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    const tmp =\n      typeof val.constructor === \"function\"\n        ? Object.create(Object.getPrototypeOf(val))\n        : {};\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy top-level shape property, which we want to regenerate\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n        tmp[key] = deepCopyElement(val[key], depth + 1);\n      }\n    }\n    return tmp;\n  }\n\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n    while (k--) {\n      arr[k] = deepCopyElement(val[k], depth + 1);\n    }\n    return arr;\n  }\n\n  return val;\n};\n\n/**\n * Duplicate an element, often used in the alt-drag operation.\n * Note that this method has gotten a bit complicated since the\n * introduction of gruoping/ungrouping elements.\n * @param editingGroupId The current group being edited. The new\n *                       element will inherit this group and its\n *                       parents.\n * @param groupIdMapForOperation A Map that maps old group IDs to\n *                               duplicated ones. If you are duplicating\n *                               multiple elements at once, share this map\n *                               amongst all of them\n * @param element Element to duplicate\n * @param overrides Any element properties to override\n */\nexport const duplicateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  editingGroupId: AppState[\"editingGroupId\"],\n  groupIdMapForOperation: Map<GroupId, GroupId>,\n  element: TElement,\n  overrides?: Partial<TElement>,\n): TElement => {\n  let copy: TElement = deepCopyElement(element);\n  if (process.env.NODE_ENV === \"test\") {\n    copy.id = `${copy.id}_copy`;\n    // `window.h` may not be defined in some unit tests\n    if (\n      window.h?.app\n        ?.getSceneElementsIncludingDeleted()\n        .find((el) => el.id === copy.id)\n    ) {\n      copy.id += \"_copy\";\n    }\n  } else {\n    copy.id = randomId();\n  }\n  copy.seed = randomInteger();\n  copy.groupIds = getNewGroupIdsForDuplication(\n    copy.groupIds,\n    editingGroupId,\n    (groupId) => {\n      if (!groupIdMapForOperation.has(groupId)) {\n        groupIdMapForOperation.set(groupId, randomId());\n      }\n      return groupIdMapForOperation.get(groupId)!;\n    },\n  );\n  if (overrides) {\n    copy = Object.assign(copy, overrides);\n  }\n  return copy;\n};\n","import { ExcalidrawElement, PointerType } from \"./types\";\n\nimport { getElementAbsoluteCoords, Bounds } from \"./bounds\";\nimport { rotate } from \"../math\";\nimport { Zoom } from \"../types\";\n\nexport type TransformHandleDirection =\n  | \"n\"\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"nw\"\n  | \"ne\"\n  | \"sw\"\n  | \"se\";\n\nexport type TransformHandleType = TransformHandleDirection | \"rotation\";\n\nexport type TransformHandle = [number, number, number, number];\nexport type TransformHandles = Partial<\n  { [T in TransformHandleType]: TransformHandle }\n>;\nexport type MaybeTransformHandleType = TransformHandleType | false;\n\nconst transformHandleSizes: { [k in PointerType]: number } = {\n  mouse: 8,\n  pen: 16,\n  touch: 28,\n};\n\nconst ROTATION_RESIZE_HANDLE_GAP = 16;\n\nexport const OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst OMIT_SIDES_FOR_TEXT_ELEMENT = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_SLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  nw: true,\n  se: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_BACKSLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  ne: true,\n  sw: true,\n};\n\nconst generateTransformHandle = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n): TransformHandle => {\n  const [xx, yy] = rotate(x + width / 2, y + height / 2, cx, cy, angle);\n  return [xx - width / 2, yy - height / 2, width, height];\n};\n\nexport const getTransformHandlesFromCoords = (\n  [x1, y1, x2, y2]: Bounds,\n  angle: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n  omitSides: { [T in TransformHandleType]?: boolean } = {},\n): TransformHandles => {\n  const size = transformHandleSizes[pointerType];\n  const handleWidth = size / zoom.value;\n  const handleHeight = size / zoom.value;\n\n  const handleMarginX = size / zoom.value;\n  const handleMarginY = size / zoom.value;\n\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n\n  const dashedLineMargin = 4 / zoom.value;\n\n  const centeringOffset = (size - 8) / (2 * zoom.value);\n\n  const transformHandles: TransformHandles = {\n    nw: omitSides.nw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    ne: omitSides.ne\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    sw: omitSides.sw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    se: omitSides.se\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    rotation: omitSides.rotation\n      ? undefined\n      : generateTransformHandle(\n          x1 + width / 2 - handleWidth / 2,\n          y1 -\n            dashedLineMargin -\n            handleMarginY +\n            centeringOffset -\n            ROTATION_RESIZE_HANDLE_GAP / zoom.value,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n  };\n\n  // We only want to show height handles (all cardinal directions)  above a certain size\n  // Note: we render using \"mouse\" size so we should also use \"mouse\" size for this check\n  const minimumSizeForEightHandles =\n    (5 * transformHandleSizes.mouse) / zoom.value;\n  if (Math.abs(width) > minimumSizeForEightHandles) {\n    if (!omitSides.n) {\n      transformHandles.n = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y1 - dashedLineMargin - handleMarginY + centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.s) {\n      transformHandles.s = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y2 + dashedLineMargin - centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n  if (Math.abs(height) > minimumSizeForEightHandles) {\n    if (!omitSides.w) {\n      transformHandles.w = generateTransformHandle(\n        x1 - dashedLineMargin - handleMarginX + centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.e) {\n      transformHandles.e = generateTransformHandle(\n        x2 + dashedLineMargin - centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n\n  return transformHandles;\n};\n\nexport const getTransformHandles = (\n  element: ExcalidrawElement,\n  zoom: Zoom,\n  pointerType: PointerType = \"mouse\",\n): TransformHandles => {\n  let omitSides: { [T in TransformHandleType]?: boolean } = {};\n  if (\n    element.type === \"arrow\" ||\n    element.type === \"line\" ||\n    element.type === \"freedraw\"\n  ) {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n      if (p1[0] === 0 || p1[1] === 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] > 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] > 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] < 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] < 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      }\n    }\n  } else if (element.type === \"text\") {\n    omitSides = OMIT_SIDES_FOR_TEXT_ELEMENT;\n  }\n\n  return getTransformHandlesFromCoords(\n    getElementAbsoluteCoords(element),\n    element.angle,\n    zoom,\n    pointerType,\n    omitSides,\n  );\n};\n","/**\n * This is a 2D Projective Geometric Algebra implementation.\n *\n * For wider context on geometric algebra visit see https://bivector.net.\n *\n * For this specific algebra see cheatsheet https://bivector.net/2DPGA.pdf.\n *\n * Converted from generator written by enki, with a ton of added on top.\n *\n * This library uses 8-vectors to represent points, directions and lines\n * in 2D space.\n *\n * An array `[a, b, c, d, e, f, g, h]` represents a n(8)vector:\n *   a + b*e0 + c*e1 + d*e2 + e*e01 + f*e20 + g*e12 + h*e012\n *\n * See GAPoint, GALine, GADirection and GATransform modules for common\n * operations.\n */\n\nexport type Point = NVector;\nexport type Direction = NVector;\nexport type Line = NVector;\nexport type Transform = NVector;\n\nexport const point = (x: number, y: number): Point => [0, 0, 0, 0, y, x, 1, 0];\n\nexport const origin = (): Point => [0, 0, 0, 0, 0, 0, 1, 0];\n\nexport const direction = (x: number, y: number): Direction => {\n  const norm = Math.hypot(x, y); // same as `inorm(direction(x, y))`\n  return [0, 0, 0, 0, y / norm, x / norm, 0, 0];\n};\n\nexport const offset = (x: number, y: number): Direction => [\n  0,\n  0,\n  0,\n  0,\n  y,\n  x,\n  0,\n  0,\n];\n\n/// This is the \"implementation\" part of the library\n\ntype NVector = readonly [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n];\n\n// These are labels for what each number in an nvector represents\nconst NVECTOR_BASE = [\"1\", \"e0\", \"e1\", \"e2\", \"e01\", \"e20\", \"e12\", \"e012\"];\n\n// Used to represent points, lines and transformations\nexport const nvector = (value: number = 0, index: number = 0): NVector => {\n  const result = [0, 0, 0, 0, 0, 0, 0, 0];\n  if (index < 0 || index > 7) {\n    throw new Error(`Expected \\`index\\` betwen 0 and 7, got \\`${index}\\``);\n  }\n  if (value !== 0) {\n    result[index] = value;\n  }\n  return (result as unknown) as NVector;\n};\n\nconst STRING_EPSILON = 0.000001;\nexport const toString = (nvector: NVector): string => {\n  const result = nvector\n    .map((value, index) =>\n      Math.abs(value) > STRING_EPSILON\n        ? value.toFixed(7).replace(/(\\.|0+)$/, \"\") +\n          (index > 0 ? NVECTOR_BASE[index] : \"\")\n        : null,\n    )\n    .filter((representation) => representation != null)\n    .join(\" + \");\n  return result === \"\" ? \"0\" : result;\n};\n\n// Reverse the order of the basis blades.\nexport const reverse = (nvector: NVector): NVector => [\n  nvector[0],\n  nvector[1],\n  nvector[2],\n  nvector[3],\n  -nvector[4],\n  -nvector[5],\n  -nvector[6],\n  -nvector[7],\n];\n\n// Poincare duality operator.\nexport const dual = (nvector: NVector): NVector => [\n  nvector[7],\n  nvector[6],\n  nvector[5],\n  nvector[4],\n  nvector[3],\n  nvector[2],\n  nvector[1],\n  nvector[0],\n];\n\n// Clifford Conjugation\nexport const conjugate = (nvector: NVector): NVector => [\n  nvector[0],\n  -nvector[1],\n  -nvector[2],\n  -nvector[3],\n  -nvector[4],\n  -nvector[5],\n  -nvector[6],\n  nvector[7],\n];\n\n// Main involution\nexport const involute = (nvector: NVector): NVector => [\n  nvector[0],\n  -nvector[1],\n  -nvector[2],\n  -nvector[3],\n  nvector[4],\n  nvector[5],\n  nvector[6],\n  -nvector[7],\n];\n\n// Multivector addition\nexport const add = (a: NVector, b: NVector | number): NVector => {\n  if (isNumber(b)) {\n    return [a[0] + b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]];\n  }\n  return [\n    a[0] + b[0],\n    a[1] + b[1],\n    a[2] + b[2],\n    a[3] + b[3],\n    a[4] + b[4],\n    a[5] + b[5],\n    a[6] + b[6],\n    a[7] + b[7],\n  ];\n};\n\n// Multivector subtraction\nexport const sub = (a: NVector, b: NVector | number): NVector => {\n  if (isNumber(b)) {\n    return [a[0] - b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]];\n  }\n  return [\n    a[0] - b[0],\n    a[1] - b[1],\n    a[2] - b[2],\n    a[3] - b[3],\n    a[4] - b[4],\n    a[5] - b[5],\n    a[6] - b[6],\n    a[7] - b[7],\n  ];\n};\n\n// The geometric product.\nexport const mul = (a: NVector, b: NVector | number): NVector => {\n  if (isNumber(b)) {\n    return [\n      a[0] * b,\n      a[1] * b,\n      a[2] * b,\n      a[3] * b,\n      a[4] * b,\n      a[5] * b,\n      a[6] * b,\n      a[7] * b,\n    ];\n  }\n  return [\n    mulScalar(a, b),\n    b[1] * a[0] +\n      b[0] * a[1] -\n      b[4] * a[2] +\n      b[5] * a[3] +\n      b[2] * a[4] -\n      b[3] * a[5] -\n      b[7] * a[6] -\n      b[6] * a[7],\n    b[2] * a[0] + b[0] * a[2] - b[6] * a[3] + b[3] * a[6],\n    b[3] * a[0] + b[6] * a[2] + b[0] * a[3] - b[2] * a[6],\n    b[4] * a[0] +\n      b[2] * a[1] -\n      b[1] * a[2] +\n      b[7] * a[3] +\n      b[0] * a[4] +\n      b[6] * a[5] -\n      b[5] * a[6] +\n      b[3] * a[7],\n    b[5] * a[0] -\n      b[3] * a[1] +\n      b[7] * a[2] +\n      b[1] * a[3] -\n      b[6] * a[4] +\n      b[0] * a[5] +\n      b[4] * a[6] +\n      b[2] * a[7],\n    b[6] * a[0] + b[3] * a[2] - b[2] * a[3] + b[0] * a[6],\n    b[7] * a[0] +\n      b[6] * a[1] +\n      b[5] * a[2] +\n      b[4] * a[3] +\n      b[3] * a[4] +\n      b[2] * a[5] +\n      b[1] * a[6] +\n      b[0] * a[7],\n  ];\n};\n\nexport const mulScalar = (a: NVector, b: NVector): number =>\n  b[0] * a[0] + b[2] * a[2] + b[3] * a[3] - b[6] * a[6];\n\n// The outer/exterior/wedge product.\nexport const meet = (a: NVector, b: NVector): NVector => [\n  b[0] * a[0],\n  b[1] * a[0] + b[0] * a[1],\n  b[2] * a[0] + b[0] * a[2],\n  b[3] * a[0] + b[0] * a[3],\n  b[4] * a[0] + b[2] * a[1] - b[1] * a[2] + b[0] * a[4],\n  b[5] * a[0] - b[3] * a[1] + b[1] * a[3] + b[0] * a[5],\n  b[6] * a[0] + b[3] * a[2] - b[2] * a[3] + b[0] * a[6],\n  b[7] * a[0] +\n    b[6] * a[1] +\n    b[5] * a[2] +\n    b[4] * a[3] +\n    b[3] * a[4] +\n    b[2] * a[5] +\n    b[1] * a[6],\n];\n\n// The regressive product.\nexport const join = (a: NVector, b: NVector): NVector => [\n  joinScalar(a, b),\n  a[1] * b[7] + a[4] * b[5] - a[5] * b[4] + a[7] * b[1],\n  a[2] * b[7] - a[4] * b[6] + a[6] * b[4] + a[7] * b[2],\n  a[3] * b[7] + a[5] * b[6] - a[6] * b[5] + a[7] * b[3],\n  a[4] * b[7] + a[7] * b[4],\n  a[5] * b[7] + a[7] * b[5],\n  a[6] * b[7] + a[7] * b[6],\n  a[7] * b[7],\n];\n\nexport const joinScalar = (a: NVector, b: NVector): number =>\n  a[0] * b[7] +\n  a[1] * b[6] +\n  a[2] * b[5] +\n  a[3] * b[4] +\n  a[4] * b[3] +\n  a[5] * b[2] +\n  a[6] * b[1] +\n  a[7] * b[0];\n\n// The inner product.\nexport const dot = (a: NVector, b: NVector): NVector => [\n  b[0] * a[0] + b[2] * a[2] + b[3] * a[3] - b[6] * a[6],\n  b[1] * a[0] +\n    b[0] * a[1] -\n    b[4] * a[2] +\n    b[5] * a[3] +\n    b[2] * a[4] -\n    b[3] * a[5] -\n    b[7] * a[6] -\n    b[6] * a[7],\n  b[2] * a[0] + b[0] * a[2] - b[6] * a[3] + b[3] * a[6],\n  b[3] * a[0] + b[6] * a[2] + b[0] * a[3] - b[2] * a[6],\n  b[4] * a[0] + b[7] * a[3] + b[0] * a[4] + b[3] * a[7],\n  b[5] * a[0] + b[7] * a[2] + b[0] * a[5] + b[2] * a[7],\n  b[6] * a[0] + b[0] * a[6],\n  b[7] * a[0] + b[0] * a[7],\n];\n\nexport const norm = (a: NVector): number =>\n  Math.sqrt(Math.abs(a[0] * a[0] - a[2] * a[2] - a[3] * a[3] + a[6] * a[6]));\n\nexport const inorm = (a: NVector): number =>\n  Math.sqrt(Math.abs(a[7] * a[7] - a[5] * a[5] - a[4] * a[4] + a[1] * a[1]));\n\nexport const normalized = (a: NVector): NVector => {\n  const n = norm(a);\n  if (n === 0 || n === 1) {\n    return a;\n  }\n  const sign = a[6] < 0 ? -1 : 1;\n  return mul(a, sign / n);\n};\n\nexport const inormalized = (a: NVector): NVector => {\n  const n = inorm(a);\n  if (n === 0 || n === 1) {\n    return a;\n  }\n  return mul(a, 1 / n);\n};\n\nconst isNumber = (a: any): a is number => typeof a === \"number\";\n\nexport const E0: NVector = nvector(1, 1);\nexport const E1: NVector = nvector(1, 2);\nexport const E2: NVector = nvector(1, 3);\nexport const E01: NVector = nvector(1, 4);\nexport const E20: NVector = nvector(1, 5);\nexport const E12: NVector = nvector(1, 6);\nexport const E012: NVector = nvector(1, 7);\nexport const I = E012;\n","import * as GA from \"./ga\";\nimport { Line, Point } from \"./ga\";\n\n/**\n * A line is stored as an array `[0, c, a, b, 0, 0, 0, 0]` representing:\n *   c * e0 + a * e1 + b*e2\n *\n * This maps to a standard formula `a * x + b * y + c`.\n *\n * `(-b, a)` correponds to a 2D vector parallel to the line. The lines\n * have a natural orientation, corresponding to that vector.\n *\n * The magnitude (\"norm\") of the line is `sqrt(a ^ 2 + b ^ 2)`.\n * `c / norm(line)` is the oriented distance from line to origin.\n */\n\n// Returns line with direction (x, y) through origin\nexport const vector = (x: number, y: number): Line =>\n  GA.normalized([0, 0, -y, x, 0, 0, 0, 0]);\n\n// For equation ax + by + c = 0.\nexport const equation = (a: number, b: number, c: number): Line =>\n  GA.normalized([0, c, a, b, 0, 0, 0, 0]);\n\nexport const through = (from: Point, to: Point): Line =>\n  GA.normalized(GA.join(to, from));\n\nexport const orthogonal = (line: Line, point: Point): Line =>\n  GA.dot(line, point);\n\n// Returns a line perpendicular to the line through `against` and `intersection`\n// going through `intersection`.\nexport const orthogonalThrough = (against: Point, intersection: Point): Line =>\n  orthogonal(through(against, intersection), intersection);\n\nexport const parallel = (line: Line, distance: number): Line => {\n  const result = line.slice();\n  result[1] -= distance;\n  return (result as unknown) as Line;\n};\n\nexport const parallelThrough = (line: Line, point: Point): Line =>\n  orthogonal(orthogonal(point, line), point);\n\nexport const distance = (line1: Line, line2: Line): number =>\n  GA.inorm(GA.meet(line1, line2));\n\nexport const angle = (line1: Line, line2: Line): number =>\n  Math.acos(GA.dot(line1, line2)[0]);\n\n// The orientation of the line\nexport const sign = (line: Line): number => Math.sign(line[1]);\n","import * as GA from \"./ga\";\nimport * as GALine from \"./galines\";\nimport { Point, Line, join } from \"./ga\";\n\nexport const from = ([x, y]: readonly [number, number]): Point => [\n  0,\n  0,\n  0,\n  0,\n  y,\n  x,\n  1,\n  0,\n];\n\nexport const toTuple = (point: Point): [number, number] => [point[5], point[4]];\n\nexport const abs = (point: Point): Point => [\n  0,\n  0,\n  0,\n  0,\n  Math.abs(point[4]),\n  Math.abs(point[5]),\n  1,\n  0,\n];\n\nexport const intersect = (line1: Line, line2: Line): Point =>\n  GA.normalized(GA.meet(line1, line2));\n\n// Projects `point` onto the `line`.\n// The returned point is the closest point on the `line` to the `point`.\nexport const project = (point: Point, line: Line): Point =>\n  intersect(GALine.orthogonal(line, point), line);\n\nexport const distance = (point1: Point, point2: Point): number =>\n  GA.norm(join(point1, point2));\n\nexport const distanceToLine = (point: Point, line: Line): number =>\n  GA.joinScalar(point, line);\n","import * as GA from \"./ga\";\nimport { Line, Direction, Point } from \"./ga\";\n\n/**\n * A direction is stored as an array `[0, 0, 0, 0, y, x, 0, 0]` representing\n * vector `(x, y)`.\n */\n\nexport const from = (point: Point): Point => [\n  0,\n  0,\n  0,\n  0,\n  point[4],\n  point[5],\n  0,\n  0,\n];\n\nexport const fromTo = (from: Point, to: Point): Direction =>\n  GA.inormalized([0, 0, 0, 0, to[4] - from[4], to[5] - from[5], 0, 0]);\n\nexport const orthogonal = (direction: Direction): Direction =>\n  GA.inormalized([0, 0, 0, 0, -direction[5], direction[4], 0, 0]);\n\nexport const orthogonalToLine = (line: Line): Direction => GA.mul(line, GA.I);\n","import * as GA from \"./ga\";\nimport { Line, Direction, Point, Transform } from \"./ga\";\nimport * as GADirection from \"./gadirections\";\n\n/**\n * TODO: docs\n */\n\nexport const rotation = (pivot: Point, angle: number): Transform =>\n  GA.add(GA.mul(pivot, Math.sin(angle / 2)), Math.cos(angle / 2));\n\nexport const translation = (direction: Direction): Transform => [\n  1,\n  0,\n  0,\n  0,\n  -(0.5 * direction[5]),\n  0.5 * direction[4],\n  0,\n  0,\n];\n\nexport const translationOrthogonal = (\n  direction: Direction,\n  distance: number,\n): Transform => {\n  const scale = 0.5 * distance;\n  return [1, 0, 0, 0, scale * direction[4], scale * direction[5], 0, 0];\n};\n\nexport const translationAlong = (line: Line, distance: number): Transform =>\n  GA.add(GA.mul(GADirection.orthogonalToLine(line), 0.5 * distance), 1);\n\nexport const compose = (motor1: Transform, motor2: Transform): Transform =>\n  GA.mul(motor2, motor1);\n\nexport const apply = (\n  motor: Transform,\n  nvector: Point | Direction | Line,\n): Point | Direction | Line =>\n  GA.normalized(GA.mul(GA.mul(motor, nvector), GA.reverse(motor)));\n","import * as GA from \"../ga\";\nimport * as GAPoint from \"../gapoints\";\nimport * as GADirection from \"../gadirections\";\nimport * as GALine from \"../galines\";\nimport * as GATransform from \"../gatransforms\";\n\nimport {\n  distance2d,\n  rotatePoint,\n  isPathALoop,\n  isPointInPolygon,\n  rotate,\n} from \"../math\";\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport {\n  NonDeletedExcalidrawElement,\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawRectangleElement,\n  ExcalidrawDiamondElement,\n  ExcalidrawTextElement,\n  ExcalidrawEllipseElement,\n  NonDeleted,\n  ExcalidrawFreeDrawElement,\n} from \"./types\";\n\nimport { getElementAbsoluteCoords, getCurvePathOps, Bounds } from \"./bounds\";\nimport { Point } from \"../types\";\nimport { Drawable } from \"roughjs/bin/core\";\nimport { AppState } from \"../types\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\n\nconst isElementDraggableFromInside = (\n  element: NonDeletedExcalidrawElement,\n): boolean => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n\n  if (element.type === \"freedraw\") {\n    return true;\n  }\n\n  const isDraggableFromInside = element.backgroundColor !== \"transparent\";\n\n  if (element.type === \"line\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n\n  return isDraggableFromInside;\n};\n\nexport const hitTest = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n): boolean => {\n  // How many pixels off the shape boundary we still consider a hit\n  const threshold = 10 / appState.zoom.value;\n  const point: Point = [x, y];\n\n  if (isElementSelected(appState, element)) {\n    return isPointHittingElementBoundingBox(element, point, threshold);\n  }\n\n  return isHittingElementNotConsideringBoundingBox(element, appState, point);\n};\n\nexport const isHittingElementBoundingBoxWithoutHittingElement = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n\n  return (\n    !isHittingElementNotConsideringBoundingBox(element, appState, [x, y]) &&\n    isPointHittingElementBoundingBox(element, [x, y], threshold)\n  );\n};\n\nconst isHittingElementNotConsideringBoundingBox = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  point: Point,\n): boolean => {\n  const threshold = 10 / appState.zoom.value;\n\n  const check =\n    element.type === \"text\"\n      ? isStrictlyInside\n      : isElementDraggableFromInside(element)\n      ? isInsideCheck\n      : isNearCheck;\n\n  return hitTestPointAgainstElement({ element, point, threshold, check });\n};\n\nconst isElementSelected = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n) => appState.selectedElementIds[element.id];\n\nconst isPointHittingElementBoundingBox = (\n  element: NonDeleted<ExcalidrawElement>,\n  [x, y]: Point,\n  threshold: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const elementCenterX = (x1 + x2) / 2;\n  const elementCenterY = (y1 + y2) / 2;\n  // reverse rotate to take element's angle into account.\n  const [rotatedX, rotatedY] = rotate(\n    x,\n    y,\n    elementCenterX,\n    elementCenterY,\n    -element.angle,\n  );\n\n  return (\n    rotatedX > x1 - threshold &&\n    rotatedX < x2 + threshold &&\n    rotatedY > y1 - threshold &&\n    rotatedY < y2 + threshold\n  );\n};\n\nexport const bindingBorderTest = (\n  element: NonDeleted<ExcalidrawBindableElement>,\n  { x, y }: { x: number; y: number },\n): boolean => {\n  const threshold = maxBindingGap(element, element.width, element.height);\n  const check = isOutsideCheck;\n  const point: Point = [x, y];\n  return hitTestPointAgainstElement({ element, point, threshold, check });\n};\n\nexport const maxBindingGap = (\n  element: ExcalidrawElement,\n  elementWidth: number,\n  elementHeight: number,\n): number => {\n  // Aligns diamonds with rectangles\n  const shapeRatio = element.type === \"diamond\" ? 1 / Math.sqrt(2) : 1;\n  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);\n  // We make the bindable boundary bigger for bigger elements\n  return Math.max(16, Math.min(0.25 * smallerDimension, 32));\n};\n\ntype HitTestArgs = {\n  element: NonDeletedExcalidrawElement;\n  point: Point;\n  threshold: number;\n  check: (distance: number, threshold: number) => boolean;\n};\n\nconst hitTestPointAgainstElement = (args: HitTestArgs): boolean => {\n  switch (args.element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n    case \"ellipse\":\n      const distance = distanceToBindableElement(args.element, args.point);\n      return args.check(distance, args.threshold);\n    case \"freedraw\": {\n      if (\n        !args.check(\n          distanceToRectangle(args.element, args.point),\n          args.threshold,\n        )\n      ) {\n        return false;\n      }\n\n      return hitTestFreeDrawElement(args.element, args.point, args.threshold);\n    }\n    case \"arrow\":\n    case \"line\":\n      return hitTestLinear(args);\n    case \"selection\":\n      console.warn(\n        \"This should not happen, we need to investigate why it does.\",\n      );\n      return false;\n  }\n};\n\nexport const distanceToBindableElement = (\n  element: ExcalidrawBindableElement,\n  point: Point,\n): number => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return distanceToRectangle(element, point);\n    case \"diamond\":\n      return distanceToDiamond(element, point);\n    case \"ellipse\":\n      return distanceToEllipse(element, point);\n  }\n};\n\nconst isStrictlyInside = (distance: number, threshold: number): boolean => {\n  return distance < 0;\n};\n\nconst isInsideCheck = (distance: number, threshold: number): boolean => {\n  return distance < threshold;\n};\n\nconst isNearCheck = (distance: number, threshold: number): boolean => {\n  return Math.abs(distance) < threshold;\n};\n\nconst isOutsideCheck = (distance: number, threshold: number): boolean => {\n  return 0 <= distance && distance < threshold;\n};\n\nconst distanceToRectangle = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawTextElement\n    | ExcalidrawFreeDrawElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  return Math.max(\n    GAPoint.distanceToLine(pointRel, GALine.equation(0, 1, -hheight)),\n    GAPoint.distanceToLine(pointRel, GALine.equation(1, 0, -hwidth)),\n  );\n};\n\nconst distanceToDiamond = (\n  element: ExcalidrawDiamondElement,\n  point: Point,\n): number => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const side = GALine.equation(hheight, hwidth, -hheight * hwidth);\n  return GAPoint.distanceToLine(pointRel, side);\n};\n\nconst distanceToEllipse = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): number => {\n  const [pointRel, tangent] = ellipseParamsForTest(element, point);\n  return -GALine.sign(tangent) * GAPoint.distanceToLine(pointRel, tangent);\n};\n\nconst ellipseParamsForTest = (\n  element: ExcalidrawEllipseElement,\n  point: Point,\n): [GA.Point, GA.Line] => {\n  const [, pointRel, hwidth, hheight] = pointRelativeToElement(element, point);\n  const [px, py] = GAPoint.toTuple(pointRel);\n\n  // We're working in positive quadrant, so start with `t = 45deg`, `tx=cos(t)`\n  let tx = 0.707;\n  let ty = 0.707;\n\n  const a = hwidth;\n  const b = hheight;\n\n  // This is a numerical method to find the params tx, ty at which\n  // the ellipse has the closest point to the given point\n  [0, 1, 2, 3].forEach((_) => {\n    const xx = a * tx;\n    const yy = b * ty;\n\n    const ex = ((a * a - b * b) * tx ** 3) / a;\n    const ey = ((b * b - a * a) * ty ** 3) / b;\n\n    const rx = xx - ex;\n    const ry = yy - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n\n    tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n    ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  });\n\n  const closestPoint = GA.point(a * tx, b * ty);\n\n  const tangent = GALine.orthogonalThrough(pointRel, closestPoint);\n  return [pointRel, tangent];\n};\n\nconst hitTestFreeDrawElement = (\n  element: ExcalidrawFreeDrawElement,\n  point: Point,\n  threshold: number,\n): boolean => {\n  // Check point-distance-to-line-segment for every segment in the\n  // element's points (its input points, not its outline points).\n  // This is... okay? It's plenty fast, but the GA library may\n  // have a faster option.\n\n  let x: number;\n  let y: number;\n\n  if (element.angle === 0) {\n    x = point[0] - element.x;\n    y = point[1] - element.y;\n  } else {\n    // Counter-rotate the point around center before testing\n    const [minX, minY, maxX, maxY] = getElementAbsoluteCoords(element);\n    const rotatedPoint = rotatePoint(\n      point,\n      [minX + (maxX - minX) / 2, minY + (maxY - minY) / 2],\n      -element.angle,\n    );\n    x = rotatedPoint[0] - element.x;\n    y = rotatedPoint[1] - element.y;\n  }\n\n  let [A, B] = element.points;\n  let P: readonly [number, number];\n\n  // For freedraw dots\n  if (element.points.length === 2) {\n    return (\n      distance2d(A[0], A[1], x, y) < threshold ||\n      distance2d(B[0], B[1], x, y) < threshold\n    );\n  }\n\n  // For freedraw lines\n  for (let i = 1; i < element.points.length - 1; i++) {\n    const delta = [B[0] - A[0], B[1] - A[1]];\n    const length = Math.hypot(delta[1], delta[0]);\n\n    const U = [delta[0] / length, delta[1] / length];\n    const C = [x - A[0], y - A[1]];\n    const d = (C[0] * U[0] + C[1] * U[1]) / Math.hypot(U[1], U[0]);\n    P = [A[0] + U[0] * d, A[1] + U[1] * d];\n\n    const da = distance2d(P[0], P[1], A[0], A[1]);\n    const db = distance2d(P[0], P[1], B[0], B[1]);\n\n    P = db < da && da > length ? B : da < db && db > length ? A : P;\n\n    if (Math.hypot(y - P[1], x - P[0]) < threshold) {\n      return true;\n    }\n\n    A = B;\n    B = element.points[i + 1];\n  }\n\n  return false;\n};\n\nconst hitTestLinear = (args: HitTestArgs): boolean => {\n  const { element, threshold } = args;\n  if (!getShapeForElement(element)) {\n    return false;\n  }\n  const [point, pointAbs, hwidth, hheight] = pointRelativeToElement(\n    args.element,\n    args.point,\n  );\n  const side1 = GALine.equation(0, 1, -hheight);\n  const side2 = GALine.equation(1, 0, -hwidth);\n  if (\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side1), threshold) ||\n    !isInsideCheck(GAPoint.distanceToLine(pointAbs, side2), threshold)\n  ) {\n    return false;\n  }\n  const [relX, relY] = GAPoint.toTuple(point);\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  if (args.check === isInsideCheck) {\n    const hit = shape.some((subshape) =>\n      hitTestCurveInside(subshape, relX, relY, element.strokeSharpness),\n    );\n    if (hit) {\n      return true;\n    }\n  }\n\n  // hit test all \"subshapes\" of the linear element\n  return shape.some((subshape) =>\n    hitTestRoughShape(subshape, relX, relY, threshold),\n  );\n};\n\n// Returns:\n//   1. the point relative to the elements (x, y) position\n//   2. the point relative to the element's center with positive (x, y)\n//   3. half element width\n//   4. half element height\n//\n// Note that for linear elements the (x, y) position is not at the\n// top right corner of their boundary.\n//\n// Rectangles, diamonds and ellipses are symmetrical over axes,\n// and other elements have a rectangular boundary,\n// so we only need to perform hit tests for the positive quadrant.\nconst pointRelativeToElement = (\n  element: ExcalidrawElement,\n  pointTuple: Point,\n): [GA.Point, GA.Point, number, number] => {\n  const point = GAPoint.from(pointTuple);\n  const elementCoords = getElementAbsoluteCoords(element);\n  const center = coordsCenter(elementCoords);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const pointRotated = GATransform.apply(rotate, point);\n  const pointRelToCenter = GA.sub(pointRotated, GADirection.from(center));\n  const pointRelToCenterAbs = GAPoint.abs(pointRelToCenter);\n  const elementPos = GA.offset(element.x, element.y);\n  const pointRelToPos = GA.sub(pointRotated, elementPos);\n  const [ax, ay, bx, by] = elementCoords;\n  const halfWidth = (bx - ax) / 2;\n  const halfHeight = (by - ay) / 2;\n  return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];\n};\n\n// Returns point in absolute coordinates\nexport const pointInAbsoluteCoords = (\n  element: ExcalidrawElement,\n  // Point relative to the element position\n  point: Point,\n): Point => {\n  const [x, y] = point;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2;\n  const cy = (y2 - y1) / 2;\n  const [rotatedX, rotatedY] = rotate(x, y, cx, cy, element.angle);\n  return [element.x + rotatedX, element.y + rotatedY];\n};\n\nconst relativizationToElementCenter = (\n  element: ExcalidrawElement,\n): GA.Transform => {\n  const elementCoords = getElementAbsoluteCoords(element);\n  const center = coordsCenter(elementCoords);\n  // GA has angle orientation opposite to `rotate`\n  const rotate = GATransform.rotation(center, element.angle);\n  const translate = GA.reverse(\n    GATransform.translation(GADirection.from(center)),\n  );\n  return GATransform.compose(rotate, translate);\n};\n\nconst coordsCenter = ([ax, ay, bx, by]: Bounds): GA.Point => {\n  return GA.point((ax + bx) / 2, (ay + by) / 2);\n};\n\n// The focus distance is the oriented ratio between the size of\n// the `element` and the \"focus image\" of the element on which\n// all focus points lie, so it's a number between -1 and 1.\n// The line going through `a` and `b` is a tangent to the \"focus image\"\n// of the element.\nexport const determineFocusDistance = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates (closer to element)\n  b: Point,\n): number => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const q = element.height / element.width;\n  const hwidth = element.width / 2;\n  const hheight = element.height / 2;\n  const n = line[2];\n  const m = line[3];\n  const c = line[1];\n  const mabs = Math.abs(m);\n  const nabs = Math.abs(n);\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return c / (hwidth * (nabs + q * mabs));\n    case \"diamond\":\n      return mabs < nabs ? c / (nabs * hwidth) : c / (mabs * hheight);\n    case \"ellipse\":\n      return c / (hwidth * Math.sqrt(n ** 2 + q ** 2 * m ** 2));\n  }\n};\n\nexport const determineFocusPoint = (\n  element: ExcalidrawBindableElement,\n  // The oriented, relative distance from the center of `element` of the\n  // returned focusPoint\n  focus: number,\n  adjecentPoint: Point,\n): Point => {\n  if (focus === 0) {\n    const elementCoords = getElementAbsoluteCoords(element);\n    const center = coordsCenter(elementCoords);\n    return GAPoint.toTuple(center);\n  }\n  const relateToCenter = relativizationToElementCenter(element);\n  const adjecentPointRel = GATransform.apply(\n    relateToCenter,\n    GAPoint.from(adjecentPoint),\n  );\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  let point;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n      point = findFocusPointForRectangulars(element, focus, adjecentPointRel);\n      break;\n    case \"ellipse\":\n      point = findFocusPointForEllipse(element, focus, adjecentPointRel);\n      break;\n  }\n  return GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point));\n};\n\n// Returns 2 or 0 intersection points between line going through `a` and `b`\n// and the `element`, in ascending order of distance from `a`.\nexport const intersectElementWithLine = (\n  element: ExcalidrawBindableElement,\n  // Point on the line, in absolute coordinates\n  a: Point,\n  // Another point on the line, in absolute coordinates\n  b: Point,\n  // If given, the element is inflated by this value\n  gap: number = 0,\n): Point[] => {\n  const relateToCenter = relativizationToElementCenter(element);\n  const aRel = GATransform.apply(relateToCenter, GAPoint.from(a));\n  const bRel = GATransform.apply(relateToCenter, GAPoint.from(b));\n  const line = GALine.through(aRel, bRel);\n  const reverseRelateToCenter = GA.reverse(relateToCenter);\n  const intersections = getSortedElementLineIntersections(\n    element,\n    line,\n    aRel,\n    gap,\n  );\n  return intersections.map((point) =>\n    GAPoint.toTuple(GATransform.apply(reverseRelateToCenter, point)),\n  );\n};\n\nconst getSortedElementLineIntersections = (\n  element: ExcalidrawBindableElement,\n  // Relative to element center\n  line: GA.Line,\n  // Relative to element center\n  nearPoint: GA.Point,\n  gap: number = 0,\n): GA.Point[] => {\n  let intersections: GA.Point[];\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"diamond\":\n      const corners = getCorners(element);\n      intersections = corners\n        .flatMap((point, i) => {\n          const edge: [GA.Point, GA.Point] = [point, corners[(i + 1) % 4]];\n          return intersectSegment(line, offsetSegment(edge, gap));\n        })\n        .concat(\n          corners.flatMap((point) => getCircleIntersections(point, gap, line)),\n        );\n      break;\n    case \"ellipse\":\n      intersections = getEllipseIntersections(element, gap, line);\n      break;\n  }\n  if (intersections.length < 2) {\n    // Ignore the \"edge\" case of only intersecting with a single corner\n    return [];\n  }\n  const sortedIntersections = intersections.sort(\n    (i1, i2) =>\n      GAPoint.distance(i1, nearPoint) - GAPoint.distance(i2, nearPoint),\n  );\n  return [\n    sortedIntersections[0],\n    sortedIntersections[sortedIntersections.length - 1],\n  ];\n};\n\nconst getCorners = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement,\n  scale: number = 1,\n): GA.Point[] => {\n  const hx = (scale * element.width) / 2;\n  const hy = (scale * element.height) / 2;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      return [\n        GA.point(hx, hy),\n        GA.point(hx, -hy),\n        GA.point(-hx, -hy),\n        GA.point(-hx, hy),\n      ];\n    case \"diamond\":\n      return [\n        GA.point(0, hy),\n        GA.point(hx, 0),\n        GA.point(0, -hy),\n        GA.point(-hx, 0),\n      ];\n  }\n};\n\n// Returns intersection of `line` with `segment`, with `segment` moved by\n// `gap` in its polar direction.\n// If intersection conincides with second segment point returns empty array.\nconst intersectSegment = (\n  line: GA.Line,\n  segment: [GA.Point, GA.Point],\n): GA.Point[] => {\n  const [a, b] = segment;\n  const aDist = GAPoint.distanceToLine(a, line);\n  const bDist = GAPoint.distanceToLine(b, line);\n  if (aDist * bDist >= 0) {\n    // The intersection is outside segment `(a, b)`\n    return [];\n  }\n  return [GAPoint.intersect(line, GALine.through(a, b))];\n};\n\nconst offsetSegment = (\n  segment: [GA.Point, GA.Point],\n  distance: number,\n): [GA.Point, GA.Point] => {\n  const [a, b] = segment;\n  const offset = GATransform.translationOrthogonal(\n    GADirection.fromTo(a, b),\n    distance,\n  );\n  return [GATransform.apply(offset, a), GATransform.apply(offset, b)];\n};\n\nconst getEllipseIntersections = (\n  element: ExcalidrawEllipseElement,\n  gap: number,\n  line: GA.Line,\n): GA.Point[] => {\n  const a = element.width / 2 + gap;\n  const b = element.height / 2 + gap;\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const squares = a * a * m * m + b * b * n * n;\n  const discr = squares - c * c;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = -a * a * m * c;\n  const yn = -b * b * n * c;\n  return [\n    GA.point(\n      (xn + a * b * n * discrRoot) / squares,\n      (yn - a * b * m * discrRoot) / squares,\n    ),\n    GA.point(\n      (xn - a * b * n * discrRoot) / squares,\n      (yn + a * b * m * discrRoot) / squares,\n    ),\n  ];\n};\n\nexport const getCircleIntersections = (\n  center: GA.Point,\n  radius: number,\n  line: GA.Line,\n): GA.Point[] => {\n  if (radius === 0) {\n    return GAPoint.distanceToLine(line, center) === 0 ? [center] : [];\n  }\n  const m = line[2];\n  const n = line[3];\n  const c = line[1];\n  const [a, b] = GAPoint.toTuple(center);\n  const r = radius;\n  const squares = m * m + n * n;\n  const discr = r * r * squares - (m * a + n * b + c) ** 2;\n  if (squares === 0 || discr <= 0) {\n    return [];\n  }\n  const discrRoot = Math.sqrt(discr);\n  const xn = a * n * n - b * m * n - m * c;\n  const yn = b * m * m - a * m * n - n * c;\n\n  return [\n    GA.point((xn + n * discrRoot) / squares, (yn - m * discrRoot) / squares),\n    GA.point((xn - n * discrRoot) / squares, (yn + m * discrRoot) / squares),\n  ];\n};\n\n// The focus point is the tangent point of the \"focus image\" of the\n// `element`, where the tangent goes through `point`.\nexport const findFocusPointForEllipse = (\n  ellipse: ExcalidrawEllipseElement,\n  // Between -1 and 1 (not 0) the relative size of the \"focus image\" of\n  // the element on which the focus point lies\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the ellipse center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const a = (ellipse.width * relativeDistanceAbs) / 2;\n  const b = (ellipse.height * relativeDistanceAbs) / 2;\n\n  const orientation = Math.sign(relativeDistance);\n  const [px, pyo] = GAPoint.toTuple(point);\n\n  // The calculation below can't handle py = 0\n  const py = pyo === 0 ? 0.0001 : pyo;\n\n  const squares = px ** 2 * b ** 2 + py ** 2 * a ** 2;\n  // Tangent mx + ny + 1 = 0\n  const m =\n    (-px * b ** 2 +\n      orientation * py * Math.sqrt(Math.max(0, squares - a ** 2 * b ** 2))) /\n    squares;\n\n  const n = (-m * px - 1) / py;\n\n  const x = -(a ** 2 * m) / (n ** 2 * b ** 2 + m ** 2 * a ** 2);\n  return GA.point(x, (-m * x - 1) / n);\n};\n\nexport const findFocusPointForRectangulars = (\n  element:\n    | ExcalidrawRectangleElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawTextElement,\n  // Between -1 and 1 for how far away should the focus point be relative\n  // to the size of the element. Sign determines orientation.\n  relativeDistance: number,\n  // The point for which we're trying to find the focus point, relative\n  // to the element center.\n  point: GA.Point,\n): GA.Point => {\n  const relativeDistanceAbs = Math.abs(relativeDistance);\n  const orientation = Math.sign(relativeDistance);\n  const corners = getCorners(element, relativeDistanceAbs);\n\n  let maxDistance = 0;\n  let tangentPoint: null | GA.Point = null;\n  corners.forEach((corner) => {\n    const distance = orientation * GALine.through(point, corner)[1];\n    if (distance > maxDistance) {\n      maxDistance = distance;\n      tangentPoint = corner;\n    }\n  });\n  return tangentPoint!;\n};\n\nconst pointInBezierEquation = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n  [mx, my]: Point,\n  lineThreshold: number,\n) => {\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // go through t in increments of 0.01\n  let t = 0;\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < lineThreshold) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nconst hitTestCurveInside = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  sharpness: ExcalidrawElement[\"strokeSharpness\"],\n) => {\n  const ops = getCurvePathOps(drawable);\n  const points: Point[] = [];\n  let odd = false; // select one line out of double lines\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      odd = !odd;\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n      }\n    } else if (operation.op === \"bcurveTo\") {\n      if (odd) {\n        points.push([operation.data[0], operation.data[1]]);\n        points.push([operation.data[2], operation.data[3]]);\n        points.push([operation.data[4], operation.data[5]]);\n      }\n    }\n  }\n  if (points.length >= 4) {\n    if (sharpness === \"sharp\") {\n      return isPointInPolygon(points, x, y);\n    }\n    const polygonPoints = pointsOnBezierCurves(points as any, 10, 5);\n    return isPointInPolygon(polygonPoints, x, y);\n  }\n  return false;\n};\n\nconst hitTestRoughShape = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  lineThreshold: number,\n) => {\n  // read operations from first opSet\n  const ops = getCurvePathOps(drawable);\n\n  // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n  let currentP: Point = [0, 0];\n\n  return ops.some(({ op, data }, idx) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = (data as unknown) as Point;\n      // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]] as Point;\n      const p2 = [data[2], data[3]] as Point;\n      const p3 = [data[4], data[5]] as Point;\n\n      const p0 = currentP;\n      currentP = p3;\n\n      // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n      const retVal = pointInBezierEquation(\n        p0,\n        p1,\n        p2,\n        p3,\n        [x, y],\n        lineThreshold,\n      );\n\n      // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n      return retVal;\n    } else if (op === \"lineTo\") {\n      // TODO: Implement this\n    } else if (op === \"qcurveTo\") {\n      // TODO: Implement this\n    }\n\n    return false;\n  });\n};\n","import {\n  ExcalidrawElement,\n  PointerType,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\nimport {\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n  TransformHandleType,\n  TransformHandle,\n  MaybeTransformHandleType,\n} from \"./transformHandles\";\nimport { AppState, Zoom } from \"../types\";\n\nconst isInsideTransformHandle = (\n  transformHandle: TransformHandle,\n  x: number,\n  y: number,\n) =>\n  x >= transformHandle[0] &&\n  x <= transformHandle[0] + transformHandle[2] &&\n  y >= transformHandle[1] &&\n  y <= transformHandle[1] + transformHandle[3];\n\nexport const resizeTest = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n): MaybeTransformHandleType => {\n  if (!appState.selectedElementIds[element.id]) {\n    return false;\n  }\n\n  const {\n    rotation: rotationTransformHandle,\n    ...transformHandles\n  } = getTransformHandles(element, zoom, pointerType);\n\n  if (\n    rotationTransformHandle &&\n    isInsideTransformHandle(rotationTransformHandle, x, y)\n  ) {\n    return \"rotation\" as TransformHandleType;\n  }\n\n  const filter = Object.keys(transformHandles).filter((key) => {\n    const transformHandle = transformHandles[\n      key as Exclude<TransformHandleType, \"rotation\">\n    ]!;\n    if (!transformHandle) {\n      return false;\n    }\n    return isInsideTransformHandle(transformHandle, x, y);\n  });\n\n  if (filter.length > 0) {\n    return filter[0] as TransformHandleType;\n  }\n\n  return false;\n};\n\nexport const getElementWithTransformHandleType = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  scenePointerX: number,\n  scenePointerY: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n) => {\n  return elements.reduce((result, element) => {\n    if (result) {\n      return result;\n    }\n    const transformHandleType = resizeTest(\n      element,\n      appState,\n      scenePointerX,\n      scenePointerY,\n      zoom,\n      pointerType,\n    );\n    return transformHandleType ? { element, transformHandleType } : null;\n  }, null as { element: NonDeletedExcalidrawElement; transformHandleType: MaybeTransformHandleType } | null);\n};\n\nexport const getTransformHandleTypeFromCoords = (\n  [x1, y1, x2, y2]: readonly [number, number, number, number],\n  scenePointerX: number,\n  scenePointerY: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n): MaybeTransformHandleType => {\n  const transformHandles = getTransformHandlesFromCoords(\n    [x1, y1, x2, y2],\n    0,\n    zoom,\n    pointerType,\n    OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  );\n\n  const found = Object.keys(transformHandles).find((key) => {\n    const transformHandle = transformHandles[\n      key as Exclude<TransformHandleType, \"rotation\">\n    ]!;\n    return (\n      transformHandle &&\n      isInsideTransformHandle(transformHandle, scenePointerX, scenePointerY)\n    );\n  });\n  return (found || false) as MaybeTransformHandleType;\n};\n\nconst RESIZE_CURSORS = [\"ns\", \"nesw\", \"ew\", \"nwse\"];\nconst rotateResizeCursor = (cursor: string, angle: number) => {\n  const index = RESIZE_CURSORS.indexOf(cursor);\n  if (index >= 0) {\n    const a = Math.round(angle / (Math.PI / 4));\n    cursor = RESIZE_CURSORS[(index + a) % RESIZE_CURSORS.length];\n  }\n  return cursor;\n};\n\n/*\n * Returns bi-directional cursor for the element being resized\n */\nexport const getCursorForResizingElement = (resizingElement: {\n  element?: ExcalidrawElement;\n  transformHandleType: MaybeTransformHandleType;\n}): string => {\n  const { element, transformHandleType } = resizingElement;\n  const shouldSwapCursors =\n    element && Math.sign(element.height) * Math.sign(element.width) === -1;\n  let cursor = null;\n\n  switch (transformHandleType) {\n    case \"n\":\n    case \"s\":\n      cursor = \"ns\";\n      break;\n    case \"w\":\n    case \"e\":\n      cursor = \"ew\";\n      break;\n    case \"nw\":\n    case \"se\":\n      if (shouldSwapCursors) {\n        cursor = \"nesw\";\n      } else {\n        cursor = \"nwse\";\n      }\n      break;\n    case \"ne\":\n    case \"sw\":\n      if (shouldSwapCursors) {\n        cursor = \"nwse\";\n      } else {\n        cursor = \"nesw\";\n      }\n      break;\n    case \"rotation\":\n      return \"grab\";\n  }\n\n  if (cursor && element) {\n    cursor = rotateResizeCursor(cursor, element.angle);\n  }\n\n  return cursor ? `${cursor}-resize` : \"\";\n};\n","import {\n  NonDeleted,\n  ExcalidrawLinearElement,\n  ExcalidrawElement,\n  PointBinding,\n  ExcalidrawBindableElement,\n} from \"./types\";\nimport { distance2d, rotate, isPathALoop, getGridPoint } from \"../math\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { getElementPointsCoords } from \"./bounds\";\nimport { Point, AppState } from \"../types\";\nimport { mutateElement } from \"./mutateElement\";\nimport History from \"../history\";\n\nimport Scene from \"../scene/Scene\";\nimport {\n  bindOrUnbindLinearElement,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n} from \"./binding\";\nimport { tupleToCoors } from \"../utils\";\nimport { isBindingElement } from \"./typeChecks\";\n\nexport class LinearElementEditor {\n  public elementId: ExcalidrawElement[\"id\"] & {\n    _brand: \"excalidrawLinearElementId\";\n  };\n  public activePointIndex: number | null;\n  /** whether you're dragging a point */\n  public isDragging: boolean;\n  public lastUncommittedPoint: Point | null;\n  public pointerOffset: { x: number; y: number };\n  public startBindingElement: ExcalidrawBindableElement | null | \"keep\";\n  public endBindingElement: ExcalidrawBindableElement | null | \"keep\";\n\n  constructor(element: NonDeleted<ExcalidrawLinearElement>, scene: Scene) {\n    this.elementId = element.id as string & {\n      _brand: \"excalidrawLinearElementId\";\n    };\n    Scene.mapElementToScene(this.elementId, scene);\n    LinearElementEditor.normalizePoints(element);\n\n    this.activePointIndex = null;\n    this.lastUncommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = { x: 0, y: 0 };\n    this.startBindingElement = \"keep\";\n    this.endBindingElement = \"keep\";\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  static POINT_HANDLE_SIZE = 20;\n\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement(id: InstanceType<typeof LinearElementEditor>[\"elementId\"]) {\n    const element = Scene.getScene(id)?.getNonDeletedElement(id);\n    if (element) {\n      return element as NonDeleted<ExcalidrawLinearElement>;\n    }\n    return null;\n  }\n\n  /** @returns whether point was dragged */\n  static handlePointDragging(\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    scenePointerX: number,\n    scenePointerY: number,\n    maybeSuggestBinding: (\n      element: NonDeleted<ExcalidrawLinearElement>,\n      startOrEnd: \"start\" | \"end\",\n    ) => void,\n  ): boolean {\n    if (!appState.editingLinearElement) {\n      return false;\n    }\n    const { editingLinearElement } = appState;\n    const { activePointIndex, elementId, isDragging } = editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n\n    if (activePointIndex != null && activePointIndex > -1) {\n      if (isDragging === false) {\n        setState({\n          editingLinearElement: {\n            ...editingLinearElement,\n            isDragging: true,\n          },\n        });\n      }\n\n      const newPoint = LinearElementEditor.createPointAt(\n        element,\n        scenePointerX - editingLinearElement.pointerOffset.x,\n        scenePointerY - editingLinearElement.pointerOffset.y,\n        appState.gridSize,\n      );\n      LinearElementEditor.movePoint(element, activePointIndex, newPoint);\n      if (isBindingElement(element)) {\n        maybeSuggestBinding(element, activePointIndex === 0 ? \"start\" : \"end\");\n      }\n      return true;\n    }\n    return false;\n  }\n\n  static handlePointerUp(\n    event: PointerEvent,\n    editingLinearElement: LinearElementEditor,\n    appState: AppState,\n  ): LinearElementEditor {\n    const { elementId, activePointIndex, isDragging } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    let binding = {};\n    if (\n      isDragging &&\n      (activePointIndex === 0 || activePointIndex === element.points.length - 1)\n    ) {\n      if (isPathALoop(element.points, appState.zoom.value)) {\n        LinearElementEditor.movePoint(\n          element,\n          activePointIndex,\n          activePointIndex === 0\n            ? element.points[element.points.length - 1]\n            : element.points[0],\n        );\n      }\n      const bindingElement = isBindingEnabled(appState)\n        ? getHoveredElementForBinding(\n            tupleToCoors(\n              LinearElementEditor.getPointAtIndexGlobalCoordinates(\n                element,\n                activePointIndex!,\n              ),\n            ),\n            Scene.getScene(element)!,\n          )\n        : null;\n      binding = {\n        [activePointIndex === 0\n          ? \"startBindingElement\"\n          : \"endBindingElement\"]: bindingElement,\n      };\n    }\n    return {\n      ...editingLinearElement,\n      ...binding,\n      isDragging: false,\n      pointerOffset: { x: 0, y: 0 },\n    };\n  }\n\n  static handlePointerDown(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    history: History,\n    scenePointer: { x: number; y: number },\n  ): {\n    didAddPoint: boolean;\n    hitElement: NonDeleted<ExcalidrawElement> | null;\n  } {\n    const ret: ReturnType<typeof LinearElementEditor[\"handlePointerDown\"]> = {\n      didAddPoint: false,\n      hitElement: null,\n    };\n\n    if (!appState.editingLinearElement) {\n      return ret;\n    }\n\n    const { elementId } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return ret;\n    }\n\n    if (event.altKey) {\n      if (appState.editingLinearElement.lastUncommittedPoint == null) {\n        mutateElement(element, {\n          points: [\n            ...element.points,\n            LinearElementEditor.createPointAt(\n              element,\n              scenePointer.x,\n              scenePointer.y,\n              appState.gridSize,\n            ),\n          ],\n        });\n      }\n      history.resumeRecording();\n      setState({\n        editingLinearElement: {\n          ...appState.editingLinearElement,\n          activePointIndex: element.points.length - 1,\n          lastUncommittedPoint: null,\n          endBindingElement: getHoveredElementForBinding(\n            scenePointer,\n            Scene.getScene(element)!,\n          ),\n        },\n      });\n      ret.didAddPoint = true;\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n\n    // if we clicked on a point, set the element as hitElement otherwise\n    // it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex > -1) {\n      ret.hitElement = element;\n    } else {\n      // You might be wandering why we are storing the binding elements on\n      // LinearElementEditor and passing them in, insted of calculating them\n      // from the end points of the `linearElement` - this is to allow disabling\n      // binding (which needs to happen at the point the user finishes moving\n      // the point).\n      const {\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      if (isBindingEnabled(appState) && isBindingElement(element)) {\n        bindOrUnbindLinearElement(\n          element,\n          startBindingElement,\n          endBindingElement,\n        );\n      }\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint =\n      clickedPointIndex > -1 &&\n      rotate(\n        element.x + element.points[clickedPointIndex][0],\n        element.y + element.points[clickedPointIndex][1],\n        cx,\n        cy,\n        element.angle,\n      );\n\n    setState({\n      editingLinearElement: {\n        ...appState.editingLinearElement,\n        activePointIndex: clickedPointIndex > -1 ? clickedPointIndex : null,\n        pointerOffset: targetPoint\n          ? {\n              x: scenePointer.x - targetPoint[0],\n              y: scenePointer.y - targetPoint[1],\n            }\n          : { x: 0, y: 0 },\n      },\n    });\n    return ret;\n  }\n\n  static handlePointerMove(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    editingLinearElement: LinearElementEditor,\n    gridSize: number | null,\n  ): LinearElementEditor {\n    const { elementId, lastUncommittedPoint } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    const { points } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.movePoint(element, points.length - 1, \"delete\");\n      }\n      return { ...editingLinearElement, lastUncommittedPoint: null };\n    }\n\n    const newPoint = LinearElementEditor.createPointAt(\n      element,\n      scenePointerX - editingLinearElement.pointerOffset.x,\n      scenePointerY - editingLinearElement.pointerOffset.y,\n      gridSize,\n    );\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoint(\n        element,\n        element.points.length - 1,\n        newPoint,\n      );\n    } else {\n      LinearElementEditor.movePoint(element, \"new\", newPoint);\n    }\n\n    return {\n      ...editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1],\n    };\n  }\n\n  static getPointsGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n  ) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map((point) => {\n      let { x, y } = element;\n      [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n      return [x, y];\n    });\n  }\n\n  static getPointAtIndexGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    indexMaybeFromEnd: number, // -1 for last element\n  ): Point {\n    const index =\n      indexMaybeFromEnd < 0\n        ? element.points.length + indexMaybeFromEnd\n        : indexMaybeFromEnd;\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const point = element.points[index];\n    const { x, y } = element;\n    return rotate(x + point[0], y + point[1], cx, cy, element.angle);\n  }\n\n  static pointFromAbsoluteCoords(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    absoluteCoords: Point,\n  ): Point {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [x, y] = rotate(\n      absoluteCoords[0],\n      absoluteCoords[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n    return [x - element.x, y - element.y];\n  }\n\n  static getPointIndexUnderCursor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    zoom: AppState[\"zoom\"],\n    x: number,\n    y: number,\n  ) {\n    const pointHandles = this.getPointsGlobalCoordinates(element);\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    // points on the left, thus should take precedence when clicking, if they\n    // overlap\n    while (--idx > -1) {\n      const point = pointHandles[idx];\n      if (\n        distance2d(x, y, point[0], point[1]) * zoom.value <\n        // +1px to account for outline stroke\n        this.POINT_HANDLE_SIZE / 2 + 1\n      ) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  static createPointAt(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    gridSize: number | null,\n  ): Point {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = rotate(\n      pointerOnGrid[0],\n      pointerOnGrid[1],\n      cx,\n      cy,\n      -element.angle,\n    );\n\n    return [rotatedX - element.x, rotatedY - element.y];\n  }\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   * expected in various parts of the codebase. Also returns new x/y to account\n   * for the potential normalization.\n   */\n  static getNormalizedPoints(element: ExcalidrawLinearElement) {\n    const { points } = element;\n\n    const offsetX = points[0][0];\n    const offsetY = points[0][1];\n\n    return {\n      points: points.map((point, _idx) => {\n        return [point[0] - offsetX, point[1] - offsetY] as const;\n      }),\n      x: element.x + offsetX,\n      y: element.y + offsetY,\n    };\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n\n  static normalizePoints(element: NonDeleted<ExcalidrawLinearElement>) {\n    mutateElement(element, LinearElementEditor.getNormalizedPoints(element));\n  }\n\n  static movePointByOffset(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndex: number,\n    offset: { x: number; y: number },\n  ) {\n    const [x, y] = element.points[pointIndex];\n    LinearElementEditor.movePoint(element, pointIndex, [\n      x + offset.x,\n      y + offset.y,\n    ]);\n  }\n\n  static movePoint(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndex: number | \"new\",\n    targetPosition: Point | \"delete\",\n    otherUpdates?: { startBinding?: PointBinding; endBinding?: PointBinding },\n  ) {\n    const { points } = element;\n\n    // in case we're moving start point, instead of modifying its position\n    // which would break the invariant of it being at [0,0], we move\n    // all the other points in the opposite direction by delta to\n    // offset it. We do the same with actual element.x/y position, so\n    // this hacks are completely transparent to the user.\n    let offsetX = 0;\n    let offsetY = 0;\n\n    let nextPoints: (readonly [number, number])[];\n    if (targetPosition === \"delete\") {\n      // remove point\n      if (pointIndex === \"new\") {\n        throw new Error(\"invalid args in movePoint\");\n      }\n      nextPoints = points.slice();\n      nextPoints.splice(pointIndex, 1);\n      if (pointIndex === 0) {\n        // if deleting first point, make the next to be [0,0] and recalculate\n        // positions of the rest with respect to it\n        offsetX = nextPoints[0][0];\n        offsetY = nextPoints[0][1];\n        nextPoints = nextPoints.map((point, idx) => {\n          if (idx === 0) {\n            return [0, 0];\n          }\n          return [point[0] - offsetX, point[1] - offsetY];\n        });\n      }\n    } else if (pointIndex === \"new\") {\n      nextPoints = [...points, targetPosition];\n    } else {\n      const deltaX = targetPosition[0] - points[pointIndex][0];\n      const deltaY = targetPosition[1] - points[pointIndex][1];\n      nextPoints = points.map((point, idx) => {\n        if (idx === pointIndex) {\n          if (idx === 0) {\n            offsetX = deltaX;\n            offsetY = deltaY;\n            return point;\n          }\n          offsetX = 0;\n          offsetY = 0;\n\n          return [point[0] + deltaX, point[1] + deltaY] as const;\n        }\n        return offsetX || offsetY\n          ? ([point[0] - offsetX, point[1] - offsetY] as const)\n          : point;\n      });\n    }\n\n    const nextCoords = getElementPointsCoords(\n      element,\n      nextPoints,\n      element.strokeSharpness || \"round\",\n    );\n    const prevCoords = getElementPointsCoords(\n      element,\n      points,\n      element.strokeSharpness || \"round\",\n    );\n    const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n    const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n    const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n    const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n    const dX = prevCenterX - nextCenterX;\n    const dY = prevCenterY - nextCenterY;\n    const rotated = rotate(offsetX, offsetY, dX, dY, element.angle);\n\n    mutateElement(element, {\n      ...otherUpdates,\n      points: nextPoints,\n      x: element.x + rotated[0],\n      y: element.y + rotated[1],\n    });\n  }\n}\n","import {\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n  PointBinding,\n  ExcalidrawElement,\n} from \"./types\";\nimport { getElementAtPosition } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { isBindableElement, isBindingElement } from \"./typeChecks\";\nimport {\n  bindingBorderTest,\n  distanceToBindableElement,\n  maxBindingGap,\n  determineFocusDistance,\n  intersectElementWithLine,\n  determineFocusPoint,\n} from \"./collision\";\nimport { mutateElement } from \"./mutateElement\";\nimport Scene from \"../scene/Scene\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { tupleToCoors } from \"../utils\";\nimport { KEYS } from \"../keys\";\n\nexport type SuggestedBinding =\n  | NonDeleted<ExcalidrawBindableElement>\n  | SuggestedPointBinding;\n\nexport type SuggestedPointBinding = [\n  NonDeleted<ExcalidrawLinearElement>,\n  \"start\" | \"end\" | \"both\",\n  NonDeleted<ExcalidrawBindableElement>,\n];\n\nexport const shouldEnableBindingForPointerEvent = (\n  event: React.PointerEvent<HTMLCanvasElement>,\n) => {\n  return !event[KEYS.CTRL_OR_CMD];\n};\n\nexport const isBindingEnabled = (appState: AppState): boolean => {\n  return appState.isBindingEnabled;\n};\n\nexport const bindOrUnbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startBindingElement: ExcalidrawBindableElement | null | \"keep\",\n  endBindingElement: ExcalidrawBindableElement | null | \"keep\",\n): void => {\n  const boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  const unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    startBindingElement,\n    endBindingElement,\n    \"start\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    endBindingElement,\n    startBindingElement,\n    \"end\",\n    boundToElementIds,\n    unboundFromElementIds,\n  );\n\n  const onlyUnbound = Array.from(unboundFromElementIds).filter(\n    (id) => !boundToElementIds.has(id),\n  );\n  Scene.getScene(linearElement)!\n    .getNonDeletedElements(onlyUnbound)\n    .forEach((element) => {\n      mutateElement(element, {\n        boundElementIds: element.boundElementIds?.filter(\n          (id) => id !== linearElement.id,\n        ),\n      });\n    });\n};\n\nconst bindOrUnbindLinearElementEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement | null | \"keep\",\n  otherEdgeBindableElement: ExcalidrawBindableElement | null | \"keep\",\n  startOrEnd: \"start\" | \"end\",\n  // Is mutated\n  boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n  // Is mutated\n  unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n): void => {\n  if (bindableElement !== \"keep\") {\n    if (bindableElement != null) {\n      // Don't bind if we're trying to bind or are already bound to the same\n      // element on the other edge already (\"start\" edge takes precedence).\n      if (\n        otherEdgeBindableElement == null ||\n        (otherEdgeBindableElement === \"keep\"\n          ? !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n              linearElement,\n              bindableElement,\n              startOrEnd,\n            )\n          : startOrEnd === \"start\" ||\n            otherEdgeBindableElement.id !== bindableElement.id)\n      ) {\n        bindLinearElement(linearElement, bindableElement, startOrEnd);\n        boundToElementIds.add(bindableElement.id);\n      }\n    } else {\n      const unbound = unbindLinearElement(linearElement, startOrEnd);\n      if (unbound != null) {\n        unboundFromElementIds.add(unbound);\n      }\n    }\n  }\n};\n\nexport const bindOrUnbindSelectedElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(\n        element,\n        getElligibleElementForBindingElement(element, \"start\"),\n        getElligibleElementForBindingElement(element, \"end\"),\n      );\n    } else if (isBindableElement(element)) {\n      maybeBindBindableElement(element);\n    }\n  });\n};\n\nconst maybeBindBindableElement = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): void => {\n  getElligibleElementsForBindableElementAndWhere(\n    bindableElement,\n  ).forEach(([linearElement, where]) =>\n    bindOrUnbindLinearElement(\n      linearElement,\n      where === \"end\" ? \"keep\" : bindableElement,\n      where === \"start\" ? \"keep\" : bindableElement,\n    ),\n  );\n};\n\nexport const maybeBindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  appState: AppState,\n  scene: Scene,\n  pointerCoords: { x: number; y: number },\n): void => {\n  if (appState.startBoundElement != null) {\n    bindLinearElement(linearElement, appState.startBoundElement, \"start\");\n  }\n  const hoveredElement = getHoveredElementForBinding(pointerCoords, scene);\n  if (\n    hoveredElement != null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      hoveredElement,\n      \"end\",\n    )\n  ) {\n    bindLinearElement(linearElement, hoveredElement, \"end\");\n  }\n};\n\nconst bindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): void => {\n  mutateElement(linearElement, {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: {\n      elementId: hoveredElement.id,\n      ...calculateFocusAndGap(linearElement, hoveredElement, startOrEnd),\n    } as PointBinding,\n  });\n  mutateElement(hoveredElement, {\n    boundElementIds: Array.from(\n      new Set([...(hoveredElement.boundElementIds ?? []), linearElement.id]),\n    ),\n  });\n};\n\n// Don't bind both ends of a simple segment\nconst isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): boolean => {\n  const otherBinding =\n    linearElement[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n  return isLinearElementSimpleAndAlreadyBound(\n    linearElement,\n    otherBinding?.elementId,\n    bindableElement,\n  );\n};\n\nexport const isLinearElementSimpleAndAlreadyBound = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  alreadyBoundToId: ExcalidrawBindableElement[\"id\"] | undefined,\n  bindableElement: ExcalidrawBindableElement,\n): boolean => {\n  return (\n    alreadyBoundToId === bindableElement.id && linearElement.points.length < 3\n  );\n};\n\nexport const unbindLinearElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): void => {\n  elements.forEach((element) => {\n    if (isBindingElement(element)) {\n      bindOrUnbindLinearElement(element, null, null);\n    }\n  });\n};\n\nconst unbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): ExcalidrawBindableElement[\"id\"] | null => {\n  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n  const binding = linearElement[field];\n  if (binding == null) {\n    return null;\n  }\n  mutateElement(linearElement, { [field]: null });\n  return binding.elementId;\n};\n\nexport const getHoveredElementForBinding = (\n  pointerCoords: {\n    x: number;\n    y: number;\n  },\n  scene: Scene,\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  const hoveredElement = getElementAtPosition(\n    scene.getElements(),\n    (element) =>\n      isBindableElement(element) && bindingBorderTest(element, pointerCoords),\n  );\n  return hoveredElement as NonDeleted<ExcalidrawBindableElement> | null;\n};\n\nconst calculateFocusAndGap = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): { focus: number; gap: number } => {\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    edgePointIndex,\n  );\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  return {\n    focus: determineFocusDistance(hoveredElement, adjacentPoint, edgePoint),\n    gap: Math.max(1, distanceToBindableElement(hoveredElement, edgePoint)),\n  };\n};\n\n// Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\n// Because scaling involves moving the focus points as well, it is\n// done before the `changedElement` is updated, and the `newSize` is passed\n// in explicitly.\nexport const updateBoundElements = (\n  changedElement: NonDeletedExcalidrawElement,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    newSize?: { width: number; height: number };\n  },\n) => {\n  const boundElementIds = changedElement.boundElementIds ?? [];\n  if (boundElementIds.length === 0) {\n    return;\n  }\n  const { newSize, simultaneouslyUpdated } = options ?? {};\n  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(\n    simultaneouslyUpdated,\n  );\n  (Scene.getScene(changedElement)!.getNonDeletedElements(\n    boundElementIds,\n  ) as NonDeleted<ExcalidrawLinearElement>[]).forEach((linearElement) => {\n    const bindableElement = changedElement as ExcalidrawBindableElement;\n    // In case the boundElementIds are stale\n    if (!doesNeedUpdate(linearElement, bindableElement)) {\n      return;\n    }\n    const startBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      linearElement.startBinding,\n      newSize,\n    );\n    const endBinding = maybeCalculateNewGapWhenScaling(\n      bindableElement,\n      linearElement.endBinding,\n      newSize,\n    );\n    // `linearElement` is being moved/scaled already, just update the binding\n    if (simultaneouslyUpdatedElementIds.has(linearElement.id)) {\n      mutateElement(linearElement, { startBinding, endBinding });\n      return;\n    }\n    updateBoundPoint(\n      linearElement,\n      \"start\",\n      startBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n    updateBoundPoint(\n      linearElement,\n      \"end\",\n      endBinding,\n      changedElement as ExcalidrawBindableElement,\n    );\n  });\n};\n\nconst doesNeedUpdate = (\n  boundElement: NonDeleted<ExcalidrawLinearElement>,\n  changedElement: ExcalidrawBindableElement,\n) => {\n  return (\n    boundElement.startBinding?.elementId === changedElement.id ||\n    boundElement.endBinding?.elementId === changedElement.id\n  );\n};\n\nconst getSimultaneouslyUpdatedElementIds = (\n  simultaneouslyUpdated: readonly ExcalidrawElement[] | undefined,\n): Set<ExcalidrawElement[\"id\"]> => {\n  return new Set((simultaneouslyUpdated || []).map((element) => element.id));\n};\n\nconst updateBoundPoint = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  binding: PointBinding | null | undefined,\n  changedElement: ExcalidrawBindableElement,\n): void => {\n  if (\n    binding == null ||\n    // We only need to update the other end if this is a 2 point line element\n    (binding.elementId !== changedElement.id && linearElement.points.length > 2)\n  ) {\n    return;\n  }\n  const bindingElement = Scene.getScene(linearElement)!.getElement(\n    binding.elementId,\n  ) as ExcalidrawBindableElement | null;\n  if (bindingElement == null) {\n    // We're not cleaning up after deleted elements atm., so handle this case\n    return;\n  }\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n  );\n  const focusPointAbsolute = determineFocusPoint(\n    bindingElement,\n    binding.focus,\n    adjacentPoint,\n  );\n  let newEdgePoint;\n  // The linear element was not originally pointing inside the bound shape,\n  // we can point directly at the focus point\n  if (binding.gap === 0) {\n    newEdgePoint = focusPointAbsolute;\n  } else {\n    const intersections = intersectElementWithLine(\n      bindingElement,\n      adjacentPoint,\n      focusPointAbsolute,\n      binding.gap,\n    );\n    if (intersections.length === 0) {\n      // This should never happen, since focusPoint should always be\n      // inside the element, but just in case, bail out\n      newEdgePoint = focusPointAbsolute;\n    } else {\n      // Guaranteed to intersect because focusPoint is always inside the shape\n      newEdgePoint = intersections[0];\n    }\n  }\n  LinearElementEditor.movePoint(\n    linearElement,\n    edgePointIndex,\n    LinearElementEditor.pointFromAbsoluteCoords(linearElement, newEdgePoint),\n    { [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding },\n  );\n};\n\nconst maybeCalculateNewGapWhenScaling = (\n  changedElement: ExcalidrawBindableElement,\n  currentBinding: PointBinding | null | undefined,\n  newSize: { width: number; height: number } | undefined,\n): PointBinding | null | undefined => {\n  if (currentBinding == null || newSize == null) {\n    return currentBinding;\n  }\n  const { gap, focus, elementId } = currentBinding;\n  const { width: newWidth, height: newHeight } = newSize;\n  const { width, height } = changedElement;\n  const newGap = Math.max(\n    1,\n    Math.min(\n      maxBindingGap(changedElement, newWidth, newHeight),\n      gap * (newWidth < newHeight ? newWidth / width : newHeight / height),\n    ),\n  );\n  return { elementId, gap: newGap, focus };\n};\n\nexport const getEligibleElementsForBinding = (\n  elements: NonDeleted<ExcalidrawElement>[],\n): SuggestedBinding[] => {\n  const includedElementIds = new Set(elements.map(({ id }) => id));\n  return elements.flatMap((element) =>\n    isBindingElement(element)\n      ? (getElligibleElementsForBindingElement(\n          element as NonDeleted<ExcalidrawLinearElement>,\n        ).filter(\n          (element) => !includedElementIds.has(element.id),\n        ) as SuggestedBinding[])\n      : isBindableElement(element)\n      ? getElligibleElementsForBindableElementAndWhere(element).filter(\n          (binding) => !includedElementIds.has(binding[0].id),\n        )\n      : [],\n  );\n};\n\nconst getElligibleElementsForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n): NonDeleted<ExcalidrawBindableElement>[] => {\n  return [\n    getElligibleElementForBindingElement(linearElement, \"start\"),\n    getElligibleElementForBindingElement(linearElement, \"end\"),\n  ].filter(\n    (element): element is NonDeleted<ExcalidrawBindableElement> =>\n      element != null,\n  );\n};\n\nconst getElligibleElementForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  return getHoveredElementForBinding(\n    getLinearElementEdgeCoors(linearElement, startOrEnd),\n    Scene.getScene(linearElement)!,\n  );\n};\n\nconst getLinearElementEdgeCoors = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n): { x: number; y: number } => {\n  const index = startOrEnd === \"start\" ? 0 : -1;\n  return tupleToCoors(\n    LinearElementEditor.getPointAtIndexGlobalCoordinates(linearElement, index),\n  );\n};\n\nconst getElligibleElementsForBindableElementAndWhere = (\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): SuggestedPointBinding[] => {\n  return Scene.getScene(bindableElement)!\n    .getElements()\n    .map((element) => {\n      if (!isBindingElement(element)) {\n        return null;\n      }\n      const canBindStart = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"start\",\n        bindableElement,\n      );\n      const canBindEnd = isLinearElementEligibleForNewBindingByBindable(\n        element,\n        \"end\",\n        bindableElement,\n      );\n      if (!canBindStart && !canBindEnd) {\n        return null;\n      }\n      return [\n        element,\n        canBindStart && canBindEnd ? \"both\" : canBindStart ? \"start\" : \"end\",\n        bindableElement,\n      ];\n    })\n    .filter((maybeElement) => maybeElement != null) as SuggestedPointBinding[];\n};\n\nconst isLinearElementEligibleForNewBindingByBindable = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  bindableElement: NonDeleted<ExcalidrawBindableElement>,\n): boolean => {\n  const existingBinding =\n    linearElement[startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"];\n  return (\n    existingBinding == null &&\n    !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n      linearElement,\n      bindableElement,\n      startOrEnd,\n    ) &&\n    bindingBorderTest(\n      bindableElement,\n      getLinearElementEdgeCoors(linearElement, startOrEnd),\n    )\n  );\n};\n\n// We need to:\n// 1: Update elements not selected to point to duplicated elements\n// 2: Update duplicated elements to point to other duplicated elements\nexport const fixBindingsAfterDuplication = (\n  sceneElements: readonly ExcalidrawElement[],\n  oldElements: readonly ExcalidrawElement[],\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n  // There are three copying mechanisms: Copy-paste, duplication and alt-drag.\n  // Only when alt-dragging the new \"duplicates\" act as the \"old\", while\n  // the \"old\" elements act as the \"new copy\" - essentially working reverse\n  // to the other two.\n  duplicatesServeAsOld?: \"duplicatesServeAsOld\" | undefined,\n): void => {\n  // First collect all the binding/bindable elements, so we only update\n  // each once, regardless of whether they were duplicated or not.\n  const allBoundElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const allBindableElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  const shouldReverseRoles = duplicatesServeAsOld === \"duplicatesServeAsOld\";\n  oldElements.forEach((oldElement) => {\n    const { boundElementIds } = oldElement;\n    if (boundElementIds != null && boundElementIds.length > 0) {\n      boundElementIds.forEach((boundElementId) => {\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(boundElementId)) {\n          allBoundElementIds.add(boundElementId);\n        }\n      });\n      allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n    }\n    if (isBindingElement(oldElement)) {\n      if (oldElement.startBinding != null) {\n        const { elementId } = oldElement.startBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.endBinding != null) {\n        const { elementId } = oldElement.endBinding;\n        if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {\n          allBindableElementIds.add(elementId);\n        }\n      }\n      if (oldElement.startBinding != null || oldElement.endBinding != null) {\n        allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id)!);\n      }\n    }\n  });\n\n  // Update the linear elements\n  (sceneElements.filter(({ id }) =>\n    allBoundElementIds.has(id),\n  ) as ExcalidrawLinearElement[]).forEach((element) => {\n    const { startBinding, endBinding } = element;\n    mutateElement(element, {\n      startBinding: newBindingAfterDuplication(\n        startBinding,\n        oldIdToDuplicatedId,\n      ),\n      endBinding: newBindingAfterDuplication(endBinding, oldIdToDuplicatedId),\n    });\n  });\n\n  // Update the bindable shapes\n  sceneElements\n    .filter(({ id }) => allBindableElementIds.has(id))\n    .forEach((bindableElement) => {\n      const { boundElementIds } = bindableElement;\n      if (boundElementIds != null && boundElementIds.length > 0) {\n        mutateElement(bindableElement, {\n          boundElementIds: boundElementIds.map(\n            (boundElementId) =>\n              oldIdToDuplicatedId.get(boundElementId) ?? boundElementId,\n          ),\n        });\n      }\n    });\n};\n\nconst newBindingAfterDuplication = (\n  binding: PointBinding | null,\n  oldIdToDuplicatedId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null) {\n    return null;\n  }\n  const { elementId, focus, gap } = binding;\n  return {\n    focus,\n    gap,\n    elementId: oldIdToDuplicatedId.get(elementId) ?? elementId,\n  };\n};\n\nexport const fixBindingsAfterDeletion = (\n  sceneElements: readonly ExcalidrawElement[],\n  deletedElements: readonly ExcalidrawElement[],\n): void => {\n  const deletedElementIds = new Set(\n    deletedElements.map((element) => element.id),\n  );\n  // Non deleted and need an update\n  const boundElementIds: Set<ExcalidrawElement[\"id\"]> = new Set();\n  deletedElements.forEach((deletedElement) => {\n    if (isBindableElement(deletedElement)) {\n      deletedElement.boundElementIds?.forEach((id) => {\n        if (!deletedElementIds.has(id)) {\n          boundElementIds.add(id);\n        }\n      });\n    }\n  });\n  (sceneElements.filter(({ id }) =>\n    boundElementIds.has(id),\n  ) as ExcalidrawLinearElement[]).forEach(\n    (element: ExcalidrawLinearElement) => {\n      const { startBinding, endBinding } = element;\n      mutateElement(element, {\n        startBinding: newBindingAfterDeletion(startBinding, deletedElementIds),\n        endBinding: newBindingAfterDeletion(endBinding, deletedElementIds),\n      });\n    },\n  );\n};\n\nconst newBindingAfterDeletion = (\n  binding: PointBinding | null,\n  deletedElementIds: Set<ExcalidrawElement[\"id\"]>,\n): PointBinding | null => {\n  if (binding == null || deletedElementIds.has(binding.elementId)) {\n    return null;\n  }\n  return binding;\n};\n","import { SHIFT_LOCKING_ANGLE } from \"../constants\";\nimport { rescalePoints } from \"../points\";\n\nimport {\n  rotate,\n  adjustXYWithRotation,\n  centerPoint,\n  rotatePoint,\n} from \"../math\";\nimport {\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"./types\";\nimport {\n  getElementAbsoluteCoords,\n  getCommonBounds,\n  getResizedElementAbsoluteCoords,\n} from \"./bounds\";\nimport {\n  isFreeDrawElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport { measureText, getFontString } from \"../utils\";\nimport { updateBoundElements } from \"./binding\";\nimport {\n  TransformHandleType,\n  MaybeTransformHandleType,\n  TransformHandleDirection,\n} from \"./transformHandles\";\nimport { Point, PointerDownState } from \"../types\";\n\nexport const normalizeAngle = (angle: number): number => {\n  if (angle >= 2 * Math.PI) {\n    return angle - 2 * Math.PI;\n  }\n  return angle;\n};\n\n// Returns true when transform (resizing/rotation) happened\nexport const transformElements = (\n  pointerDownState: PointerDownState,\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  resizeArrowDirection: \"origin\" | \"end\",\n  isRotateWithDiscreteAngle: boolean,\n  isResizeCenterPoint: boolean,\n  shouldKeepSidesRatio: boolean,\n  pointerX: number,\n  pointerY: number,\n  centerX: number,\n  centerY: number,\n) => {\n  if (selectedElements.length === 1) {\n    const [element] = selectedElements;\n    if (transformHandleType === \"rotation\") {\n      rotateSingleElement(\n        element,\n        pointerX,\n        pointerY,\n        isRotateWithDiscreteAngle,\n      );\n      updateBoundElements(element);\n    } else if (\n      isLinearElement(element) &&\n      element.points.length === 2 &&\n      (transformHandleType === \"nw\" ||\n        transformHandleType === \"ne\" ||\n        transformHandleType === \"sw\" ||\n        transformHandleType === \"se\")\n    ) {\n      reshapeSingleTwoPointElement(\n        element,\n        resizeArrowDirection,\n        isRotateWithDiscreteAngle,\n        pointerX,\n        pointerY,\n      );\n    } else if (\n      isTextElement(element) &&\n      (transformHandleType === \"nw\" ||\n        transformHandleType === \"ne\" ||\n        transformHandleType === \"sw\" ||\n        transformHandleType === \"se\")\n    ) {\n      resizeSingleTextElement(\n        element,\n        transformHandleType,\n        isResizeCenterPoint,\n        pointerX,\n        pointerY,\n      );\n      updateBoundElements(element);\n    } else if (transformHandleType) {\n      resizeSingleElement(\n        pointerDownState.originalElements.get(element.id) as typeof element,\n        shouldKeepSidesRatio,\n        element,\n        transformHandleType,\n        isResizeCenterPoint,\n        pointerX,\n        pointerY,\n      );\n    }\n\n    return true;\n  } else if (selectedElements.length > 1) {\n    if (transformHandleType === \"rotation\") {\n      rotateMultipleElements(\n        pointerDownState,\n        selectedElements,\n        pointerX,\n        pointerY,\n        isRotateWithDiscreteAngle,\n        centerX,\n        centerY,\n      );\n      return true;\n    } else if (\n      transformHandleType === \"nw\" ||\n      transformHandleType === \"ne\" ||\n      transformHandleType === \"sw\" ||\n      transformHandleType === \"se\"\n    ) {\n      resizeMultipleElements(\n        selectedElements,\n        transformHandleType,\n        pointerX,\n        pointerY,\n      );\n      return true;\n    }\n  }\n  return false;\n};\n\nconst rotateSingleElement = (\n  element: NonDeletedExcalidrawElement,\n  pointerX: number,\n  pointerY: number,\n  isRotateWithDiscreteAngle: boolean,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  let angle = (5 * Math.PI) / 2 + Math.atan2(pointerY - cy, pointerX - cx);\n  if (isRotateWithDiscreteAngle) {\n    angle += SHIFT_LOCKING_ANGLE / 2;\n    angle -= angle % SHIFT_LOCKING_ANGLE;\n  }\n  angle = normalizeAngle(angle);\n  mutateElement(element, { angle });\n};\n\n// used in DEV only\nconst validateTwoPointElementNormalized = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n) => {\n  if (\n    element.points.length !== 2 ||\n    element.points[0][0] !== 0 ||\n    element.points[0][1] !== 0 ||\n    Math.abs(element.points[1][0]) !== element.width ||\n    Math.abs(element.points[1][1]) !== element.height\n  ) {\n    throw new Error(\"Two-point element is not normalized\");\n  }\n};\n\nconst getPerfectElementSizeWithRotation = (\n  elementType: string,\n  width: number,\n  height: number,\n  angle: number,\n): [number, number] => {\n  const size = getPerfectElementSize(\n    elementType,\n    ...rotate(width, height, 0, 0, angle),\n  );\n  return rotate(size.width, size.height, 0, 0, -angle);\n};\n\nexport const reshapeSingleTwoPointElement = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  resizeArrowDirection: \"origin\" | \"end\",\n  isRotateWithDiscreteAngle: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  if (process.env.NODE_ENV !== \"production\") {\n    validateTwoPointElementNormalized(element);\n  }\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // rotation pointer with reverse angle\n  const [rotatedX, rotatedY] = rotate(\n    pointerX,\n    pointerY,\n    cx,\n    cy,\n    -element.angle,\n  );\n  let [width, height] =\n    resizeArrowDirection === \"end\"\n      ? [rotatedX - element.x, rotatedY - element.y]\n      : [\n          element.x + element.points[1][0] - rotatedX,\n          element.y + element.points[1][1] - rotatedY,\n        ];\n  if (isRotateWithDiscreteAngle) {\n    [width, height] = getPerfectElementSizeWithRotation(\n      element.type,\n      width,\n      height,\n      element.angle,\n    );\n  }\n  const [nextElementX, nextElementY] = adjustXYWithRotation(\n    resizeArrowDirection === \"end\"\n      ? { s: true, e: true }\n      : { n: true, w: true },\n    element.x,\n    element.y,\n    element.angle,\n    0,\n    0,\n    (element.points[1][0] - width) / 2,\n    (element.points[1][1] - height) / 2,\n  );\n  mutateElement(element, {\n    x: nextElementX,\n    y: nextElementY,\n    points: [\n      [0, 0],\n      [width, height],\n    ],\n  });\n};\n\nconst rescalePointsInElement = (\n  element: NonDeletedExcalidrawElement,\n  width: number,\n  height: number,\n) =>\n  isLinearElement(element) || isFreeDrawElement(element)\n    ? {\n        points: rescalePoints(\n          0,\n          width,\n          rescalePoints(1, height, element.points),\n        ),\n      }\n    : {};\n\nconst MIN_FONT_SIZE = 1;\n\nconst measureFontSizeFromWH = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  nextWidth: number,\n  nextHeight: number,\n): { size: number; baseline: number } | null => {\n  // We only use width to scale font on resize\n  const nextFontSize = element.fontSize * (nextWidth / element.width);\n  if (nextFontSize < MIN_FONT_SIZE) {\n    return null;\n  }\n  const metrics = measureText(\n    element.text,\n    getFontString({ fontSize: nextFontSize, fontFamily: element.fontFamily }),\n  );\n  return {\n    size: nextFontSize,\n    baseline: metrics.baseline + (nextHeight - metrics.height),\n  };\n};\n\nconst getSidesForTransformHandle = (\n  transformHandleType: TransformHandleType,\n  isResizeFromCenter: boolean,\n) => {\n  return {\n    n:\n      /^(n|ne|nw)$/.test(transformHandleType) ||\n      (isResizeFromCenter && /^(s|se|sw)$/.test(transformHandleType)),\n    s:\n      /^(s|se|sw)$/.test(transformHandleType) ||\n      (isResizeFromCenter && /^(n|ne|nw)$/.test(transformHandleType)),\n    w:\n      /^(w|nw|sw)$/.test(transformHandleType) ||\n      (isResizeFromCenter && /^(e|ne|se)$/.test(transformHandleType)),\n    e:\n      /^(e|ne|se)$/.test(transformHandleType) ||\n      (isResizeFromCenter && /^(w|nw|sw)$/.test(transformHandleType)),\n  };\n};\n\nconst resizeSingleTextElement = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  transformHandleType: \"nw\" | \"ne\" | \"sw\" | \"se\",\n  isResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // rotation pointer with reverse angle\n  const [rotatedX, rotatedY] = rotate(\n    pointerX,\n    pointerY,\n    cx,\n    cy,\n    -element.angle,\n  );\n  let scale: number;\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max(\n        (rotatedX - x1) / (x2 - x1),\n        (rotatedY - y1) / (y2 - y1),\n      );\n      break;\n    case \"nw\":\n      scale = Math.max(\n        (x2 - rotatedX) / (x2 - x1),\n        (y2 - rotatedY) / (y2 - y1),\n      );\n      break;\n    case \"ne\":\n      scale = Math.max(\n        (rotatedX - x1) / (x2 - x1),\n        (y2 - rotatedY) / (y2 - y1),\n      );\n      break;\n    case \"sw\":\n      scale = Math.max(\n        (x2 - rotatedX) / (x2 - x1),\n        (rotatedY - y1) / (y2 - y1),\n      );\n      break;\n  }\n  if (scale > 0) {\n    const nextWidth = element.width * scale;\n    const nextHeight = element.height * scale;\n    const nextFont = measureFontSizeFromWH(element, nextWidth, nextHeight);\n    if (nextFont === null) {\n      return;\n    }\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n    const [nextElementX, nextElementY] = adjustXYWithRotation(\n      getSidesForTransformHandle(transformHandleType, isResizeFromCenter),\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n    mutateElement(element, {\n      fontSize: nextFont.size,\n      width: nextWidth,\n      height: nextHeight,\n      baseline: nextFont.baseline,\n      x: nextElementX,\n      y: nextElementY,\n    });\n  }\n};\n\nexport const resizeSingleElement = (\n  stateAtResizeStart: NonDeletedExcalidrawElement,\n  shouldKeepSidesRatio: boolean,\n  element: NonDeletedExcalidrawElement,\n  transformHandleDirection: TransformHandleDirection,\n  isResizeFromCenter: boolean,\n  pointerX: number,\n  pointerY: number,\n) => {\n  // Gets bounds corners\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(\n    stateAtResizeStart,\n    stateAtResizeStart.width,\n    stateAtResizeStart.height,\n  );\n  const startTopLeft: Point = [x1, y1];\n  const startBottomRight: Point = [x2, y2];\n  const startCenter: Point = centerPoint(startTopLeft, startBottomRight);\n\n  // Calculate new dimensions based on cursor position\n  const rotatedPointer = rotatePoint(\n    [pointerX, pointerY],\n    startCenter,\n    -stateAtResizeStart.angle,\n  );\n\n  // Get bounds corners rendered on screen\n  const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(\n    element,\n    element.width,\n    element.height,\n  );\n  const boundsCurrentWidth = esx2 - esx1;\n  const boundsCurrentHeight = esy2 - esy1;\n\n  // It's important we set the initial scale value based on the width and height at resize start,\n  // otherwise previous dimensions affected by modifiers will be taken into account.\n  const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];\n  const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];\n  let scaleX = atStartBoundsWidth / boundsCurrentWidth;\n  let scaleY = atStartBoundsHeight / boundsCurrentHeight;\n\n  if (transformHandleDirection.includes(\"e\")) {\n    scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"s\")) {\n    scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;\n  }\n  if (transformHandleDirection.includes(\"w\")) {\n    scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;\n  }\n  if (transformHandleDirection.includes(\"n\")) {\n    scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;\n  }\n  // Linear elements dimensions differ from bounds dimensions\n  const eleInitialWidth = stateAtResizeStart.width;\n  const eleInitialHeight = stateAtResizeStart.height;\n  // We have to use dimensions of element on screen, otherwise the scaling of the\n  // dimensions won't match the cursor for linear elements.\n  let eleNewWidth = element.width * scaleX;\n  let eleNewHeight = element.height * scaleY;\n\n  // adjust dimensions for resizing from center\n  if (isResizeFromCenter) {\n    eleNewWidth = 2 * eleNewWidth - eleInitialWidth;\n    eleNewHeight = 2 * eleNewHeight - eleInitialHeight;\n  }\n\n  // adjust dimensions to keep sides ratio\n  if (shouldKeepSidesRatio) {\n    const widthRatio = Math.abs(eleNewWidth) / eleInitialWidth;\n    const heightRatio = Math.abs(eleNewHeight) / eleInitialHeight;\n    if (transformHandleDirection.length === 1) {\n      eleNewHeight *= widthRatio;\n      eleNewWidth *= heightRatio;\n    }\n    if (transformHandleDirection.length === 2) {\n      const ratio = Math.max(widthRatio, heightRatio);\n      eleNewWidth = eleInitialWidth * ratio * Math.sign(eleNewWidth);\n      eleNewHeight = eleInitialHeight * ratio * Math.sign(eleNewHeight);\n    }\n  }\n\n  const [\n    newBoundsX1,\n    newBoundsY1,\n    newBoundsX2,\n    newBoundsY2,\n  ] = getResizedElementAbsoluteCoords(\n    stateAtResizeStart,\n    eleNewWidth,\n    eleNewHeight,\n  );\n  const newBoundsWidth = newBoundsX2 - newBoundsX1;\n  const newBoundsHeight = newBoundsY2 - newBoundsY1;\n\n  // Calculate new topLeft based on fixed corner during resize\n  let newTopLeft = [...startTopLeft] as [number, number];\n  if ([\"n\", \"w\", \"nw\"].includes(transformHandleDirection)) {\n    newTopLeft = [\n      startBottomRight[0] - Math.abs(newBoundsWidth),\n      startBottomRight[1] - Math.abs(newBoundsHeight),\n    ];\n  }\n  if (transformHandleDirection === \"ne\") {\n    const bottomLeft = [startTopLeft[0], startBottomRight[1]];\n    newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];\n  }\n  if (transformHandleDirection === \"sw\") {\n    const topRight = [startBottomRight[0], startTopLeft[1]];\n    newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];\n  }\n\n  // Keeps opposite handle fixed during resize\n  if (shouldKeepSidesRatio) {\n    if ([\"s\", \"n\"].includes(transformHandleDirection)) {\n      newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;\n    }\n    if ([\"e\", \"w\"].includes(transformHandleDirection)) {\n      newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;\n    }\n  }\n\n  // Flip horizontally\n  if (eleNewWidth < 0) {\n    if (transformHandleDirection.includes(\"e\")) {\n      newTopLeft[0] -= Math.abs(newBoundsWidth);\n    }\n    if (transformHandleDirection.includes(\"w\")) {\n      newTopLeft[0] += Math.abs(newBoundsWidth);\n    }\n  }\n  // Flip vertically\n  if (eleNewHeight < 0) {\n    if (transformHandleDirection.includes(\"s\")) {\n      newTopLeft[1] -= Math.abs(newBoundsHeight);\n    }\n    if (transformHandleDirection.includes(\"n\")) {\n      newTopLeft[1] += Math.abs(newBoundsHeight);\n    }\n  }\n\n  if (isResizeFromCenter) {\n    newTopLeft[0] = startCenter[0] - Math.abs(newBoundsWidth) / 2;\n    newTopLeft[1] = startCenter[1] - Math.abs(newBoundsHeight) / 2;\n  }\n\n  // adjust topLeft to new rotation point\n  const angle = stateAtResizeStart.angle;\n  const rotatedTopLeft = rotatePoint(newTopLeft, startCenter, angle);\n  const newCenter: Point = [\n    newTopLeft[0] + Math.abs(newBoundsWidth) / 2,\n    newTopLeft[1] + Math.abs(newBoundsHeight) / 2,\n  ];\n  const rotatedNewCenter = rotatePoint(newCenter, startCenter, angle);\n  newTopLeft = rotatePoint(rotatedTopLeft, rotatedNewCenter, -angle);\n\n  // Readjust points for linear elements\n  const rescaledPoints = rescalePointsInElement(\n    stateAtResizeStart,\n    eleNewWidth,\n    eleNewHeight,\n  );\n  // For linear elements (x,y) are the coordinates of the first drawn point not the top-left corner\n  // So we need to readjust (x,y) to be where the first point should be\n  const newOrigin = [...newTopLeft];\n  newOrigin[0] += stateAtResizeStart.x - newBoundsX1;\n  newOrigin[1] += stateAtResizeStart.y - newBoundsY1;\n\n  const resizedElement = {\n    width: Math.abs(eleNewWidth),\n    height: Math.abs(eleNewHeight),\n    x: newOrigin[0],\n    y: newOrigin[1],\n    ...rescaledPoints,\n  };\n\n  if (\n    resizedElement.width !== 0 &&\n    resizedElement.height !== 0 &&\n    Number.isFinite(resizedElement.x) &&\n    Number.isFinite(resizedElement.y)\n  ) {\n    updateBoundElements(element, {\n      newSize: { width: resizedElement.width, height: resizedElement.height },\n    });\n    mutateElement(element, resizedElement);\n  }\n};\n\nconst resizeMultipleElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  transformHandleType: \"nw\" | \"ne\" | \"sw\" | \"se\",\n  pointerX: number,\n  pointerY: number,\n) => {\n  const [x1, y1, x2, y2] = getCommonBounds(elements);\n  let scale: number;\n  let getNextXY: (\n    element: NonDeletedExcalidrawElement,\n    origCoords: readonly [number, number, number, number],\n    finalCoords: readonly [number, number, number, number],\n  ) => { x: number; y: number };\n  switch (transformHandleType) {\n    case \"se\":\n      scale = Math.max(\n        (pointerX - x1) / (x2 - x1),\n        (pointerY - y1) / (y2 - y1),\n      );\n      getNextXY = (element, [origX1, origY1], [finalX1, finalY1]) => {\n        const x = element.x + (origX1 - x1) * (scale - 1) + origX1 - finalX1;\n        const y = element.y + (origY1 - y1) * (scale - 1) + origY1 - finalY1;\n        return { x, y };\n      };\n      break;\n    case \"nw\":\n      scale = Math.max(\n        (x2 - pointerX) / (x2 - x1),\n        (y2 - pointerY) / (y2 - y1),\n      );\n      getNextXY = (element, [, , origX2, origY2], [, , finalX2, finalY2]) => {\n        const x = element.x - (x2 - origX2) * (scale - 1) + origX2 - finalX2;\n        const y = element.y - (y2 - origY2) * (scale - 1) + origY2 - finalY2;\n        return { x, y };\n      };\n      break;\n    case \"ne\":\n      scale = Math.max(\n        (pointerX - x1) / (x2 - x1),\n        (y2 - pointerY) / (y2 - y1),\n      );\n      getNextXY = (element, [origX1, , , origY2], [finalX1, , , finalY2]) => {\n        const x = element.x + (origX1 - x1) * (scale - 1) + origX1 - finalX1;\n        const y = element.y - (y2 - origY2) * (scale - 1) + origY2 - finalY2;\n        return { x, y };\n      };\n      break;\n    case \"sw\":\n      scale = Math.max(\n        (x2 - pointerX) / (x2 - x1),\n        (pointerY - y1) / (y2 - y1),\n      );\n      getNextXY = (element, [, origY1, origX2], [, finalY1, finalX2]) => {\n        const x = element.x - (x2 - origX2) * (scale - 1) + origX2 - finalX2;\n        const y = element.y + (origY1 - y1) * (scale - 1) + origY1 - finalY1;\n        return { x, y };\n      };\n      break;\n  }\n  if (scale > 0) {\n    const updates = elements.reduce(\n      (prev, element) => {\n        if (!prev) {\n          return prev;\n        }\n        const width = element.width * scale;\n        const height = element.height * scale;\n        let font: { fontSize?: number; baseline?: number } = {};\n        if (element.type === \"text\") {\n          const nextFont = measureFontSizeFromWH(element, width, height);\n          if (nextFont === null) {\n            return null;\n          }\n          font = { fontSize: nextFont.size, baseline: nextFont.baseline };\n        }\n        const origCoords = getElementAbsoluteCoords(element);\n\n        const rescaledPoints = rescalePointsInElement(element, width, height);\n\n        updateBoundElements(element, {\n          newSize: { width, height },\n          simultaneouslyUpdated: elements,\n        });\n\n        const finalCoords = getResizedElementAbsoluteCoords(\n          {\n            ...element,\n            ...rescaledPoints,\n          },\n          width,\n          height,\n        );\n\n        const { x, y } = getNextXY(element, origCoords, finalCoords);\n        return [...prev, { width, height, x, y, ...rescaledPoints, ...font }];\n      },\n      [] as\n        | {\n            width: number;\n            height: number;\n            x: number;\n            y: number;\n            points?: (readonly [number, number])[];\n            fontSize?: number;\n            baseline?: number;\n          }[]\n        | null,\n    );\n    if (updates) {\n      elements.forEach((element, index) => {\n        mutateElement(element, updates[index]);\n      });\n    }\n  }\n};\n\nconst rotateMultipleElements = (\n  pointerDownState: PointerDownState,\n  elements: readonly NonDeletedExcalidrawElement[],\n  pointerX: number,\n  pointerY: number,\n  isRotateWithDiscreteAngle: boolean,\n  centerX: number,\n  centerY: number,\n) => {\n  let centerAngle =\n    (5 * Math.PI) / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);\n  if (isRotateWithDiscreteAngle) {\n    centerAngle += SHIFT_LOCKING_ANGLE / 2;\n    centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;\n  }\n  elements.forEach((element, index) => {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const origAngle =\n      pointerDownState.originalElements.get(element.id)?.angle ?? element.angle;\n    const [rotatedCX, rotatedCY] = rotate(\n      cx,\n      cy,\n      centerX,\n      centerY,\n      centerAngle + origAngle - element.angle,\n    );\n    mutateElement(element, {\n      x: element.x + (rotatedCX - cx),\n      y: element.y + (rotatedCY - cy),\n      angle: normalizeAngle(centerAngle + origAngle),\n    });\n  });\n};\n\nexport const getResizeOffsetXY = (\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1, x2, y2] =\n    selectedElements.length === 1\n      ? getElementAbsoluteCoords(selectedElements[0])\n      : getCommonBounds(selectedElements);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const angle = selectedElements.length === 1 ? selectedElements[0].angle : 0;\n  [x, y] = rotate(x, y, cx, cy, -angle);\n  switch (transformHandleType) {\n    case \"n\":\n      return rotate(x - (x1 + x2) / 2, y - y1, 0, 0, angle);\n    case \"s\":\n      return rotate(x - (x1 + x2) / 2, y - y2, 0, 0, angle);\n    case \"w\":\n      return rotate(x - x1, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"e\":\n      return rotate(x - x2, y - (y1 + y2) / 2, 0, 0, angle);\n    case \"nw\":\n      return rotate(x - x1, y - y1, 0, 0, angle);\n    case \"ne\":\n      return rotate(x - x2, y - y1, 0, 0, angle);\n    case \"sw\":\n      return rotate(x - x1, y - y2, 0, 0, angle);\n    case \"se\":\n      return rotate(x - x2, y - y2, 0, 0, angle);\n    default:\n      return [0, 0];\n  }\n};\n\nexport const getResizeArrowDirection = (\n  transformHandleType: MaybeTransformHandleType,\n  element: NonDeleted<ExcalidrawLinearElement>,\n): \"origin\" | \"end\" => {\n  const [, [px, py]] = element.points;\n  const isResizeEnd =\n    (transformHandleType === \"nw\" && (px < 0 || py < 0)) ||\n    (transformHandleType === \"ne\" && px >= 0) ||\n    (transformHandleType === \"sw\" && px <= 0) ||\n    (transformHandleType === \"se\" && (px > 0 || py > 0));\n  return isResizeEnd ? \"end\" : \"origin\";\n};\n","import { SHAPES } from \"../shapes\";\nimport { updateBoundElements } from \"./binding\";\nimport { getCommonBounds } from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport Scene from \"../scene/Scene\";\nimport { NonDeletedExcalidrawElement } from \"./types\";\nimport { PointerDownState } from \"../types\";\n\nexport const dragSelectedElements = (\n  pointerDownState: PointerDownState,\n  selectedElements: NonDeletedExcalidrawElement[],\n  pointerX: number,\n  pointerY: number,\n  scene: Scene,\n  lockDirection: boolean = false,\n  distanceX: number = 0,\n  distanceY: number = 0,\n) => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  const offset = { x: pointerX - x1, y: pointerY - y1 };\n  selectedElements.forEach((element) => {\n    let x: number;\n    let y: number;\n    if (lockDirection) {\n      const lockX = lockDirection && distanceX < distanceY;\n      const lockY = lockDirection && distanceX > distanceY;\n      const original = pointerDownState.originalElements.get(element.id);\n      x = lockX && original ? original.x : element.x + offset.x;\n      y = lockY && original ? original.y : element.y + offset.y;\n    } else {\n      x = element.x + offset.x;\n      y = element.y + offset.y;\n    }\n\n    mutateElement(element, {\n      x,\n      y,\n    });\n\n    updateBoundElements(element, {\n      simultaneouslyUpdated: selectedElements,\n    });\n  });\n};\n\nexport const getDragOffsetXY = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  return [x - x1, y - y1];\n};\n\nexport const dragNewElement = (\n  draggingElement: NonDeletedExcalidrawElement,\n  elementType: typeof SHAPES[number][\"value\"],\n  originX: number,\n  originY: number,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  isResizeWithSidesSameLength: boolean,\n  isResizeCenterPoint: boolean,\n) => {\n  if (isResizeWithSidesSameLength) {\n    ({ width, height } = getPerfectElementSize(\n      elementType,\n      width,\n      y < originY ? -height : height,\n    ));\n\n    if (height < 0) {\n      height = -height;\n    }\n  }\n\n  let newX = x < originX ? originX - width : originX;\n  let newY = y < originY ? originY - height : originY;\n\n  if (isResizeCenterPoint) {\n    width += width;\n    height += height;\n    newX = originX - width / 2;\n    newY = originY - height / 2;\n  }\n\n  if (width !== 0 && height !== 0) {\n    mutateElement(draggingElement, {\n      x: newX,\n      y: newY,\n      width,\n      height,\n    });\n  }\n};\n","import { CODES, KEYS } from \"../keys\";\nimport { isWritableElement, getFontString } from \"../utils\";\nimport Scene from \"../scene/Scene\";\nimport { isTextElement } from \"./typeChecks\";\nimport { CLASSES } from \"../constants\";\nimport { ExcalidrawElement } from \"./types\";\nimport { AppState } from \"../types\";\n\nconst normalizeText = (text: string) => {\n  return (\n    text\n      // replace tabs with spaces so they render and measure correctly\n      .replace(/\\t/g, \"        \")\n      // normalize newlines\n      .replace(/\\r?\\n|\\r/g, \"\\n\")\n  );\n};\n\nconst getTransform = (\n  width: number,\n  height: number,\n  angle: number,\n  appState: AppState,\n  maxWidth: number,\n) => {\n  const { zoom, offsetTop, offsetLeft } = appState;\n  const degree = (180 * angle) / Math.PI;\n  // offsets must be multiplied by 2 to account for the division by 2 of\n  // the whole expression afterwards\n  let translateX = ((width - offsetLeft * 2) * (zoom.value - 1)) / 2;\n  const translateY = ((height - offsetTop * 2) * (zoom.value - 1)) / 2;\n  if (width > maxWidth && zoom.value !== 1) {\n    translateX = (maxWidth / 2) * (zoom.value - 1);\n  }\n  return `translate(${translateX}px, ${translateY}px) scale(${zoom.value}) rotate(${degree}deg)`;\n};\n\nexport const textWysiwyg = ({\n  id,\n  appState,\n  onChange,\n  onSubmit,\n  getViewportCoords,\n  element,\n  canvas,\n  excalidrawContainer,\n}: {\n  id: ExcalidrawElement[\"id\"];\n  appState: AppState;\n  onChange?: (text: string) => void;\n  onSubmit: (data: { text: string; viaKeyboard: boolean }) => void;\n  getViewportCoords: (x: number, y: number) => [number, number];\n  element: ExcalidrawElement;\n  canvas: HTMLCanvasElement | null;\n  excalidrawContainer: HTMLDivElement | null;\n}) => {\n  const updateWysiwygStyle = () => {\n    const updatedElement = Scene.getScene(element)?.getElement(id);\n    if (updatedElement && isTextElement(updatedElement)) {\n      const [viewportX, viewportY] = getViewportCoords(\n        updatedElement.x,\n        updatedElement.y,\n      );\n      const { textAlign, angle } = updatedElement;\n\n      editable.value = updatedElement.text;\n\n      const lines = updatedElement.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n      const lineHeight = updatedElement.height / lines.length;\n      const maxWidth =\n        (appState.offsetLeft + appState.width - viewportX - 8) /\n          appState.zoom.value -\n        // margin-right of parent if any\n        Number(\n          getComputedStyle(\n            excalidrawContainer?.parentNode as Element,\n          ).marginRight.slice(0, -2),\n        );\n\n      Object.assign(editable.style, {\n        font: getFontString(updatedElement),\n        // must be defined *after* font ¯\\_(ツ)_/¯\n        lineHeight: `${lineHeight}px`,\n        width: `${updatedElement.width}px`,\n        height: `${updatedElement.height}px`,\n        left: `${viewportX}px`,\n        top: `${viewportY}px`,\n        transform: getTransform(\n          updatedElement.width,\n          updatedElement.height,\n          angle,\n          appState,\n          maxWidth,\n        ),\n        textAlign,\n        color: updatedElement.strokeColor,\n        opacity: updatedElement.opacity / 100,\n        filter: \"var(--theme-filter)\",\n        maxWidth: `${maxWidth}px`,\n      });\n    }\n  };\n\n  const editable = document.createElement(\"textarea\");\n\n  editable.dir = \"auto\";\n  editable.tabIndex = 0;\n  editable.dataset.type = \"wysiwyg\";\n  // prevent line wrapping on Safari\n  editable.wrap = \"off\";\n\n  Object.assign(editable.style, {\n    position: \"absolute\",\n    display: \"inline-block\",\n    minHeight: \"1em\",\n    backfaceVisibility: \"hidden\",\n    margin: 0,\n    padding: 0,\n    border: 0,\n    outline: 0,\n    resize: \"none\",\n    background: \"transparent\",\n    overflow: \"hidden\",\n    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)\n    whiteSpace: \"pre\",\n    // must be specified because in dark mode canvas creates a stacking context\n    zIndex: \"var(--zIndex-wysiwyg)\",\n  });\n\n  updateWysiwygStyle();\n\n  if (onChange) {\n    editable.oninput = () => {\n      onChange(normalizeText(editable.value));\n    };\n  }\n\n  editable.onkeydown = (event) => {\n    event.stopPropagation();\n    if (event.key === KEYS.ESCAPE) {\n      event.preventDefault();\n      submittedViaKeyboard = true;\n      handleSubmit();\n    } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {\n      event.preventDefault();\n      if (event.isComposing || event.keyCode === 229) {\n        return;\n      }\n      submittedViaKeyboard = true;\n      handleSubmit();\n    } else if (\n      event.key === KEYS.TAB ||\n      (event[KEYS.CTRL_OR_CMD] &&\n        (event.code === CODES.BRACKET_LEFT ||\n          event.code === CODES.BRACKET_RIGHT))\n    ) {\n      event.preventDefault();\n      if (event.shiftKey || event.code === CODES.BRACKET_LEFT) {\n        outdent();\n      } else {\n        indent();\n      }\n      // We must send an input event to resize the element\n      editable.dispatchEvent(new Event(\"input\"));\n    }\n  };\n\n  const TAB_SIZE = 4;\n  const TAB = \" \".repeat(TAB_SIZE);\n  const RE_LEADING_TAB = new RegExp(`^ {1,${TAB_SIZE}}`);\n  const indent = () => {\n    const { selectionStart, selectionEnd } = editable;\n    const linesStartIndices = getSelectedLinesStartIndices();\n\n    let value = editable.value;\n    linesStartIndices.forEach((startIndex) => {\n      const startValue = value.slice(0, startIndex);\n      const endValue = value.slice(startIndex);\n\n      value = `${startValue}${TAB}${endValue}`;\n    });\n\n    editable.value = value;\n\n    editable.selectionStart = selectionStart + TAB_SIZE;\n    editable.selectionEnd = selectionEnd + TAB_SIZE * linesStartIndices.length;\n  };\n\n  const outdent = () => {\n    const { selectionStart, selectionEnd } = editable;\n    const linesStartIndices = getSelectedLinesStartIndices();\n    const removedTabs: number[] = [];\n\n    let value = editable.value;\n    linesStartIndices.forEach((startIndex) => {\n      const tabMatch = value\n        .slice(startIndex, startIndex + TAB_SIZE)\n        .match(RE_LEADING_TAB);\n\n      if (tabMatch) {\n        const startValue = value.slice(0, startIndex);\n        const endValue = value.slice(startIndex + tabMatch[0].length);\n\n        // Delete a tab from the line\n        value = `${startValue}${endValue}`;\n        removedTabs.push(startIndex);\n      }\n    });\n\n    editable.value = value;\n\n    if (removedTabs.length) {\n      if (selectionStart > removedTabs[removedTabs.length - 1]) {\n        editable.selectionStart = Math.max(\n          selectionStart - TAB_SIZE,\n          removedTabs[removedTabs.length - 1],\n        );\n      } else {\n        // If the cursor is before the first tab removed, ex:\n        // Line| #1\n        //     Line #2\n        // Lin|e #3\n        // we should reset the selectionStart to his initial value.\n        editable.selectionStart = selectionStart;\n      }\n      editable.selectionEnd = Math.max(\n        editable.selectionStart,\n        selectionEnd - TAB_SIZE * removedTabs.length,\n      );\n    }\n  };\n\n  /**\n   * @returns indeces of start positions of selected lines, in reverse order\n   */\n  const getSelectedLinesStartIndices = () => {\n    let { selectionStart, selectionEnd, value } = editable;\n\n    // chars before selectionStart on the same line\n    const startOffset = value.slice(0, selectionStart).match(/[^\\n]*$/)![0]\n      .length;\n    // put caret at the start of the line\n    selectionStart = selectionStart - startOffset;\n\n    const selected = value.slice(selectionStart, selectionEnd);\n\n    return selected\n      .split(\"\\n\")\n      .reduce(\n        (startIndices, line, idx, lines) =>\n          startIndices.concat(\n            idx\n              ? // curr line index is prev line's start + prev line's length + \\n\n                startIndices[idx - 1] + lines[idx - 1].length + 1\n              : // first selected line\n                selectionStart,\n          ),\n        [] as number[],\n      )\n      .reverse();\n  };\n\n  const stopEvent = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  // using a state variable instead of passing it to the handleSubmit callback\n  // so that we don't need to create separate a callback for event handlers\n  let submittedViaKeyboard = false;\n  const handleSubmit = () => {\n    // cleanup must be run before onSubmit otherwise when app blurs the wysiwyg\n    // it'd get stuck in an infinite loop of blur→onSubmit after we re-focus the\n    // wysiwyg on update\n    cleanup();\n    onSubmit({\n      text: normalizeText(editable.value),\n      viaKeyboard: submittedViaKeyboard,\n    });\n  };\n\n  const cleanup = () => {\n    if (isDestroyed) {\n      return;\n    }\n    isDestroyed = true;\n    // remove events to ensure they don't late-fire\n    editable.onblur = null;\n    editable.oninput = null;\n    editable.onkeydown = null;\n\n    if (observer) {\n      observer.disconnect();\n    }\n\n    window.removeEventListener(\"resize\", updateWysiwygStyle);\n    window.removeEventListener(\"wheel\", stopEvent, true);\n    window.removeEventListener(\"pointerdown\", onPointerDown);\n    window.removeEventListener(\"pointerup\", bindBlurEvent);\n    window.removeEventListener(\"blur\", handleSubmit);\n\n    unbindUpdate();\n\n    editable.remove();\n  };\n\n  const bindBlurEvent = () => {\n    window.removeEventListener(\"pointerup\", bindBlurEvent);\n    // Deferred so that the pointerdown that initiates the wysiwyg doesn't\n    // trigger the blur on ensuing pointerup.\n    // Also to handle cases such as picking a color which would trigger a blur\n    // in that same tick.\n    setTimeout(() => {\n      editable.onblur = handleSubmit;\n      // case: clicking on the same property → no change → no update → no focus\n      editable.focus();\n    });\n  };\n\n  // prevent blur when changing properties from the menu\n  const onPointerDown = (event: MouseEvent) => {\n    if (\n      (event.target instanceof HTMLElement ||\n        event.target instanceof SVGElement) &&\n      event.target.closest(`.${CLASSES.SHAPE_ACTIONS_MENU}`) &&\n      !isWritableElement(event.target)\n    ) {\n      editable.onblur = null;\n      window.addEventListener(\"pointerup\", bindBlurEvent);\n      // handle edge-case where pointerup doesn't fire e.g. due to user\n      // alt-tabbing away\n      window.addEventListener(\"blur\", handleSubmit);\n    }\n  };\n\n  // handle updates of textElement properties of editing element\n  const unbindUpdate = Scene.getScene(element)!.addCallback(() => {\n    updateWysiwygStyle();\n    editable.focus();\n  });\n\n  // ---------------------------------------------------------------------------\n\n  let isDestroyed = false;\n\n  // select on init (focusing is done separately inside the bindBlurEvent()\n  // because we need it to happen *after* the blur event from `pointerdown`)\n  editable.select();\n  bindBlurEvent();\n\n  // reposition wysiwyg in case of canvas is resized. Using ResizeObserver\n  // is preferred so we catch changes from host, where window may not resize.\n  let observer: ResizeObserver | null = null;\n  if (canvas && \"ResizeObserver\" in window) {\n    observer = new window.ResizeObserver(() => {\n      updateWysiwygStyle();\n    });\n    observer.observe(canvas);\n  } else {\n    window.addEventListener(\"resize\", updateWysiwygStyle);\n  }\n\n  window.addEventListener(\"pointerdown\", onPointerDown);\n  window.addEventListener(\"wheel\", stopEvent, {\n    passive: false,\n    capture: true,\n  });\n  excalidrawContainer\n    ?.querySelector(\".excalidraw-textEditorContainer\")!\n    .appendChild(editable);\n};\n","import { measureText, getFontString } from \"../utils\";\nimport { ExcalidrawTextElement } from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\n\nexport const redrawTextBoundingBox = (element: ExcalidrawTextElement) => {\n  const metrics = measureText(element.text, getFontString(element));\n  mutateElement(element, {\n    width: metrics.width,\n    height: metrics.height,\n    baseline: metrics.baseline,\n  });\n};\n","import { AppState } from \"../types\";\nimport { NonDeletedExcalidrawElement } from \"./types\";\nimport { getSelectedElements } from \"../scene\";\n\nexport const showSelectedShapeActions = (\n  appState: AppState,\n  elements: readonly NonDeletedExcalidrawElement[],\n) =>\n  Boolean(\n    !appState.viewModeEnabled &&\n      (appState.editingElement ||\n        getSelectedElements(elements, appState).length ||\n        appState.elementType !== \"selection\"),\n  );\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"./types\";\nimport { isInvisiblySmallElement } from \"./sizeHelpers\";\nimport { isLinearElementType } from \"./typeChecks\";\n\nexport {\n  newElement,\n  newTextElement,\n  updateTextElement,\n  newLinearElement,\n  duplicateElement,\n} from \"./newElement\";\nexport {\n  getElementAbsoluteCoords,\n  getElementBounds,\n  getCommonBounds,\n  getDiamondPoints,\n  getArrowheadPoints,\n  getClosestElementBounds,\n} from \"./bounds\";\n\nexport {\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n} from \"./transformHandles\";\nexport {\n  hitTest,\n  isHittingElementBoundingBoxWithoutHittingElement,\n} from \"./collision\";\nexport {\n  resizeTest,\n  getCursorForResizingElement,\n  getElementWithTransformHandleType,\n  getTransformHandleTypeFromCoords,\n} from \"./resizeTest\";\nexport {\n  transformElements,\n  getResizeOffsetXY,\n  getResizeArrowDirection,\n} from \"./resizeElements\";\nexport {\n  dragSelectedElements,\n  getDragOffsetXY,\n  dragNewElement,\n} from \"./dragElements\";\nexport { isTextElement, isExcalidrawElement } from \"./typeChecks\";\nexport { textWysiwyg } from \"./textWysiwyg\";\nexport { redrawTextBoundingBox } from \"./textElement\";\nexport {\n  getPerfectElementSize,\n  isInvisiblySmallElement,\n  resizePerfectLineForNWHandler,\n  getNormalizedDimensions,\n} from \"./sizeHelpers\";\nexport { showSelectedShapeActions } from \"./showSelectedShapeActions\";\n\nexport const getElementMap = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce(\n    (acc: { [key: string]: ExcalidrawElement }, element: ExcalidrawElement) => {\n      acc[element.id] = element;\n      return acc;\n    },\n    {},\n  );\n\nexport const getSceneVersion = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce((acc, el) => acc + el.version, 0);\n\nexport const getVisibleElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter(\n    (el) => !el.isDeleted && !isInvisiblySmallElement(el),\n  ) as readonly NonDeletedExcalidrawElement[];\n\nexport const getNonDeletedElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter(\n    (element) => !element.isDeleted,\n  ) as readonly NonDeletedExcalidrawElement[];\n\nexport const isNonDeletedElement = <T extends ExcalidrawElement>(\n  element: T,\n): element is NonDeleted<T> => !element.isDeleted;\n\nconst _clearElements = (\n  elements: readonly ExcalidrawElement[],\n): ExcalidrawElement[] =>\n  getNonDeletedElements(elements).map((element) =>\n    isLinearElementType(element.type)\n      ? { ...element, lastCommittedPoint: null }\n      : element,\n  );\n\nexport const clearElementsForExport = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n\nexport const clearElementsForLocalStorage = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n","import { ExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds } from \"../element\";\nimport { Zoom } from \"../types\";\nimport { ScrollBars } from \"./types\";\nimport { getGlobalCSSVariable } from \"../utils\";\nimport { getLanguage } from \"../i18n\";\n\nexport const SCROLLBAR_MARGIN = 4;\nexport const SCROLLBAR_WIDTH = 6;\nexport const SCROLLBAR_COLOR = \"rgba(0,0,0,0.3)\";\n\nexport const getScrollBars = (\n  elements: readonly ExcalidrawElement[],\n  viewportWidth: number,\n  viewportHeight: number,\n  {\n    scrollX,\n    scrollY,\n    zoom,\n  }: {\n    scrollX: number;\n    scrollY: number;\n    zoom: Zoom;\n  },\n): ScrollBars => {\n  if (elements.length === 0) {\n    return {\n      horizontal: null,\n      vertical: null,\n    };\n  }\n  // This is the bounding box of all the elements\n  const [\n    elementsMinX,\n    elementsMinY,\n    elementsMaxX,\n    elementsMaxY,\n  ] = getCommonBounds(elements);\n\n  // Apply zoom\n  const viewportWidthWithZoom = viewportWidth / zoom.value;\n  const viewportHeightWithZoom = viewportHeight / zoom.value;\n\n  const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;\n  const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;\n\n  const safeArea = {\n    top: parseInt(getGlobalCSSVariable(\"sat\")),\n    bottom: parseInt(getGlobalCSSVariable(\"sab\")),\n    left: parseInt(getGlobalCSSVariable(\"sal\")),\n    right: parseInt(getGlobalCSSVariable(\"sar\")),\n  };\n\n  const isRTL = getLanguage().rtl;\n\n  // The viewport is the rectangle currently visible for the user\n  const viewportMinX = -scrollX + viewportWidthDiff / 2 + safeArea.left;\n  const viewportMinY = -scrollY + viewportHeightDiff / 2 + safeArea.top;\n  const viewportMaxX = viewportMinX + viewportWidthWithZoom - safeArea.right;\n  const viewportMaxY = viewportMinY + viewportHeightWithZoom - safeArea.bottom;\n\n  // The scene is the bounding box of both the elements and viewport\n  const sceneMinX = Math.min(elementsMinX, viewportMinX);\n  const sceneMinY = Math.min(elementsMinY, viewportMinY);\n  const sceneMaxX = Math.max(elementsMaxX, viewportMaxX);\n  const sceneMaxY = Math.max(elementsMaxY, viewportMaxY);\n\n  // The scrollbar represents where the viewport is in relationship to the scene\n\n  return {\n    horizontal:\n      viewportMinX === sceneMinX && viewportMaxX === sceneMaxX\n        ? null\n        : {\n            x:\n              Math.max(safeArea.left, SCROLLBAR_MARGIN) +\n              ((viewportMinX - sceneMinX) / (sceneMaxX - sceneMinX)) *\n                viewportWidth,\n            y:\n              viewportHeight -\n              SCROLLBAR_WIDTH -\n              Math.max(SCROLLBAR_MARGIN, safeArea.bottom),\n            width:\n              ((viewportMaxX - viewportMinX) / (sceneMaxX - sceneMinX)) *\n                viewportWidth -\n              Math.max(SCROLLBAR_MARGIN * 2, safeArea.left + safeArea.right),\n            height: SCROLLBAR_WIDTH,\n          },\n    vertical:\n      viewportMinY === sceneMinY && viewportMaxY === sceneMaxY\n        ? null\n        : {\n            x: isRTL\n              ? Math.max(safeArea.left, SCROLLBAR_MARGIN)\n              : viewportWidth -\n                SCROLLBAR_WIDTH -\n                Math.max(safeArea.right, SCROLLBAR_MARGIN),\n            y:\n              ((viewportMinY - sceneMinY) / (sceneMaxY - sceneMinY)) *\n                viewportHeight +\n              Math.max(safeArea.top, SCROLLBAR_MARGIN),\n            width: SCROLLBAR_WIDTH,\n            height:\n              ((viewportMaxY - viewportMinY) / (sceneMaxY - sceneMinY)) *\n                viewportHeight -\n              Math.max(SCROLLBAR_MARGIN * 2, safeArea.top + safeArea.bottom),\n          },\n  };\n};\n\nexport const isOverScrollBars = (\n  scrollBars: ScrollBars,\n  x: number,\n  y: number,\n): {\n  isOverEither: boolean;\n  isOverHorizontal: boolean;\n  isOverVertical: boolean;\n} => {\n  const [isOverHorizontal, isOverVertical] = [\n    scrollBars.horizontal,\n    scrollBars.vertical,\n  ].map((scrollBar) => {\n    return (\n      scrollBar != null &&\n      scrollBar.x <= x &&\n      x <= scrollBar.x + scrollBar.width &&\n      scrollBar.y <= y &&\n      y <= scrollBar.y + scrollBar.height\n    );\n  });\n  const isOverEither = isOverHorizontal || isOverVertical;\n  return { isOverEither, isOverHorizontal, isOverVertical };\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { getElementAbsoluteCoords, getElementBounds } from \"../element\";\nimport { AppState } from \"../types\";\n\nexport const getElementsWithinSelection = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selection: NonDeletedExcalidrawElement,\n) => {\n  const [\n    selectionX1,\n    selectionY1,\n    selectionX2,\n    selectionY2,\n  ] = getElementAbsoluteCoords(selection);\n  return elements.filter((element) => {\n    const [elementX1, elementY1, elementX2, elementY2] = getElementBounds(\n      element,\n    );\n\n    return (\n      element.type !== \"selection\" &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2\n    );\n  });\n};\n\nexport const isSomeElementSelected = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n): boolean =>\n  elements.some((element) => appState.selectedElementIds[element.id]);\n\n/**\n * Returns common attribute (picked by `getAttribute` callback) of selected\n *  elements. If elements don't share the same value, returns `null`.\n */\nexport const getCommonAttributeOfSelectedElements = <T>(\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  getAttribute: (element: ExcalidrawElement) => T,\n): T | null => {\n  const attributes = Array.from(\n    new Set(\n      getSelectedElements(elements, appState).map((element) =>\n        getAttribute(element),\n      ),\n    ),\n  );\n  return attributes.length === 1 ? attributes[0] : null;\n};\n\nexport const getSelectedElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => elements.filter((element) => appState.selectedElementIds[element.id]);\n\nexport const getTargetElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) =>\n  appState.editingElement\n    ? [appState.editingElement]\n    : getSelectedElements(elements, appState);\n","import { AppState, PointerCoords, Zoom } from \"../types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport {\n  getCommonBounds,\n  getClosestElementBounds,\n  getVisibleElements,\n} from \"../element\";\n\nimport {\n  sceneCoordsToViewportCoords,\n  viewportCoordsToSceneCoords,\n} from \"../utils\";\n\nconst isOutsideViewPort = (\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n  cords: Array<number>,\n) => {\n  const [x1, y1, x2, y2] = cords;\n  const { x: viewportX1, y: viewportY1 } = sceneCoordsToViewportCoords(\n    { sceneX: x1, sceneY: y1 },\n    appState,\n  );\n  const { x: viewportX2, y: viewportY2 } = sceneCoordsToViewportCoords(\n    { sceneX: x2, sceneY: y2 },\n    appState,\n  );\n  return (\n    viewportX2 - viewportX1 > appState.width ||\n    viewportY2 - viewportY1 > appState.height\n  );\n};\n\nexport const centerScrollOn = ({\n  scenePoint,\n  viewportDimensions,\n  zoom,\n}: {\n  scenePoint: PointerCoords;\n  viewportDimensions: { height: number; width: number };\n  zoom: Zoom;\n}) => {\n  return {\n    scrollX:\n      (viewportDimensions.width / 2) * (1 / zoom.value) -\n      scenePoint.x -\n      zoom.translation.x * (1 / zoom.value),\n    scrollY:\n      (viewportDimensions.height / 2) * (1 / zoom.value) -\n      scenePoint.y -\n      zoom.translation.y * (1 / zoom.value),\n  };\n};\n\nexport const calculateScrollCenter = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n): { scrollX: number; scrollY: number } => {\n  elements = getVisibleElements(elements);\n\n  if (!elements.length) {\n    return {\n      scrollX: 0,\n      scrollY: 0,\n    };\n  }\n  let [x1, y1, x2, y2] = getCommonBounds(elements);\n\n  if (isOutsideViewPort(appState, canvas, [x1, y1, x2, y2])) {\n    [x1, y1, x2, y2] = getClosestElementBounds(\n      elements,\n      viewportCoordsToSceneCoords(\n        { clientX: appState.scrollX, clientY: appState.scrollY },\n        appState,\n      ),\n    );\n  }\n\n  const centerX = (x1 + x2) / 2;\n  const centerY = (y1 + y2) / 2;\n\n  return centerScrollOn({\n    scenePoint: { x: centerX, y: centerY },\n    viewportDimensions: { width: appState.width, height: appState.height },\n    zoom: appState.zoom,\n  });\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\n\nimport { getElementAbsoluteCoords } from \"../element\";\n\nexport const hasBackground = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"line\";\n\nexport const hasStrokeWidth = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"freedraw\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const hasStrokeStyle = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const canChangeSharpness = (type: string) =>\n  type === \"rectangle\" || type === \"arrow\" || type === \"line\";\n\nexport const hasText = (type: string) => type === \"text\";\n\nexport const canHaveArrowheads = (type: string) => type === \"arrow\";\n\nexport const getElementAtPosition = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n    if (element.isDeleted) {\n      continue;\n    }\n    if (isAtPositionFn(element)) {\n      hitElement = element;\n      break;\n    }\n  }\n\n  return hitElement;\n};\n\nexport const getElementsAtPosition = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  // The parameter elements comes ordered from lower z-index to higher.\n  // We want to preserve that order on the returned array.\n  return elements.filter(\n    (element) => !element.isDeleted && isAtPositionFn(element),\n  );\n};\n\nexport const getElementContainingPosition = (\n  elements: readonly ExcalidrawElement[],\n  x: number,\n  y: number,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  for (let index = elements.length - 1; index >= 0; --index) {\n    if (elements[index].isDeleted) {\n      continue;\n    }\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(elements[index]);\n    if (x1 < x && x < x2 && y1 < y && y < y2) {\n      hitElement = elements[index];\n      break;\n    }\n  }\n  return hitElement;\n};\n","import { NormalizedZoomValue, PointerCoords, Zoom } from \"../types\";\n\nexport const getNewZoom = (\n  newZoomValue: NormalizedZoomValue,\n  prevZoom: Zoom,\n  canvasOffset: { left: number; top: number },\n  zoomOnViewportPoint: PointerCoords = { x: 0, y: 0 },\n): Zoom => {\n  return {\n    value: newZoomValue,\n    translation: {\n      x:\n        zoomOnViewportPoint.x -\n        canvasOffset.left -\n        (zoomOnViewportPoint.x - canvasOffset.left - prevZoom.translation.x) *\n          (newZoomValue / prevZoom.value),\n      y:\n        zoomOnViewportPoint.y -\n        canvasOffset.top -\n        (zoomOnViewportPoint.y - canvasOffset.top - prevZoom.translation.y) *\n          (newZoomValue / prevZoom.value),\n    },\n  };\n};\n\nexport const getNormalizedZoom = (zoom: number): NormalizedZoomValue => {\n  const normalizedZoom = parseFloat(zoom.toFixed(2));\n  const clampedZoom = Math.max(0.1, Math.min(normalizedZoom, 10));\n  return clampedZoom as NormalizedZoomValue;\n};\n","import \"./ToolIcon.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\nimport { useExcalidrawContainer } from \"./App\";\n\ntype ToolIconSize = \"s\" | \"m\";\n\ntype ToolButtonBaseProps = {\n  icon?: React.ReactNode;\n  \"aria-label\": string;\n  \"aria-keyshortcuts\"?: string;\n  \"data-testid\"?: string;\n  label?: string;\n  title?: string;\n  name?: string;\n  id?: string;\n  size?: ToolIconSize;\n  keyBindingLabel?: string;\n  showAriaLabel?: boolean;\n  hidden?: boolean;\n  visible?: boolean;\n  selected?: boolean;\n  className?: string;\n};\n\ntype ToolButtonProps =\n  | (ToolButtonBaseProps & {\n      type: \"button\";\n      children?: React.ReactNode;\n      onClick?(): void;\n    })\n  | (ToolButtonBaseProps & {\n      type: \"icon\";\n      children?: React.ReactNode;\n      onClick?(): void;\n    })\n  | (ToolButtonBaseProps & {\n      type: \"radio\";\n      checked: boolean;\n      onChange?(): void;\n    });\n\nconst DEFAULT_SIZE: ToolIconSize = \"m\";\n\nexport const ToolButton = React.forwardRef((props: ToolButtonProps, ref) => {\n  const { id: excalId } = useExcalidrawContainer();\n  const innerRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => innerRef.current);\n  const sizeCn = `ToolIcon_size_${props.size || DEFAULT_SIZE}`;\n\n  if (props.type === \"button\" || props.type === \"icon\") {\n    return (\n      <button\n        className={clsx(\n          \"ToolIcon_type_button\",\n          sizeCn,\n          props.className,\n          props.visible && !props.hidden\n            ? \"ToolIcon_type_button--show\"\n            : \"ToolIcon_type_button--hide\",\n          {\n            ToolIcon: !props.hidden,\n            \"ToolIcon--selected\": props.selected,\n            \"ToolIcon--plain\": props.type === \"icon\",\n          },\n        )}\n        data-testid={props[\"data-testid\"]}\n        hidden={props.hidden}\n        title={props.title}\n        aria-label={props[\"aria-label\"]}\n        type=\"button\"\n        onClick={props.onClick}\n        ref={innerRef}\n      >\n        {(props.icon || props.label) && (\n          <div className=\"ToolIcon__icon\" aria-hidden=\"true\">\n            {props.icon || props.label}\n            {props.keyBindingLabel && (\n              <span className=\"ToolIcon__keybinding\">\n                {props.keyBindingLabel}\n              </span>\n            )}\n          </div>\n        )}\n        {props.showAriaLabel && (\n          <div className=\"ToolIcon__label\">{props[\"aria-label\"]}</div>\n        )}\n        {props.children}\n      </button>\n    );\n  }\n\n  return (\n    <label className={clsx(\"ToolIcon\", props.className)} title={props.title}>\n      <input\n        className={`ToolIcon_type_radio ${sizeCn}`}\n        type=\"radio\"\n        name={props.name}\n        aria-label={props[\"aria-label\"]}\n        aria-keyshortcuts={props[\"aria-keyshortcuts\"]}\n        data-testid={props[\"data-testid\"]}\n        id={`${excalId}-${props.id}`}\n        onChange={props.onChange}\n        checked={props.checked}\n        ref={innerRef}\n      />\n      <div className=\"ToolIcon__icon\">\n        {props.icon}\n        {props.keyBindingLabel && (\n          <span className=\"ToolIcon__keybinding\">{props.keyBindingLabel}</span>\n        )}\n      </div>\n    </label>\n  );\n});\n\nToolButton.defaultProps = {\n  visible: true,\n  className: \"\",\n};\n","//\n// All icons are imported from https://fontawesome.com/icons?d=gallery\n// Icons are under the license https://fontawesome.com/license\n//\n\n// Note: when adding new icons, review https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/RTL_Guidelines\n// to determine whether or not the icons should be mirrored in right-to-left languages.\n\nimport React from \"react\";\n\nimport oc from \"open-color\";\nimport clsx from \"clsx\";\n\nconst activeElementColor = (theme: \"light\" | \"dark\") =>\n  theme === \"light\" ? oc.orange[4] : oc.orange[9];\nconst iconFillColor = (theme: \"light\" | \"dark\") =>\n  theme === \"light\" ? oc.black : oc.gray[4];\nconst handlerColor = (theme: \"light\" | \"dark\") =>\n  theme === \"light\" ? oc.white : \"#1e1e1e\";\n\ntype Opts = {\n  width?: number;\n  height?: number;\n  mirror?: true;\n} & React.SVGProps<SVGSVGElement>;\n\nexport const createIcon = (\n  d: string | React.ReactNode,\n  opts: number | Opts = 512,\n) => {\n  const { width = 512, height = width, mirror, style } =\n    typeof opts === \"number\" ? ({ width: opts } as Opts) : opts;\n  return (\n    <svg\n      aria-hidden=\"true\"\n      focusable=\"false\"\n      role=\"img\"\n      viewBox={`0 0 ${width} ${height}`}\n      className={clsx({ \"rtl-mirror\": mirror })}\n      style={style}\n    >\n      {typeof d === \"string\" ? <path fill=\"currentColor\" d={d} /> : d}\n    </svg>\n  );\n};\n\nexport const checkIcon = createIcon(\n  <polyline fill=\"none\" stroke=\"currentColor\" points=\"20 6 9 17 4 12\" />,\n  {\n    width: 24,\n    height: 24,\n  },\n);\n\nexport const link = createIcon(\n  \"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\",\n  { mirror: true },\n);\n\nexport const save = createIcon(\n  \"M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z\",\n  { width: 448, height: 512 },\n);\n\nexport const saveAs = createIcon(\n  \"M252 54L203 8a28 27 0 00-20-8H28C12 0 0 12 0 27v195c0 15 12 26 28 26h204c15 0 28-11 28-26V73a28 27 0 00-8-19zM130 213c-21 0-37-16-37-36 0-19 16-35 37-35 20 0 37 16 37 35 0 20-17 36-37 36zm56-169v56c0 4-4 6-7 6H44c-4 0-7-2-7-6V42c0-4 3-7 7-7h133l4 2 3 2a7 7 0 012 5z M296 201l87 95-188 205-78 9c-10 1-19-8-18-20l9-84zm141-14l-41-44a31 31 0 00-46 0l-38 41 87 95 38-42c13-14 13-36 0-50z\",\n  { width: 448, height: 512 },\n);\n\nexport const load = createIcon(\n  \"M572.694 292.093L500.27 416.248A63.997 63.997 0 0 1 444.989 448H45.025c-18.523 0-30.064-20.093-20.731-36.093l72.424-124.155A64 64 0 0 1 152 256h399.964c18.523 0 30.064 20.093 20.73 36.093zM152 224h328v-48c0-26.51-21.49-48-48-48H272l-64-64H48C21.49 64 0 85.49 0 112v278.046l69.077-118.418C86.214 242.25 117.989 224 152 224z\",\n  { width: 576, height: 512, mirror: true },\n);\n\nexport const clipboard = createIcon(\n  \"M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 0 0-6-6H102a6 6 0 0 0-6 6v20a6 6 0 0 0 6 6h180a6 6 0 0 0 6-6z\",\n  { width: 384, height: 512 },\n);\n\nexport const trash = createIcon(\n  \"M32 464a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V128H32zm272-256a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zM432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z\",\n  { width: 448, height: 512 },\n);\n\nexport const palette = createIcon(\n  \"M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z\",\n);\n\nexport const exportFile = createIcon(\n  \"M384 121.9c0-6.3-2.5-12.4-7-16.9L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128zM571 308l-95.7-96.4c-10.1-10.1-27.4-3-27.4 11.3V288h-64v64h64v65.2c0 14.3 17.3 21.4 27.4 11.3L571 332c6.6-6.6 6.6-17.4 0-24zm-379 28v-32c0-8.8 7.2-16 16-16h176V160H248c-13.2 0-24-10.8-24-24V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V352H208c-8.8 0-16-7.2-16-16z\",\n  { width: 576, height: 512, mirror: true },\n);\n\nexport const exportImage = createIcon(\n  <>\n    <path d=\"M571 308l-95.7-96.4c-10.1-10.1-27.4-3-27.4 11.3V288h-64v64h64v65.2c0 14.3 17.3 21.4 27.4 11.3L571 332c6.6-6.6 6.6-17.4 0-24zm-187 44v-64 64z\" />\n    <path d=\"M384 121.941V128H256V0h6.059c6.362 0 12.471 2.53 16.97 7.029l97.941 97.941a24.01 24.01 0 017.03 16.971zM248 160c-13.2 0-24-10.8-24-24V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248zm-135.455 16c26.51 0 48 21.49 48 48s-21.49 48-48 48-48-21.49-48-48 21.491-48 48-48zm208 240h-256l.485-48.485L104.545 328c4.686-4.686 11.799-4.201 16.485.485L160.545 368 264.06 264.485c4.686-4.686 12.284-4.686 16.971 0L320.545 304v112z\" />\n  </>,\n  { width: 576, height: 512, mirror: true },\n);\n\nexport const exportToFileIcon = createIcon(\n  \"M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z\",\n  { width: 512, height: 512 },\n);\n\nexport const zoomIn = createIcon(\n  \"M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z\",\n  { width: 448, height: 512 },\n);\n\nexport const zoomOut = createIcon(\n  \"M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z\",\n  { width: 448, height: 512 },\n);\n\nexport const done = createIcon(\n  \"M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z\",\n);\n\nexport const menu = createIcon(\n  \"M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z\",\n);\n\nexport const undo = createIcon(\n  \"M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z\",\n  { mirror: true },\n);\n\nexport const redo = createIcon(\n  \"M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z\",\n  { mirror: true },\n);\n\nexport const questionCircle = createIcon(\n  \"M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z\",\n  { mirror: true },\n);\n\nexport const share = createIcon(\n  \"M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z\",\n  { width: 24, height: 24 },\n);\n\nexport const shareIOS = createIcon(\n  \"M16 5l-1.42 1.42-1.59-1.59V16h-1.98V4.83L9.42 6.42 8 5l4-4 4 4zm4 5v11c0 1.1-.9 2-2 2H6c-1.11 0-2-.9-2-2V10c0-1.11.89-2 2-2h3v2H6v11h12V10h-3V8h3c1.1 0 2 .89 2 2z\",\n  { width: 24, height: 24 },\n);\n\nexport const shareWindows = createIcon(\n  <>\n    <path\n      stroke=\"currentColor\"\n      fill=\"currentColor\"\n      d=\"M40 5.6v6.1l-4.1.7c-8.9 1.4-16.5 6.9-20.6 15C13 32 10.9 43 12.4 43c.4 0 2.4-1.3 4.4-3 5-3.9 12.1-7 18.2-7.7l5-.6v12.8l11.2-11.3L62.5 22 51.2 10.8 40-.5v6.1zm10.2 22.6L44 34.5v-6.8l-6.9.6c-3.9.3-9.8 1.7-13.2 3.1-3.5 1.4-6.5 2.4-6.7 2.2-.9-1 3-7.5 6.4-10.8C28 18.6 34.4 16 40.1 16c3.7 0 3.9-.1 3.9-3.2V9.5l6.2 6.3 6.3 6.2-6.3 6.2z\"\n    />\n    <path\n      stroke=\"currentColor\"\n      fill=\"currentColor\"\n      d=\"M0 36v20h48v-6.2c0-6 0-6.1-2-4.3-1.1 1-2 2.9-2 4.2V52H4V34c0-17.3-.1-18-2-18s-2 .7-2 20z\"\n    />\n  </>,\n  { width: 64, height: 64 },\n);\n\n// Icon imported form Storybook\n// Storybook is licensed under MIT https://github.com/storybookjs/storybook/blob/next/LICENSE\nexport const resetZoom = createIcon(\n  <path\n    stroke=\"currentColor\"\n    strokeWidth=\"40\"\n    fill=\"currentColor\"\n    d=\"M148 560a318 318 0 0 0 522 110 316 316 0 0 0 0-450 316 316 0 0 0-450 0c-11 11-21 22-30 34v4h47c25 0 46 21 46 46s-21 45-46 45H90c-13 0-25-6-33-14-9-9-14-20-14-33V156c0-25 20-45 45-45s45 20 45 45v32l1 1a401 401 0 0 1 623 509l212 212a42 42 0 0 1-59 59L698 757A401 401 0 0 1 65 570a42 42 0 0 1 83-10z\"\n  />,\n  { width: 1024 },\n);\n\nexport const BringForwardIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M22 9.556C22 8.696 21.303 8 20.444 8H16v8H8v4.444C8 21.304 8.697 22 9.556 22h10.888c.86 0 1.556-.697 1.556-1.556V9.556z\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M16 3.556C16 2.696 15.303 2 14.444 2H3.556C2.696 2 2 2.697 2 3.556v10.888C2 15.304 2.697 16 3.556 16h10.888c.86 0 1.556-.697 1.556-1.556V3.556z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const SendBackwardIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M16 3.556C16 2.696 15.303 2 14.444 2H3.556C2.696 2 2 2.697 2 3.556v10.888C2 15.304 2.697 16 3.556 16h10.888c.86 0 1.556-.697 1.556-1.556V3.556z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M22 9.556C22 8.696 21.303 8 20.444 8H9.556C8.696 8 8 8.697 8 9.556v10.888C8 21.304 8.697 22 9.556 22h10.888c.86 0 1.556-.697 1.556-1.556V9.556z\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const BringToFrontIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M13 21a1 1 0 001 1h7a1 1 0 001-1v-7a1 1 0 00-1-1h-3v5h-5v3zM11 3a1 1 0 00-1-1H3a1 1 0 00-1 1v7a1 1 0 001 1h3V6h5V3z\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M18 7.333C18 6.597 17.403 6 16.667 6H7.333C6.597 6 6 6.597 6 7.333v9.334C6 17.403 6.597 18 7.333 18h9.334c.736 0 1.333-.597 1.333-1.333V7.333z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const SendToBackIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M18 7.333C18 6.597 17.403 6 16.667 6H7.333C6.597 6 6 6.597 6 7.333v9.334C6 17.403 6.597 18 7.333 18h9.334c.736 0 1.333-.597 1.333-1.333V7.333z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M11 3a1 1 0 00-1-1H3a1 1 0 00-1 1v7a1 1 0 001 1h8V3zM22 14a1 1 0 00-1-1h-7a1 1 0 00-1 1v7a1 1 0 001 1h8v-8z\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\n//\n// Align action icons created from scratch to match those of z-index actions\n// Note: vertical align icons are flipped so the larger item is always the\n// first one the user sees. Horizontal align icons should not be flipped since\n// that would make them lie about their function.\n//\nexport const AlignTopIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 2,5 H 22\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"M 6,7 C 5.446,7 5,7.446 5,8 v 9.999992 c 0,0.554 0.446,1 1,1 h 3.0000001 c 0.554,0 0.9999999,-0.446 0.9999999,-1 V 8 C 10,7.446 9.5540001,7 9.0000001,7 Z m 9,0 c -0.554,0 -1,0.446 -1,1 v 5.999992 c 0,0.554 0.446,1 1,1 h 3 c 0.554,0 1,-0.446 1,-1 V 8 C 19,7.446 18.554,7 18,7 Z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const AlignBottomIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 2,19 H 22\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"m 6,16.999992 c -0.554,0 -1,-0.446 -1,-1 V 6 C 5,5.446 5.446,5 6,5 H 9.0000001 C 9.5540001,5 10,5.446 10,6 v 9.999992 c 0,0.554 -0.4459999,1 -0.9999999,1 z m 9,0 c -0.554,0 -1,-0.446 -1,-1 V 10 c 0,-0.554 0.446,-1 1,-1 h 3 c 0.554,0 1,0.446 1,1 v 5.999992 c 0,0.554 -0.446,1 -1,1 z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const AlignLeftIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 5,2 V 22\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"m 7.000004,5.999996 c 0,-0.554 0.446,-1 1,-1 h 9.999992 c 0.554,0 1,0.446 1,1 v 3.0000001 c 0,0.554 -0.446,0.9999999 -1,0.9999999 H 8.000004 c -0.554,0 -1,-0.4459999 -1,-0.9999999 z m 0,9 c 0,-0.554 0.446,-1 1,-1 h 5.999992 c 0.554,0 1,0.446 1,1 v 3 c 0,0.554 -0.446,1 -1,1 H 8.000004 c -0.554,0 -1,-0.446 -1,-1 z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const AlignRightIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 19,2 V 22\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"m 16.999996,5.999996 c 0,-0.554 -0.446,-1 -1,-1 H 6.000004 c -0.554,0 -1,0.446 -1,1 v 3.0000001 c 0,0.554 0.446,0.9999999 1,0.9999999 h 9.999992 c 0.554,0 1,-0.4459999 1,-0.9999999 z m 0,9 c 0,-0.554 -0.446,-1 -1,-1 h -5.999992 c -0.554,0 -1,0.446 -1,1 v 3 c 0,0.554 0.446,1 1,1 h 5.999992 c 0.554,0 1,-0.446 1,-1 z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const DistributeHorizontallyIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M19 5V19M5 5V19\"\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"M15 9C15.554 9 16 9.446 16 10V14C16 14.554 15.554 15 15 15H9C8.446 15 8 14.554 8 14V10C8 9.446 8.446 9 9 9H15Z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const DistributeVerticallyIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M5 5L19 5M5 19H19\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n          strokeLinecap=\"round\"\n        />\n        <path\n          d=\"M15 9C15.554 9 16 9.446 16 10V14C16 14.554 15.554 15 15 15H9C8.446 15 8 14.554 8 14V10C8 9.446 8.446 9 9 9H15Z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const CenterVerticallyIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"m 5.000004,16.999996 c 0,0.554 0.446,1 1,1 h 3 c 0.554,0 1,-0.446 1,-1 v -10 c 0,-0.554 -0.446,-1 -1,-1 h -3 c -0.554,0 -1,0.446 -1,1 z m 9,-2 c 0,0.554 0.446,1 1,1 h 3 c 0.554,0 1,-0.446 1,-1 v -6 c 0,-0.554 -0.446,-1 -1,-1 h -3 c -0.554,0 -1,0.446 -1,1 z\"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M 2,12 H 22\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n          strokeDasharray=\"1, 2.8\"\n          strokeLinecap=\"round\"\n        />\n      </>,\n      { width: 24, mirror: true },\n    ),\n);\n\nexport const CenterHorizontallyIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          d=\"M 7 5 C 6.446 5 6 5.446 6 6 L 6 9 C 6 9.554 6.446 10 7 10 L 17 10 C 17.554 10 18 9.554 18 9 L 18 6 C 18 5.446 17.554 5 17 5 L 7 5 z M 9 14 C 8.446 14 8 14.446 8 15 L 8 18 C 8 18.554 8.446 19 9 19 L 15 19 C 15.554 19 16 18.554 16 18 L 16 15 C 16 14.446 15.554 14 15 14 L 9 14 z \"\n          fill={activeElementColor(theme)}\n          stroke={activeElementColor(theme)}\n          strokeWidth=\"2\"\n        />\n        <path\n          d=\"M 12,2 V 22\"\n          fill={iconFillColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n          strokeDasharray=\"1, 2.8\"\n          strokeLinecap=\"round\"\n        />\n      </>,\n      { width: 24 },\n    ),\n);\n\nexport const users = createIcon(\n  \"M192 256c61.9 0 112-50.1 112-112S253.9 32 192 32 80 82.1 80 144s50.1 112 112 112zm76.8 32h-8.3c-20.8 10-43.9 16-68.5 16s-47.6-6-68.5-16h-8.3C51.6 288 0 339.6 0 403.2V432c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48v-28.8c0-63.6-51.6-115.2-115.2-115.2zM480 256c53 0 96-43 96-96s-43-96-96-96-96 43-96 96 43 96 96 96zm48 32h-3.8c-13.9 4.8-28.6 8-44.2 8s-30.3-3.2-44.2-8H432c-20.4 0-39.2 5.9-55.7 15.4 24.4 26.3 39.7 61.2 39.7 99.8v38.4c0 2.2-.5 4.3-.6 6.4H592c26.5 0 48-21.5 48-48 0-61.9-50.1-112-112-112z\",\n  { width: 640, height: 512, mirror: true },\n);\n\n// not mirrored because it's inspired by a playback control, which is always RTL\nexport const start = createIcon(\n  \"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z\",\n);\n\nexport const stop = createIcon(\n  \"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm96 328c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16h160c8.8 0 16 7.2 16 16v160z\",\n);\n\nexport const close = createIcon(\n  \"M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z\",\n  { width: 352, height: 512 },\n);\n\nexport const back = createIcon(\n  \"M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z\",\n  { width: 320, height: 512, style: { marginLeft: \"-0.2rem\" }, mirror: true },\n);\n\nexport const clone = createIcon(\n  \"M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z\",\n  { mirror: true },\n);\n\n// modified https://feathericons.com/?query=shield\nexport const shield = createIcon(\n  \"M11.553 22.894a.998.998 0 00.894 0s3.037-1.516 5.465-4.097C19.616 16.987 21 14.663 21 12V5a1 1 0 00-.649-.936l-8-3a.998.998 0 00-.702 0l-8 3A1 1 0 003 5v7c0 2.663 1.384 4.987 3.088 6.797 2.428 2.581 5.465 4.097 5.465 4.097zm-1.303-8.481l6.644-6.644a.856.856 0 111.212 1.212l-7.25 7.25a.856.856 0 01-1.212 0l-3.75-3.75a.856.856 0 111.212-1.212l3.144 3.144z\",\n  { width: 24 },\n);\n\nexport const file = createIcon(\n  \"M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm32-48h224V288l-23.5-23.5c-4.7-4.7-12.3-4.7-17 0L176 352l-39.5-39.5c-4.7-4.7-12.3-4.7-17 0L80 352v64zm48-240c-26.5 0-48 21.5-48 48s21.5 48 48 48 48-21.5 48-48-21.5-48-48-48z\",\n  { width: 384, height: 512 },\n);\n\nexport const GroupIcon = React.memo(({ theme }: { theme: \"light\" | \"dark\" }) =>\n  createIcon(\n    <>\n      <path d=\"M25 26H111V111H25\" fill={iconFillColor(theme)} />\n      <path\n        d=\"M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z\"\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <path d=\"M100 100H160V160H100\" fill={iconFillColor(theme)} />\n      <path\n        d=\"M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z\"\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <g\n        fill={handlerColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"6\"\n      >\n        <rect x=\"2.5\" y=\"2.5\" width=\"30\" height=\"30\" />\n        <rect x=\"2.5\" y=\"149.5\" width=\"30\" height=\"30\" />\n        <rect x=\"147.5\" y=\"149.5\" width=\"30\" height=\"30\" />\n        <rect x=\"147.5\" y=\"2.5\" width=\"30\" height=\"30\" />\n      </g>\n    </>,\n    { width: 182, height: 182, mirror: true },\n  ),\n);\n\nexport const UngroupIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path d=\"M25 26H111V111H25\" fill={iconFillColor(theme)} />\n        <path\n          d=\"M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z\"\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n        />\n        <path d=\"M100 100H160V160H100\" fill={iconFillColor(theme)} />\n        <path\n          d=\"M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z\"\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"2\"\n        />\n        <g\n          fill={handlerColor(theme)}\n          stroke={iconFillColor(theme)}\n          strokeWidth=\"6\"\n        >\n          <rect x=\"2.5\" y=\"2.5\" width=\"30\" height=\"30\" />\n          <rect x=\"78.5\" y=\"149.5\" width=\"30\" height=\"30\" />\n          <rect x=\"147.5\" y=\"149.5\" width=\"30\" height=\"30\" />\n          <rect x=\"147.5\" y=\"78.5\" width=\"30\" height=\"30\" />\n          <rect x=\"105.5\" y=\"2.5\" width=\"30\" height=\"30\" />\n          <rect x=\"2.5\" y=\"102.5\" width=\"30\" height=\"30\" />\n        </g>\n      </>,\n      { width: 182, height: 182, mirror: true },\n    ),\n);\n\nexport const FillHachureIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        fillRule=\"evenodd\"\n        clipRule=\"evenodd\"\n        d=\"M20.101 16H28.0934L36 8.95989V4H33.5779L20.101 16ZM30.5704 4L17.0935 16H9.10101L22.5779 4H30.5704ZM19.5704 4L6.09349 16H4V10.7475L11.5779 4H19.5704ZM8.57036 4H4V8.06952L8.57036 4ZM36 11.6378L31.101 16H36V11.6378ZM2 2V18H38V2H2Z\"\n        fill={iconFillColor(theme)}\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const FillCrossHatchIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <g fill={iconFillColor(theme)} fillRule=\"evenodd\" clipRule=\"evenodd\">\n        <path d=\"M20.101 16H28.0934L36 8.95989V4H33.5779L20.101 16ZM30.5704 4L17.0935 16H9.10101L22.5779 4H30.5704ZM19.5704 4L6.09349 16H4V10.7475L11.5779 4H19.5704ZM8.57036 4H4V8.06952L8.57036 4ZM36 11.6378L31.101 16H36V11.6378ZM2 2V18H38V2H2Z\" />\n        <path d=\"M14.0001 18L3.00006 4.00002L4.5727 2.76438L15.5727 16.7644L14.0001 18ZM25.0001 18L14.0001 4.00002L15.5727 2.76438L26.5727 16.7644L25.0001 18ZM36.0001 18L25.0001 4.00002L26.5727 2.76438L37.5727 16.7644L36.0001 18Z\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const FillSolidIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(<path d=\"M2 2H38V18H2V2Z\" fill={iconFillColor(theme)} />, {\n      width: 40,\n      height: 20,\n    }),\n);\n\nexport const StrokeWidthIcon = React.memo(\n  ({ theme, strokeWidth }: { theme: \"light\" | \"dark\"; strokeWidth: number }) =>\n    createIcon(\n      <path\n        d=\"M6 10H32\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={strokeWidth}\n        strokeLinecap=\"round\"\n        fill=\"none\"\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const StrokeStyleSolidIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={2}\n        fill=\"none\"\n        strokeLinecap=\"round\"\n      />,\n      {\n        width: 40,\n        height: 20,\n      },\n    ),\n);\n\nexport const StrokeStyleDashedIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={2.5}\n        strokeDasharray={\"10, 8\"}\n        fill=\"none\"\n        strokeLinecap=\"round\"\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const StrokeStyleDottedIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M6 10H36\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={2.5}\n        strokeDasharray={\"2, 4.5\"}\n        fill=\"none\"\n        strokeLinecap=\"round\"\n      />,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const SloppinessArchitectIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M3.00098 16.1691C6.28774 13.9744 19.6399 2.8905 22.7215 3.00082C25.8041 3.11113 19.1158 15.5488 21.4962 16.8309C23.8757 18.1131 34.4155 11.7148 37.0001 10.6919\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={2}\n        strokeLinecap=\"round\"\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const SloppinessArtistIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M3 17C6.68158 14.8752 16.1296 9.09849 22.0648 6.54922C28 3.99995 22.2896 13.3209 25 14C27.7104 14.6791 36.3757 9.6471 36.3757 9.6471M6.40706 15C13 11.1918 20.0468 1.51045 23.0234 3.0052C26 4.49995 20.457 12.8659 22.7285 16.4329C25 20 36.3757 13 36.3757 13\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={2}\n        strokeLinecap=\"round\"\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const SloppinessCartoonistIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M3 15.6468C6.93692 13.5378 22.5544 2.81528 26.6206 3.00242C30.6877 3.18956 25.6708 15.3346 27.4009 16.7705C29.1309 18.2055 35.4001 12.4762 37 11.6177M3.97143 10.4917C6.61158 9.24563 16.3706 2.61886 19.8104 3.01724C23.2522 3.41472 22.0773 12.2013 24.6181 12.8783C27.1598 13.5536 33.3179 8.04068 35.0571 7.07244\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={2}\n        strokeLinecap=\"round\"\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const EdgeSharpIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M10 17L10 5L35 5\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={2}\n        strokeLinecap=\"round\"\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const EdgeRoundIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M10 17V15C10 8 13 5 21 5L33.5 5\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={2}\n        strokeLinecap=\"round\"\n        fill=\"none\"\n      />,\n      { width: 40, height: 20, mirror: true },\n    ),\n);\n\nexport const ArrowheadNoneIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M6 10H34\"\n        stroke={iconFillColor(theme)}\n        strokeWidth={2}\n        fill=\"none\"\n      />,\n      {\n        width: 40,\n        height: 20,\n      },\n    ),\n);\n\nexport const ArrowheadArrowIcon = React.memo(\n  ({ theme, flip = false }: { theme: \"light\" | \"dark\"; flip?: boolean }) =>\n    createIcon(\n      <g\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n        stroke={iconFillColor(theme)}\n        strokeWidth={2}\n        fill=\"none\"\n      >\n        <path d=\"M34 10H6M34 10L27 5M34 10L27 15\" />\n        <path d=\"M27.5 5L34.5 10L27.5 15\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadDotIcon = React.memo(\n  ({ theme, flip = false }: { theme: \"light\" | \"dark\"; flip?: boolean }) =>\n    createIcon(\n      <g\n        stroke={iconFillColor(theme)}\n        fill={iconFillColor(theme)}\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n      >\n        <path d=\"M32 10L6 10\" strokeWidth={2} />\n        <circle r=\"4\" transform=\"matrix(-1 0 0 1 30 10)\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadBarIcon = React.memo(\n  ({ theme, flip = false }: { theme: \"light\" | \"dark\"; flip?: boolean }) =>\n    createIcon(\n      <g transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}>\n        <path\n          d=\"M34 10H5.99996M34 10L34 5M34 10L34 15\"\n          stroke={iconFillColor(theme)}\n          strokeWidth={2}\n          fill=\"none\"\n        />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const FontSizeSmallIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        fill={iconFillColor(theme)}\n        d=\"M 0 69.092 L 0 55.03 A 124.24 124.24 0 0 0 4.706 57.02 Q 6.826 57.863 8.708 58.5 A 53.466 53.466 0 0 0 12.231 59.571 Q 17.236 60.889 21.387 60.889 A 20.909 20.909 0 0 0 24.265 60.704 Q 25.719 60.502 26.903 60.077 A 8.649 8.649 0 0 0 29.028 58.985 Q 31.689 57.08 31.689 53.321 Q 31.689 51.221 30.518 49.585 A 10.126 10.126 0 0 0 29.282 48.177 Q 28.352 47.287 27.075 46.436 A 23.719 23.719 0 0 0 25.752 45.627 Q 23.774 44.492 20.176 42.735 A 254.44 254.44 0 0 0 17.822 41.602 Q 11.503 38.631 8.236 35.888 A 19.742 19.742 0 0 1 8.008 35.694 A 22.18 22.18 0 0 1 2.783 29.102 Q 0.83 25.342 0.83 20.313 A 22.471 22.471 0 0 1 1.733 13.778 A 17.283 17.283 0 0 1 7.251 5.42 A 21.486 21.486 0 0 1 15.177 1.272 Q 18.361 0.338 22.166 0.09 A 43.573 43.573 0 0 1 25 0 A 42.399 42.399 0 0 1 34.349 1.01 A 39.075 39.075 0 0 1 35.62 1.319 A 67.407 67.407 0 0 1 42.108 3.382 A 83.357 83.357 0 0 1 46.191 5.03 L 41.309 16.797 Q 35.596 14.453 31.86 13.526 A 30.762 30.762 0 0 0 25.417 12.612 A 28.337 28.337 0 0 0 24.512 12.598 A 14.846 14.846 0 0 0 22.022 12.793 Q 19.498 13.224 17.92 14.6 Q 15.625 16.602 15.625 19.824 Q 15.625 21.826 16.553 23.316 Q 17.48 24.805 19.507 26.197 A 18.343 18.343 0 0 0 20.659 26.912 Q 22.596 28.035 26.516 29.953 A 299.99 299.99 0 0 0 29.102 31.201 Q 37.91 35.412 41.841 39.642 A 16.553 16.553 0 0 1 42.822 40.796 A 17.675 17.675 0 0 1 46.301 49.233 A 23.517 23.517 0 0 1 46.533 52.588 A 21.581 21.581 0 0 1 45.471 59.515 A 17.733 17.733 0 0 1 39.575 67.823 Q 33.745 72.486 24.094 73.243 A 49.683 49.683 0 0 1 20.215 73.389 A 51.712 51.712 0 0 1 9.448 72.315 A 40.672 40.672 0 0 1 0 69.092 Z\"\n      />,\n      { width: 47, height: 77 },\n    ),\n);\n\nexport const FontSizeMediumIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        fill={iconFillColor(theme)}\n        d=\"M 44.092 71.387 L 30.225 71.387 L 13.037 15.381 L 12.598 15.381 A 1505.093 1505.093 0 0 1 12.959 22.313 Q 13.426 31.715 13.508 36.4 A 102.991 102.991 0 0 1 13.525 38.184 L 13.525 71.387 L 0 71.387 L 0 0 L 20.605 0 L 37.5 54.59 L 37.793 54.59 L 55.713 0 L 76.318 0 L 76.318 71.387 L 62.207 71.387 L 62.207 37.598 Q 62.207 35.205 62.28 32.08 A 160.703 160.703 0 0 1 62.326 30.544 Q 62.452 26.754 62.866 17.168 A 5390.536 5390.536 0 0 1 62.939 15.479 L 62.5 15.479 L 44.092 71.387 Z\"\n      />,\n      { width: 77, height: 75 },\n    ),\n);\n\nexport const FontSizeLargeIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        fill={iconFillColor(theme)}\n        d=\"M 44.092 71.387 L 0 71.387 L 0 0 L 15.137 0 L 15.137 58.887 L 44.092 58.887 L 44.092 71.387 Z\"\n      />,\n      { width: 45, height: 75 },\n    ),\n);\n\nexport const FontSizeExtraLargeIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        fill={iconFillColor(theme)}\n        d=\"M 42.578 35.4 L 66.699 71.387 L 49.414 71.387 L 32.813 44.385 L 16.211 71.387 L 0 71.387 L 23.682 34.57 L 1.514 0 L 18.213 0 L 33.594 25.684 L 48.682 0 L 64.99 0 L 42.578 35.4 Z M 119.775 71.387 L 75.684 71.387 L 75.684 0 L 90.82 0 L 90.82 58.887 L 119.775 58.887 L 119.775 71.387 Z\"\n      />,\n      { width: 120, height: 75 },\n    ),\n);\n\nexport const FontFamilyHandDrawnIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        fill={iconFillColor(theme)}\n        d=\"M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z\"\n      />,\n      { width: 448, height: 512 },\n    ),\n);\n\nexport const FontFamilyNormalIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          fill={iconFillColor(theme)}\n          d=\"M 63.818 71.68 L 54.492 71.68 L 45.898 49.561 L 17.578 49.561 L 9.082 71.68 L 0 71.68 L 27.881 0 L 35.986 0 L 63.818 71.68 Z M 20.605 41.602 L 43.213 41.602 L 35.205 19.971 L 31.787 9.277 Q 30.322 15.137 28.711 19.971 L 20.605 41.602 Z\"\n        />\n        <path\n          fill={iconFillColor(theme)}\n          d=\"M 68.994 71.68 L 52.686 71.68 L 47.51 54.688 L 21.484 54.688 L 16.309 71.68 L 0 71.68 L 25.195 0 L 43.701 0 L 68.994 71.68 Z M 25.293 41.992 L 43.896 41.992 A 27590.463 27590.463 0 0 1 42.2 36.532 Q 36.965 19.676 35.937 16.273 A 120.932 120.932 0 0 1 35.815 15.869 A 131.65 131.65 0 0 1 35.396 14.435 Q 34.951 12.879 34.675 11.741 A 34.866 34.866 0 0 1 34.521 11.084 A 141.762 141.762 0 0 1 33.706 14.075 Q 31.482 21.957 25.293 41.992 Z\"\n        />\n      </>,\n      { width: 70, height: 78 },\n    ),\n);\n\nexport const FontFamilyCodeIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <>\n        <path\n          fill={iconFillColor(theme)}\n          d=\"M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2l43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6l144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z\"\n        />\n      </>,\n      { width: 640, height: 512 },\n    ),\n);\n\nexport const TextAlignLeftIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M12.83 352h262.34A12.82 12.82 0 00288 339.17v-38.34A12.82 12.82 0 00275.17 288H12.83A12.82 12.82 0 000 300.83v38.34A12.82 12.82 0 0012.83 352zm0-256h262.34A12.82 12.82 0 00288 83.17V44.83A12.82 12.82 0 00275.17 32H12.83A12.82 12.82 0 000 44.83v38.34A12.82 12.82 0 0012.83 96zM432 160H16a16 16 0 00-16 16v32a16 16 0 0016 16h416a16 16 0 0016-16v-32a16 16 0 00-16-16zm0 256H16a16 16 0 00-16 16v32a16 16 0 0016 16h416a16 16 0 0016-16v-32a16 16 0 00-16-16z\"\n        fill={iconFillColor(theme)}\n        strokeLinecap=\"round\"\n      />,\n      { width: 448, height: 512 },\n    ),\n);\n\nexport const TextAlignCenterIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M432 160H16a16 16 0 00-16 16v32a16 16 0 0016 16h416a16 16 0 0016-16v-32a16 16 0 00-16-16zm0 256H16a16 16 0 00-16 16v32a16 16 0 0016 16h416a16 16 0 0016-16v-32a16 16 0 00-16-16zM108.1 96h231.81A12.09 12.09 0 00352 83.9V44.09A12.09 12.09 0 00339.91 32H108.1A12.09 12.09 0 0096 44.09V83.9A12.1 12.1 0 00108.1 96zm231.81 256A12.09 12.09 0 00352 339.9v-39.81A12.09 12.09 0 00339.91 288H108.1A12.09 12.09 0 0096 300.09v39.81a12.1 12.1 0 0012.1 12.1z\"\n        fill={iconFillColor(theme)}\n      />,\n      { width: 448, height: 512 },\n    ),\n);\n\nexport const TextAlignRightIcon = React.memo(\n  ({ theme }: { theme: \"light\" | \"dark\" }) =>\n    createIcon(\n      <path\n        d=\"M16 224h416a16 16 0 0016-16v-32a16 16 0 00-16-16H16a16 16 0 00-16 16v32a16 16 0 0016 16zm416 192H16a16 16 0 00-16 16v32a16 16 0 0016 16h416a16 16 0 0016-16v-32a16 16 0 00-16-16zm3.17-384H172.83A12.82 12.82 0 00160 44.83v38.34A12.82 12.82 0 00172.83 96h262.34A12.82 12.82 0 00448 83.17V44.83A12.82 12.82 0 00435.17 32zm0 256H172.83A12.82 12.82 0 00160 300.83v38.34A12.82 12.82 0 00172.83 352h262.34A12.82 12.82 0 00448 339.17v-38.34A12.82 12.82 0 00435.17 288z\"\n        fill={iconFillColor(theme)}\n        strokeLinecap=\"round\"\n      />,\n      { width: 448, height: 512 },\n    ),\n);\n","import { Action } from \"./types\";\n\nexport let actions: readonly Action[] = [];\n\nexport const register = (action: Action): Action => {\n  actions = actions.concat(action);\n  return action;\n};\n","import { isSomeElementSelected } from \"../scene\";\nimport { KEYS } from \"../keys\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport React from \"react\";\nimport { trash } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getElementsInGroup } from \"../groups\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { fixBindingsAfterDeletion } from \"../element/binding\";\n\nconst deleteSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return {\n    elements: elements.map((el) => {\n      if (appState.selectedElementIds[el.id]) {\n        return newElementWith(el, { isDeleted: true });\n      }\n      return el;\n    }),\n    appState: {\n      ...appState,\n      selectedElementIds: {},\n    },\n  };\n};\n\nconst handleGroupEditingState = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n): AppState => {\n  if (appState.editingGroupId) {\n    const siblingElements = getElementsInGroup(\n      getNonDeletedElements(elements),\n      appState.editingGroupId!,\n    );\n    if (siblingElements.length) {\n      return {\n        ...appState,\n        selectedElementIds: { [siblingElements[0].id]: true },\n      };\n    }\n  }\n  return appState;\n};\n\nexport const actionDeleteSelected = register({\n  name: \"deleteSelectedElements\",\n  perform: (elements, appState) => {\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        activePointIndex,\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n      if (!element) {\n        return false;\n      }\n      if (\n        // case: no point selected → delete whole element\n        activePointIndex == null ||\n        activePointIndex === -1 ||\n        // case: deleting last remaining point\n        element.points.length < 2\n      ) {\n        const nextElements = elements.filter((el) => el.id !== element.id);\n        const nextAppState = handleGroupEditingState(appState, nextElements);\n\n        return {\n          elements: nextElements,\n          appState: {\n            ...nextAppState,\n            editingLinearElement: null,\n          },\n          commitToHistory: false,\n        };\n      }\n\n      // We cannot do this inside `movePoint` because it is also called\n      // when deleting the uncommitted point (which hasn't caused any binding)\n      const binding = {\n        startBindingElement:\n          activePointIndex === 0 ? null : startBindingElement,\n        endBindingElement:\n          activePointIndex === element.points.length - 1\n            ? null\n            : endBindingElement,\n      };\n\n      LinearElementEditor.movePoint(element, activePointIndex, \"delete\");\n\n      return {\n        elements,\n        appState: {\n          ...appState,\n          editingLinearElement: {\n            ...appState.editingLinearElement,\n            ...binding,\n            activePointIndex: activePointIndex > 0 ? activePointIndex - 1 : 0,\n          },\n        },\n        commitToHistory: true,\n      };\n    }\n\n    let {\n      elements: nextElements,\n      appState: nextAppState,\n    } = deleteSelectedElements(elements, appState);\n    fixBindingsAfterDeletion(\n      nextElements,\n      elements.filter(({ id }) => appState.selectedElementIds[id]),\n    );\n\n    nextAppState = handleGroupEditingState(nextAppState, nextElements);\n\n    return {\n      elements: nextElements,\n      appState: {\n        ...nextAppState,\n        elementType: \"selection\",\n        multiElement: null,\n      },\n      commitToHistory: isSomeElementSelected(\n        getNonDeletedElements(elements),\n        appState,\n      ),\n    };\n  },\n  contextItemLabel: \"labels.delete\",\n  keyTest: (event) => event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={trash}\n      title={t(\"labels.delete\")}\n      aria-label={t(\"labels.delete\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n","import { bumpVersion } from \"./element/mutateElement\";\nimport { ExcalidrawElement } from \"./element/types\";\nimport { getElementsInGroup } from \"./groups\";\nimport { AppState } from \"./types\";\nimport { findIndex, findLastIndex } from \"./utils\";\n\n/**\n * Returns indices of elements to move based on selected elements.\n * Includes contiguous deleted elements that are between two selected elements,\n *  e.g.: [0 (selected), 1 (deleted), 2 (deleted), 3 (selected)]\n */\nconst getIndicesToMove = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  let selectedIndices: number[] = [];\n  let deletedIndices: number[] = [];\n  let includeDeletedIndex = null;\n  let index = -1;\n  while (++index < elements.length) {\n    if (appState.selectedElementIds[elements[index].id]) {\n      if (deletedIndices.length) {\n        selectedIndices = selectedIndices.concat(deletedIndices);\n        deletedIndices = [];\n      }\n      selectedIndices.push(index);\n      includeDeletedIndex = index + 1;\n    } else if (elements[index].isDeleted && includeDeletedIndex === index) {\n      includeDeletedIndex = index + 1;\n      deletedIndices.push(index);\n    } else {\n      deletedIndices = [];\n    }\n  }\n  return selectedIndices;\n};\n\nconst toContiguousGroups = (array: number[]) => {\n  let cursor = 0;\n  return array.reduce((acc, value, index) => {\n    if (index > 0 && array[index - 1] !== value - 1) {\n      cursor = ++cursor;\n    }\n    (acc[cursor] || (acc[cursor] = [])).push(value);\n    return acc;\n  }, [] as number[][]);\n};\n\n/**\n * Returns next candidate index that's available to be moved to. Currently that\n *  is a non-deleted element, and not inside a group (unless we're editing it).\n */\nconst getTargetIndex = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n  boundaryIndex: number,\n  direction: \"left\" | \"right\",\n) => {\n  const sourceElement = elements[boundaryIndex];\n\n  const indexFilter = (element: ExcalidrawElement) => {\n    if (element.isDeleted) {\n      return false;\n    }\n    // if we're editing group, find closest sibling irrespective of whether\n    // there's a different-group element between them (for legacy reasons)\n    if (appState.editingGroupId) {\n      return element.groupIds.includes(appState.editingGroupId);\n    }\n    return true;\n  };\n\n  const candidateIndex =\n    direction === \"left\"\n      ? findLastIndex(elements, indexFilter, Math.max(0, boundaryIndex - 1))\n      : findIndex(elements, indexFilter, boundaryIndex + 1);\n\n  const nextElement = elements[candidateIndex];\n\n  if (!nextElement) {\n    return -1;\n  }\n\n  if (appState.editingGroupId) {\n    if (\n      // candidate element is a sibling in current editing group → return\n      sourceElement?.groupIds.join(\"\") === nextElement?.groupIds.join(\"\")\n    ) {\n      return candidateIndex;\n    } else if (!nextElement?.groupIds.includes(appState.editingGroupId)) {\n      // candidate element is outside current editing group → prevent\n      return -1;\n    }\n  }\n\n  if (!nextElement.groupIds.length) {\n    return candidateIndex;\n  }\n\n  const siblingGroupId = appState.editingGroupId\n    ? nextElement.groupIds[\n        nextElement.groupIds.indexOf(appState.editingGroupId) - 1\n      ]\n    : nextElement.groupIds[nextElement.groupIds.length - 1];\n\n  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);\n\n  if (elementsInSiblingGroup.length) {\n    // assumes getElementsInGroup() returned elements are sorted\n    // by zIndex (ascending)\n    return direction === \"left\"\n      ? elements.indexOf(elementsInSiblingGroup[0])\n      : elements.indexOf(\n          elementsInSiblingGroup[elementsInSiblingGroup.length - 1],\n        );\n  }\n\n  return candidateIndex;\n};\n\nconst getTargetElementsMap = (\n  elements: readonly ExcalidrawElement[],\n  indices: number[],\n) => {\n  return indices.reduce((acc, index) => {\n    const element = elements[index];\n    acc[element.id] = element;\n    return acc;\n  }, {} as Record<string, ExcalidrawElement>);\n};\n\nconst shiftElements = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n  direction: \"left\" | \"right\",\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n  let groupedIndices = toContiguousGroups(indicesToMove);\n\n  if (direction === \"right\") {\n    groupedIndices = groupedIndices.reverse();\n  }\n\n  groupedIndices.forEach((indices, i) => {\n    const leadingIndex = indices[0];\n    const trailingIndex = indices[indices.length - 1];\n    const boundaryIndex = direction === \"left\" ? leadingIndex : trailingIndex;\n\n    const targetIndex = getTargetIndex(\n      appState,\n      elements,\n      boundaryIndex,\n      direction,\n    );\n\n    if (targetIndex === -1 || boundaryIndex === targetIndex) {\n      return;\n    }\n\n    const leadingElements =\n      direction === \"left\"\n        ? elements.slice(0, targetIndex)\n        : elements.slice(0, leadingIndex);\n    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);\n    const displacedElements =\n      direction === \"left\"\n        ? elements.slice(targetIndex, leadingIndex)\n        : elements.slice(trailingIndex + 1, targetIndex + 1);\n    const trailingElements =\n      direction === \"left\"\n        ? elements.slice(trailingIndex + 1)\n        : elements.slice(targetIndex + 1);\n\n    elements =\n      direction === \"left\"\n        ? [\n            ...leadingElements,\n            ...targetElements,\n            ...displacedElements,\n            ...trailingElements,\n          ]\n        : [\n            ...leadingElements,\n            ...displacedElements,\n            ...targetElements,\n            ...trailingElements,\n          ];\n  });\n\n  return elements.map((element) => {\n    if (targetElementsMap[element.id]) {\n      return bumpVersion(element);\n    }\n    return element;\n  });\n};\n\nconst shiftElementsToEnd = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n  const displacedElements: ExcalidrawElement[] = [];\n\n  let leadingIndex: number;\n  let trailingIndex: number;\n  if (direction === \"left\") {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      leadingIndex = elements.indexOf(groupElements[0]);\n    } else {\n      leadingIndex = 0;\n    }\n\n    trailingIndex = indicesToMove[indicesToMove.length - 1];\n  } else {\n    if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);\n    } else {\n      trailingIndex = elements.length - 1;\n    }\n\n    leadingIndex = indicesToMove[0];\n  }\n\n  for (let index = leadingIndex; index < trailingIndex + 1; index++) {\n    if (!indicesToMove.includes(index)) {\n      displacedElements.push(elements[index]);\n    }\n  }\n\n  const targetElements = Object.values(targetElementsMap).map((element) => {\n    return bumpVersion(element);\n  });\n\n  const leadingElements = elements.slice(0, leadingIndex);\n  const trailingElements = elements.slice(trailingIndex + 1);\n\n  return direction === \"left\"\n    ? [\n        ...leadingElements,\n        ...targetElements,\n        ...displacedElements,\n        ...trailingElements,\n      ]\n    : [\n        ...leadingElements,\n        ...displacedElements,\n        ...targetElements,\n        ...trailingElements,\n      ];\n};\n\n// public API\n// -----------------------------------------------------------------------------\n\nexport const moveOneLeft = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElements(appState, elements, \"left\");\n};\n\nexport const moveOneRight = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElements(appState, elements, \"right\");\n};\n\nexport const moveAllLeft = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElementsToEnd(elements, appState, \"left\");\n};\n\nexport const moveAllRight = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElementsToEnd(elements, appState, \"right\");\n};\n","import React from \"react\";\nimport {\n  moveOneLeft,\n  moveOneRight,\n  moveAllLeft,\n  moveAllRight,\n} from \"../zindex\";\nimport { KEYS, isDarwin, CODES } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\nimport {\n  SendBackwardIcon,\n  BringToFrontIcon,\n  SendToBackIcon,\n  BringForwardIcon,\n} from \"../components/icons\";\n\nexport const actionSendBackward = register({\n  name: \"sendBackward\",\n  perform: (elements, appState) => {\n    return {\n      elements: moveOneLeft(elements, appState),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.sendBackward\",\n  keyPriority: 40,\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] &&\n    !event.shiftKey &&\n    event.code === CODES.BRACKET_LEFT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.sendBackward\")} — ${getShortcutKey(\"CtrlOrCmd+[\")}`}\n    >\n      <SendBackwardIcon theme={appState.theme} />\n    </button>\n  ),\n});\n\nexport const actionBringForward = register({\n  name: \"bringForward\",\n  perform: (elements, appState) => {\n    return {\n      elements: moveOneRight(elements, appState),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.bringForward\",\n  keyPriority: 40,\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] &&\n    !event.shiftKey &&\n    event.code === CODES.BRACKET_RIGHT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.bringForward\")} — ${getShortcutKey(\"CtrlOrCmd+]\")}`}\n    >\n      <BringForwardIcon theme={appState.theme} />\n    </button>\n  ),\n});\n\nexport const actionSendToBack = register({\n  name: \"sendToBack\",\n  perform: (elements, appState) => {\n    return {\n      elements: moveAllLeft(elements, appState),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.sendToBack\",\n  keyTest: (event) =>\n    isDarwin\n      ? event[KEYS.CTRL_OR_CMD] &&\n        event.altKey &&\n        event.code === CODES.BRACKET_LEFT\n      : event[KEYS.CTRL_OR_CMD] &&\n        event.shiftKey &&\n        event.code === CODES.BRACKET_LEFT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.sendToBack\")} — ${\n        isDarwin\n          ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n          : getShortcutKey(\"CtrlOrCmd+Shift+[\")\n      }`}\n    >\n      <SendToBackIcon theme={appState.theme} />\n    </button>\n  ),\n});\n\nexport const actionBringToFront = register({\n  name: \"bringToFront\",\n  perform: (elements, appState) => {\n    return {\n      elements: moveAllRight(elements, appState),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.bringToFront\",\n  keyTest: (event) =>\n    isDarwin\n      ? event[KEYS.CTRL_OR_CMD] &&\n        event.altKey &&\n        event.code === CODES.BRACKET_RIGHT\n      : event[KEYS.CTRL_OR_CMD] &&\n        event.shiftKey &&\n        event.code === CODES.BRACKET_RIGHT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={(event) => updateData(null)}\n      title={`${t(\"labels.bringToFront\")} — ${\n        isDarwin\n          ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n          : getShortcutKey(\"CtrlOrCmd+Shift+]\")\n      }`}\n    >\n      <BringToFrontIcon theme={appState.theme} />\n    </button>\n  ),\n});\n","import { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { selectGroupsForSelectedElements } from \"../groups\";\nimport { getNonDeletedElements } from \"../element\";\n\nexport const actionSelectAll = register({\n  name: \"selectAll\",\n  perform: (elements, appState) => {\n    if (appState.editingLinearElement) {\n      return false;\n    }\n    return {\n      appState: selectGroupsForSelectedElements(\n        {\n          ...appState,\n          editingGroupId: null,\n          selectedElementIds: elements.reduce((map, element) => {\n            if (!element.isDeleted) {\n              map[element.id] = true;\n            }\n            return map;\n          }, {} as any),\n        },\n        getNonDeletedElements(elements),\n      ),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.selectAll\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.A,\n});\n","import React from \"react\";\nimport { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { duplicateElement, getNonDeletedElements } from \"../element\";\nimport { isSomeElementSelected } from \"../scene\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { clone } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport {\n  selectGroupsForSelectedElements,\n  getSelectedGroupForElement,\n  getElementsInGroup,\n} from \"../groups\";\nimport { AppState } from \"../types\";\nimport { fixBindingsAfterDuplication } from \"../element/binding\";\nimport { ActionResult } from \"./types\";\nimport { GRID_SIZE } from \"../constants\";\n\nexport const actionDuplicateSelection = register({\n  name: \"duplicateSelection\",\n  perform: (elements, appState) => {\n    // duplicate point if selected while editing multi-point element\n    if (appState.editingLinearElement) {\n      const { activePointIndex, elementId } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n      if (!element || activePointIndex === null) {\n        return false;\n      }\n      const { points } = element;\n      const selectedPoint = points[activePointIndex];\n      const nextPoint = points[activePointIndex + 1];\n      mutateElement(element, {\n        points: [\n          ...points.slice(0, activePointIndex + 1),\n          nextPoint\n            ? [\n                (selectedPoint[0] + nextPoint[0]) / 2,\n                (selectedPoint[1] + nextPoint[1]) / 2,\n              ]\n            : [selectedPoint[0] + 30, selectedPoint[1] + 30],\n          ...points.slice(activePointIndex + 1),\n        ],\n      });\n      return {\n        appState: {\n          ...appState,\n          editingLinearElement: {\n            ...appState.editingLinearElement,\n            activePointIndex: activePointIndex + 1,\n          },\n        },\n        elements,\n        commitToHistory: true,\n      };\n    }\n\n    return {\n      ...duplicateElements(elements, appState),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.duplicateSelection\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={clone}\n      title={`${t(\"labels.duplicateSelection\")} — ${getShortcutKey(\n        \"CtrlOrCmd+D\",\n      )}`}\n      aria-label={t(\"labels.duplicateSelection\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nconst duplicateElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n): Partial<ActionResult> => {\n  const groupIdMap = new Map();\n  const newElements: ExcalidrawElement[] = [];\n  const oldElements: ExcalidrawElement[] = [];\n  const oldIdToDuplicatedId = new Map();\n\n  const duplicateAndOffsetElement = (element: ExcalidrawElement) => {\n    const newElement = duplicateElement(\n      appState.editingGroupId,\n      groupIdMap,\n      element,\n      {\n        x: element.x + GRID_SIZE / 2,\n        y: element.y + GRID_SIZE / 2,\n      },\n    );\n    oldIdToDuplicatedId.set(element.id, newElement.id);\n    oldElements.push(element);\n    newElements.push(newElement);\n    return newElement;\n  };\n\n  const finalElements: ExcalidrawElement[] = [];\n\n  let index = 0;\n  while (index < elements.length) {\n    const element = elements[index];\n    if (appState.selectedElementIds[element.id]) {\n      if (element.groupIds.length) {\n        const groupId = getSelectedGroupForElement(appState, element);\n        // if group selected, duplicate it atomically\n        if (groupId) {\n          const groupElements = getElementsInGroup(elements, groupId);\n          finalElements.push(\n            ...groupElements,\n            ...groupElements.map((element) =>\n              duplicateAndOffsetElement(element),\n            ),\n          );\n          index = index + groupElements.length;\n          continue;\n        }\n      }\n      finalElements.push(element, duplicateAndOffsetElement(element));\n    } else {\n      finalElements.push(element);\n    }\n    index++;\n  }\n\n  fixBindingsAfterDuplication(finalElements, oldElements, oldIdToDuplicatedId);\n\n  return {\n    elements: finalElements,\n    appState: selectGroupsForSelectedElements(\n      {\n        ...appState,\n        selectedGroupIds: {},\n        selectedElementIds: newElements.reduce((acc, element) => {\n          acc[element.id] = true;\n          return acc;\n        }, {} as any),\n      },\n      getNonDeletedElements(finalElements),\n    ),\n  };\n};\n","import React from \"react\";\nimport clsx from \"clsx\";\n\n// TODO: It might be \"clever\" to add option.icon to the existing component <ButtonSelect />\nexport const ButtonIconSelect = <T extends Object>({\n  options,\n  value,\n  onChange,\n  group,\n}: {\n  options: { value: T; text: string; icon: JSX.Element }[];\n  value: T | null;\n  onChange: (value: T) => void;\n  group: string;\n}) => (\n  <div className=\"buttonList buttonListIcon\">\n    {options.map((option) => (\n      <label\n        key={option.text}\n        className={clsx({ active: value === option.value })}\n        title={option.text}\n      >\n        <input\n          type=\"radio\"\n          name={group}\n          onChange={() => onChange(option.value)}\n          checked={value === option.value}\n        />\n        {option.icon}\n      </label>\n    ))}\n  </div>\n);\n","import React, { useLayoutEffect, useRef, useEffect } from \"react\";\nimport \"./Popover.scss\";\nimport { unstable_batchedUpdates } from \"react-dom\";\n\ntype Props = {\n  top?: number;\n  left?: number;\n  children?: React.ReactNode;\n  onCloseRequest?(event: PointerEvent): void;\n  fitInViewport?: boolean;\n};\n\nexport const Popover = ({\n  children,\n  left,\n  top,\n  onCloseRequest,\n  fitInViewport = false,\n}: Props) => {\n  const popoverRef = useRef<HTMLDivElement>(null);\n\n  // ensure the popover doesn't overflow the viewport\n  useLayoutEffect(() => {\n    if (fitInViewport && popoverRef.current) {\n      const element = popoverRef.current;\n      const { x, y, width, height } = element.getBoundingClientRect();\n\n      const viewportWidth = window.innerWidth;\n      if (x + width > viewportWidth) {\n        element.style.left = `${viewportWidth - width}px`;\n      }\n      const viewportHeight = window.innerHeight;\n      if (y + height > viewportHeight) {\n        element.style.top = `${viewportHeight - height}px`;\n      }\n    }\n  }, [fitInViewport]);\n\n  useEffect(() => {\n    if (onCloseRequest) {\n      const handler = (event: PointerEvent) => {\n        if (!popoverRef.current?.contains(event.target as Node)) {\n          unstable_batchedUpdates(() => onCloseRequest(event));\n        }\n      };\n      document.addEventListener(\"pointerdown\", handler, false);\n      return () => document.removeEventListener(\"pointerdown\", handler, false);\n    }\n  }, [onCloseRequest]);\n\n  return (\n    <div className=\"popover\" style={{ top, left }} ref={popoverRef}>\n      {children}\n    </div>\n  );\n};\n","import React from \"react\";\nimport { Popover } from \"./Popover\";\n\nimport \"./ColorPicker.scss\";\nimport { isArrowKey, KEYS } from \"../keys\";\nimport { t, getLanguage } from \"../i18n\";\nimport { isWritableElement } from \"../utils\";\nimport colors from \"../colors\";\n\nconst isValidColor = (color: string) => {\n  const style = new Option().style;\n  style.color = color;\n  return !!style.color;\n};\n\nconst getColor = (color: string): string | null => {\n  if (color === \"transparent\") {\n    return color;\n  }\n\n  return isValidColor(color)\n    ? color\n    : isValidColor(`#${color}`)\n    ? `#${color}`\n    : null;\n};\n\n// This is a narrow reimplementation of the awesome react-color Twitter component\n// https://github.com/casesandberg/react-color/blob/master/src/components/twitter/Twitter.js\n\n// Unfortunately, we can't detect keyboard layout in the browser. So this will\n// only work well for QWERTY but not AZERTY or others...\nconst keyBindings = [\n  [\"1\", \"2\", \"3\", \"4\", \"5\"],\n  [\"q\", \"w\", \"e\", \"r\", \"t\"],\n  [\"a\", \"s\", \"d\", \"f\", \"g\"],\n].flat();\n\nconst Picker = ({\n  colors,\n  color,\n  onChange,\n  onClose,\n  label,\n  showInput = true,\n  type,\n}: {\n  colors: string[];\n  color: string | null;\n  onChange: (color: string) => void;\n  onClose: () => void;\n  label: string;\n  showInput: boolean;\n  type: \"canvasBackground\" | \"elementBackground\" | \"elementStroke\";\n}) => {\n  const firstItem = React.useRef<HTMLButtonElement>();\n  const activeItem = React.useRef<HTMLButtonElement>();\n  const gallery = React.useRef<HTMLDivElement>();\n  const colorInput = React.useRef<HTMLInputElement>();\n\n  React.useEffect(() => {\n    // After the component is first mounted focus on first input\n    if (activeItem.current) {\n      activeItem.current.focus();\n    } else if (colorInput.current) {\n      colorInput.current.focus();\n    } else if (gallery.current) {\n      gallery.current.focus();\n    }\n  }, []);\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    if (event.key === KEYS.TAB) {\n      const { activeElement } = document;\n      if (event.shiftKey) {\n        if (activeElement === firstItem.current) {\n          colorInput.current?.focus();\n          event.preventDefault();\n        }\n      } else if (activeElement === colorInput.current) {\n        firstItem.current?.focus();\n        event.preventDefault();\n      }\n    } else if (isArrowKey(event.key)) {\n      const { activeElement } = document;\n      const isRTL = getLanguage().rtl;\n      const index = Array.prototype.indexOf.call(\n        gallery!.current!.children,\n        activeElement,\n      );\n      if (index !== -1) {\n        const length = gallery!.current!.children.length - (showInput ? 1 : 0);\n        const nextIndex =\n          event.key === (isRTL ? KEYS.ARROW_LEFT : KEYS.ARROW_RIGHT)\n            ? (index + 1) % length\n            : event.key === (isRTL ? KEYS.ARROW_RIGHT : KEYS.ARROW_LEFT)\n            ? (length + index - 1) % length\n            : event.key === KEYS.ARROW_DOWN\n            ? (index + 5) % length\n            : event.key === KEYS.ARROW_UP\n            ? (length + index - 5) % length\n            : index;\n        (gallery!.current!.children![nextIndex] as any).focus();\n      }\n      event.preventDefault();\n    } else if (\n      keyBindings.includes(event.key.toLowerCase()) &&\n      !isWritableElement(event.target)\n    ) {\n      const index = keyBindings.indexOf(event.key.toLowerCase());\n      (gallery!.current!.children![index] as any).focus();\n      event.preventDefault();\n    } else if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {\n      event.preventDefault();\n      onClose();\n    }\n    event.nativeEvent.stopImmediatePropagation();\n    event.stopPropagation();\n  };\n\n  return (\n    <div\n      className={`color-picker color-picker-type-${type}`}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-label={t(\"labels.colorPicker\")}\n      onKeyDown={handleKeyDown}\n    >\n      <div className=\"color-picker-triangle color-picker-triangle-shadow\"></div>\n      <div className=\"color-picker-triangle\"></div>\n      <div\n        className=\"color-picker-content\"\n        ref={(el) => {\n          if (el) {\n            gallery.current = el;\n          }\n        }}\n        tabIndex={0}\n      >\n        {colors.map((_color, i) => (\n          <button\n            className=\"color-picker-swatch\"\n            onClick={(event) => {\n              (event.currentTarget as HTMLButtonElement).focus();\n              onChange(_color);\n            }}\n            title={`${_color} — ${keyBindings[i].toUpperCase()}`}\n            aria-label={_color}\n            aria-keyshortcuts={keyBindings[i]}\n            style={{ color: _color }}\n            key={_color}\n            ref={(el) => {\n              if (el && i === 0) {\n                firstItem.current = el;\n              }\n              if (el && _color === color) {\n                activeItem.current = el;\n              }\n            }}\n            onFocus={() => {\n              onChange(_color);\n            }}\n          >\n            {_color === \"transparent\" ? (\n              <div className=\"color-picker-transparent\"></div>\n            ) : undefined}\n            <span className=\"color-picker-keybinding\">{keyBindings[i]}</span>\n          </button>\n        ))}\n        {showInput && (\n          <ColorInput\n            color={color}\n            label={label}\n            onChange={(color) => {\n              onChange(color);\n            }}\n            ref={colorInput}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nconst ColorInput = React.forwardRef(\n  (\n    {\n      color,\n      onChange,\n      label,\n    }: {\n      color: string | null;\n      onChange: (color: string) => void;\n      label: string;\n    },\n    ref,\n  ) => {\n    const [innerValue, setInnerValue] = React.useState(color);\n    const inputRef = React.useRef(null);\n\n    React.useEffect(() => {\n      setInnerValue(color);\n    }, [color]);\n\n    React.useImperativeHandle(ref, () => inputRef.current);\n\n    const changeColor = React.useCallback(\n      (inputValue: string) => {\n        const value = inputValue.toLowerCase();\n        const color = getColor(value);\n        if (color) {\n          onChange(color);\n        }\n        setInnerValue(value);\n      },\n      [onChange],\n    );\n\n    return (\n      <label className=\"color-input-container\">\n        <div className=\"color-picker-hash\">#</div>\n        <input\n          spellCheck={false}\n          className=\"color-picker-input\"\n          aria-label={label}\n          onChange={(event) => changeColor(event.target.value)}\n          value={(innerValue || \"\").replace(/^#/, \"\")}\n          onBlur={() => setInnerValue(color)}\n          ref={inputRef}\n        />\n      </label>\n    );\n  },\n);\n\nexport const ColorPicker = ({\n  type,\n  color,\n  onChange,\n  label,\n  isActive,\n  setActive,\n}: {\n  type: \"canvasBackground\" | \"elementBackground\" | \"elementStroke\";\n  color: string | null;\n  onChange: (color: string) => void;\n  label: string;\n  isActive: boolean;\n  setActive: (active: boolean) => void;\n}) => {\n  const pickerButton = React.useRef<HTMLButtonElement>(null);\n\n  return (\n    <div>\n      <div className=\"color-picker-control-container\">\n        <button\n          className=\"color-picker-label-swatch\"\n          aria-label={label}\n          style={color ? { \"--swatch-color\": color } : undefined}\n          onClick={() => setActive(!isActive)}\n          ref={pickerButton}\n        />\n        <ColorInput\n          color={color}\n          label={label}\n          onChange={(color) => {\n            onChange(color);\n          }}\n        />\n      </div>\n      <React.Suspense fallback=\"\">\n        {isActive ? (\n          <Popover\n            onCloseRequest={(event) =>\n              event.target !== pickerButton.current && setActive(false)\n            }\n          >\n            <Picker\n              colors={colors[type]}\n              color={color || null}\n              onChange={(changedColor) => {\n                onChange(changedColor);\n              }}\n              onClose={() => {\n                setActive(false);\n                pickerButton.current?.focus();\n              }}\n              label={label}\n              showInput={false}\n              type={type}\n            />\n          </Popover>\n        ) : null}\n      </React.Suspense>\n    </div>\n  );\n};\n","import React from \"react\";\nimport { Popover } from \"./Popover\";\n\nimport \"./IconPicker.scss\";\nimport { isArrowKey, KEYS } from \"../keys\";\nimport { getLanguage } from \"../i18n\";\n\nfunction Picker<T>({\n  options,\n  value,\n  label,\n  onChange,\n  onClose,\n}: {\n  label: string;\n  value: T;\n  options: { value: T; text: string; icon: JSX.Element; keyBinding: string }[];\n  onChange: (value: T) => void;\n  onClose: () => void;\n}) {\n  const rFirstItem = React.useRef<HTMLButtonElement>();\n  const rActiveItem = React.useRef<HTMLButtonElement>();\n  const rGallery = React.useRef<HTMLDivElement>(null);\n\n  React.useEffect(() => {\n    // After the component is first mounted focus on first input\n    if (rActiveItem.current) {\n      rActiveItem.current.focus();\n    } else if (rGallery.current) {\n      rGallery.current.focus();\n    }\n  }, []);\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    const pressedOption = options.find(\n      (option) => option.keyBinding === event.key.toLowerCase(),\n    )!;\n\n    if (!(event.metaKey || event.altKey || event.ctrlKey) && pressedOption) {\n      // Keybinding navigation\n      const index = options.indexOf(pressedOption);\n      (rGallery!.current!.children![index] as any).focus();\n      event.preventDefault();\n    } else if (event.key === KEYS.TAB) {\n      // Tab navigation cycle through options. If the user tabs\n      // away from the picker, close the picker. We need to use\n      // a timeout here to let the stack clear before checking.\n      setTimeout(() => {\n        const active = rActiveItem.current;\n        const docActive = document.activeElement;\n        if (active !== docActive) {\n          onClose();\n        }\n      }, 0);\n    } else if (isArrowKey(event.key)) {\n      // Arrow navigation\n      const { activeElement } = document;\n      const isRTL = getLanguage().rtl;\n      const index = Array.prototype.indexOf.call(\n        rGallery!.current!.children,\n        activeElement,\n      );\n      if (index !== -1) {\n        const length = options.length;\n        let nextIndex = index;\n\n        switch (event.key) {\n          // Select the next option\n          case isRTL ? KEYS.ARROW_LEFT : KEYS.ARROW_RIGHT:\n          case KEYS.ARROW_DOWN: {\n            nextIndex = (index + 1) % length;\n            break;\n          }\n          // Select the previous option\n          case isRTL ? KEYS.ARROW_RIGHT : KEYS.ARROW_LEFT:\n          case KEYS.ARROW_UP: {\n            nextIndex = (length + index - 1) % length;\n            break;\n          }\n        }\n\n        (rGallery.current!.children![nextIndex] as any).focus();\n      }\n      event.preventDefault();\n    } else if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {\n      // Close on escape or enter\n      event.preventDefault();\n      onClose();\n    }\n    event.nativeEvent.stopImmediatePropagation();\n    event.stopPropagation();\n  };\n\n  return (\n    <div\n      className={`picker`}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-label={label}\n      onKeyDown={handleKeyDown}\n    >\n      <div className=\"picker-content\" ref={rGallery}>\n        {options.map((option, i) => (\n          <button\n            className=\"picker-option\"\n            onClick={(event) => {\n              (event.currentTarget as HTMLButtonElement).focus();\n              onChange(option.value);\n            }}\n            title={`${option.text} — ${option.keyBinding.toUpperCase()}`}\n            aria-label={option.text || \"none\"}\n            aria-keyshortcuts={option.keyBinding}\n            key={option.text}\n            ref={(el) => {\n              if (el && i === 0) {\n                rFirstItem.current = el;\n              }\n              if (el && option.value === value) {\n                rActiveItem.current = el;\n              }\n            }}\n            onFocus={() => {\n              onChange(option.value);\n            }}\n          >\n            {option.icon}\n            <span className=\"picker-keybinding\">{option.keyBinding}</span>\n          </button>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport function IconPicker<T>({\n  value,\n  label,\n  options,\n  onChange,\n  group = \"\",\n}: {\n  label: string;\n  value: T;\n  options: { value: T; text: string; icon: JSX.Element; keyBinding: string }[];\n  onChange: (value: T) => void;\n  group?: string;\n}) {\n  const [isActive, setActive] = React.useState(false);\n  const rPickerButton = React.useRef<any>(null);\n  const isRTL = getLanguage().rtl;\n\n  return (\n    <label className={\"picker-container\"}>\n      <button\n        name={group}\n        className={isActive ? \"active\" : \"\"}\n        aria-label={label}\n        onClick={() => setActive(!isActive)}\n        ref={rPickerButton}\n      >\n        {options.find((option) => option.value === value)?.icon}\n      </button>\n      <React.Suspense fallback=\"\">\n        {isActive ? (\n          <>\n            <Popover\n              onCloseRequest={(event) =>\n                event.target !== rPickerButton.current && setActive(false)\n              }\n              {...(isRTL ? { right: 5.5 } : { left: -5.5 })}\n            >\n              <Picker\n                options={options}\n                value={value}\n                label={label}\n                onChange={onChange}\n                onClose={() => {\n                  setActive(false);\n                  rPickerButton.current?.focus();\n                }}\n              />\n            </Popover>\n            <div className=\"picker-triangle\" />\n          </>\n        ) : null}\n      </React.Suspense>\n    </label>\n  );\n}\n","import React from \"react\";\nimport { AppState } from \"../../src/types\";\nimport { ButtonIconSelect } from \"../components/ButtonIconSelect\";\nimport { ColorPicker } from \"../components/ColorPicker\";\nimport { IconPicker } from \"../components/IconPicker\";\nimport {\n  ArrowheadArrowIcon,\n  ArrowheadBarIcon,\n  ArrowheadDotIcon,\n  ArrowheadNoneIcon,\n  EdgeRoundIcon,\n  EdgeSharpIcon,\n  FillCrossHatchIcon,\n  FillHachureIcon,\n  FillSolidIcon,\n  FontFamilyCodeIcon,\n  FontFamilyHandDrawnIcon,\n  FontFamilyNormalIcon,\n  FontSizeExtraLargeIcon,\n  FontSizeLargeIcon,\n  FontSizeMediumIcon,\n  FontSizeSmallIcon,\n  SloppinessArchitectIcon,\n  SloppinessArtistIcon,\n  SloppinessCartoonistIcon,\n  StrokeStyleDashedIcon,\n  StrokeStyleDottedIcon,\n  StrokeStyleSolidIcon,\n  StrokeWidthIcon,\n  TextAlignCenterIcon,\n  TextAlignLeftIcon,\n  TextAlignRightIcon,\n} from \"../components/icons\";\nimport {\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  FONT_FAMILY,\n} from \"../constants\";\nimport {\n  getNonDeletedElements,\n  isTextElement,\n  redrawTextBoundingBox,\n} from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { isLinearElement, isLinearElementType } from \"../element/typeChecks\";\nimport {\n  Arrowhead,\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  FontFamilyValues,\n  TextAlign,\n} from \"../element/types\";\nimport { getLanguage, t } from \"../i18n\";\nimport { randomInteger } from \"../random\";\nimport {\n  canChangeSharpness,\n  canHaveArrowheads,\n  getCommonAttributeOfSelectedElements,\n  getTargetElements,\n  isSomeElementSelected,\n} from \"../scene\";\nimport { register } from \"./register\";\n\nconst changeProperty = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  callback: (element: ExcalidrawElement) => ExcalidrawElement,\n) => {\n  return elements.map((element) => {\n    if (\n      appState.selectedElementIds[element.id] ||\n      element.id === appState.editingElement?.id\n    ) {\n      return callback(element);\n    }\n    return element;\n  });\n};\n\nconst getFormValue = function <T>(\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  getAttribute: (element: ExcalidrawElement) => T,\n  defaultValue?: T,\n): T | null {\n  const editingElement = appState.editingElement;\n  const nonDeletedElements = getNonDeletedElements(elements);\n  return (\n    (editingElement && getAttribute(editingElement)) ??\n    (isSomeElementSelected(nonDeletedElements, appState)\n      ? getCommonAttributeOfSelectedElements(\n          nonDeletedElements,\n          appState,\n          getAttribute,\n        )\n      : defaultValue) ??\n    null\n  );\n};\n\nexport const actionChangeStrokeColor = register({\n  name: \"changeStrokeColor\",\n  perform: (elements, appState, value) => {\n    return {\n      ...(value.currentItemStrokeColor && {\n        elements: changeProperty(elements, appState, (el) =>\n          newElementWith(el, {\n            strokeColor: value.currentItemStrokeColor,\n          }),\n        ),\n      }),\n      appState: {\n        ...appState,\n        ...value,\n      },\n      commitToHistory: !!value.currentItemStrokeColor,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <>\n      <h3 aria-hidden=\"true\">{t(\"labels.stroke\")}</h3>\n      <ColorPicker\n        type=\"elementStroke\"\n        label={t(\"labels.stroke\")}\n        color={getFormValue(\n          elements,\n          appState,\n          (element) => element.strokeColor,\n          appState.currentItemStrokeColor,\n        )}\n        onChange={(color) => updateData({ currentItemStrokeColor: color })}\n        isActive={appState.openPopup === \"strokeColorPicker\"}\n        setActive={(active) =>\n          updateData({ openPopup: active ? \"strokeColorPicker\" : null })\n        }\n      />\n    </>\n  ),\n});\n\nexport const actionChangeBackgroundColor = register({\n  name: \"changeBackgroundColor\",\n  perform: (elements, appState, value) => {\n    return {\n      ...(value.currentItemBackgroundColor && {\n        elements: changeProperty(elements, appState, (el) =>\n          newElementWith(el, {\n            backgroundColor: value.currentItemBackgroundColor,\n          }),\n        ),\n      }),\n      appState: {\n        ...appState,\n        ...value,\n      },\n      commitToHistory: !!value.currentItemBackgroundColor,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <>\n      <h3 aria-hidden=\"true\">{t(\"labels.background\")}</h3>\n      <ColorPicker\n        type=\"elementBackground\"\n        label={t(\"labels.background\")}\n        color={getFormValue(\n          elements,\n          appState,\n          (element) => element.backgroundColor,\n          appState.currentItemBackgroundColor,\n        )}\n        onChange={(color) => updateData({ currentItemBackgroundColor: color })}\n        isActive={appState.openPopup === \"backgroundColorPicker\"}\n        setActive={(active) =>\n          updateData({ openPopup: active ? \"backgroundColorPicker\" : null })\n        }\n      />\n    </>\n  ),\n});\n\nexport const actionChangeFillStyle = register({\n  name: \"changeFillStyle\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          fillStyle: value,\n        }),\n      ),\n      appState: { ...appState, currentItemFillStyle: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.fill\")}</legend>\n      <ButtonIconSelect\n        options={[\n          {\n            value: \"hachure\",\n            text: t(\"labels.hachure\"),\n            icon: <FillHachureIcon theme={appState.theme} />,\n          },\n          {\n            value: \"cross-hatch\",\n            text: t(\"labels.crossHatch\"),\n            icon: <FillCrossHatchIcon theme={appState.theme} />,\n          },\n          {\n            value: \"solid\",\n            text: t(\"labels.solid\"),\n            icon: <FillSolidIcon theme={appState.theme} />,\n          },\n        ]}\n        group=\"fill\"\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.fillStyle,\n          appState.currentItemFillStyle,\n        )}\n        onChange={(value) => {\n          updateData(value);\n        }}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeStrokeWidth = register({\n  name: \"changeStrokeWidth\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          strokeWidth: value,\n        }),\n      ),\n      appState: { ...appState, currentItemStrokeWidth: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.strokeWidth\")}</legend>\n      <ButtonIconSelect\n        group=\"stroke-width\"\n        options={[\n          {\n            value: 1,\n            text: t(\"labels.thin\"),\n            icon: <StrokeWidthIcon theme={appState.theme} strokeWidth={2} />,\n          },\n          {\n            value: 2,\n            text: t(\"labels.bold\"),\n            icon: <StrokeWidthIcon theme={appState.theme} strokeWidth={6} />,\n          },\n          {\n            value: 4,\n            text: t(\"labels.extraBold\"),\n            icon: <StrokeWidthIcon theme={appState.theme} strokeWidth={10} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.strokeWidth,\n          appState.currentItemStrokeWidth,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeSloppiness = register({\n  name: \"changeSloppiness\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          seed: randomInteger(),\n          roughness: value,\n        }),\n      ),\n      appState: { ...appState, currentItemRoughness: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.sloppiness\")}</legend>\n      <ButtonIconSelect\n        group=\"sloppiness\"\n        options={[\n          {\n            value: 0,\n            text: t(\"labels.architect\"),\n            icon: <SloppinessArchitectIcon theme={appState.theme} />,\n          },\n          {\n            value: 1,\n            text: t(\"labels.artist\"),\n            icon: <SloppinessArtistIcon theme={appState.theme} />,\n          },\n          {\n            value: 2,\n            text: t(\"labels.cartoonist\"),\n            icon: <SloppinessCartoonistIcon theme={appState.theme} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.roughness,\n          appState.currentItemRoughness,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeStrokeStyle = register({\n  name: \"changeStrokeStyle\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          strokeStyle: value,\n        }),\n      ),\n      appState: { ...appState, currentItemStrokeStyle: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.strokeStyle\")}</legend>\n      <ButtonIconSelect\n        group=\"strokeStyle\"\n        options={[\n          {\n            value: \"solid\",\n            text: t(\"labels.strokeStyle_solid\"),\n            icon: <StrokeStyleSolidIcon theme={appState.theme} />,\n          },\n          {\n            value: \"dashed\",\n            text: t(\"labels.strokeStyle_dashed\"),\n            icon: <StrokeStyleDashedIcon theme={appState.theme} />,\n          },\n          {\n            value: \"dotted\",\n            text: t(\"labels.strokeStyle_dotted\"),\n            icon: <StrokeStyleDottedIcon theme={appState.theme} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.strokeStyle,\n          appState.currentItemStrokeStyle,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeOpacity = register({\n  name: \"changeOpacity\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          opacity: value,\n        }),\n      ),\n      appState: { ...appState, currentItemOpacity: value },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <label className=\"control-label\">\n      {t(\"labels.opacity\")}\n      <input\n        type=\"range\"\n        min=\"0\"\n        max=\"100\"\n        step=\"10\"\n        onChange={(event) => updateData(+event.target.value)}\n        onWheel={(event) => {\n          event.stopPropagation();\n          const target = event.target as HTMLInputElement;\n          const STEP = 10;\n          const MAX = 100;\n          const MIN = 0;\n          const value = +target.value;\n\n          if (event.deltaY < 0 && value < MAX) {\n            updateData(value + STEP);\n          } else if (event.deltaY > 0 && value > MIN) {\n            updateData(value - STEP);\n          }\n        }}\n        value={\n          getFormValue(\n            elements,\n            appState,\n            (element) => element.opacity,\n            appState.currentItemOpacity,\n          ) ?? undefined\n        }\n      />\n    </label>\n  ),\n});\n\nexport const actionChangeFontSize = register({\n  name: \"changeFontSize\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isTextElement(el)) {\n          const element: ExcalidrawTextElement = newElementWith(el, {\n            fontSize: value,\n          });\n          redrawTextBoundingBox(element);\n          return element;\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        currentItemFontSize: value,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.fontSize\")}</legend>\n      <ButtonIconSelect\n        group=\"font-size\"\n        options={[\n          {\n            value: 16,\n            text: t(\"labels.small\"),\n            icon: <FontSizeSmallIcon theme={appState.theme} />,\n          },\n          {\n            value: 20,\n            text: t(\"labels.medium\"),\n            icon: <FontSizeMediumIcon theme={appState.theme} />,\n          },\n          {\n            value: 28,\n            text: t(\"labels.large\"),\n            icon: <FontSizeLargeIcon theme={appState.theme} />,\n          },\n          {\n            value: 36,\n            text: t(\"labels.veryLarge\"),\n            icon: <FontSizeExtraLargeIcon theme={appState.theme} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => isTextElement(element) && element.fontSize,\n          appState.currentItemFontSize || DEFAULT_FONT_SIZE,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeFontFamily = register({\n  name: \"changeFontFamily\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isTextElement(el)) {\n          const element: ExcalidrawTextElement = newElementWith(el, {\n            fontFamily: value,\n          });\n          redrawTextBoundingBox(element);\n          return element;\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        currentItemFontFamily: value,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => {\n    const options: {\n      value: FontFamilyValues;\n      text: string;\n      icon: JSX.Element;\n    }[] = [\n      {\n        value: FONT_FAMILY.Virgil,\n        text: t(\"labels.handDrawn\"),\n        icon: <FontFamilyHandDrawnIcon theme={appState.theme} />,\n      },\n      {\n        value: FONT_FAMILY.Helvetica,\n        text: t(\"labels.normal\"),\n        icon: <FontFamilyNormalIcon theme={appState.theme} />,\n      },\n      {\n        value: FONT_FAMILY.Cascadia,\n        text: t(\"labels.code\"),\n        icon: <FontFamilyCodeIcon theme={appState.theme} />,\n      },\n    ];\n\n    return (\n      <fieldset>\n        <legend>{t(\"labels.fontFamily\")}</legend>\n        <ButtonIconSelect<FontFamilyValues | false>\n          group=\"font-family\"\n          options={options}\n          value={getFormValue(\n            elements,\n            appState,\n            (element) => isTextElement(element) && element.fontFamily,\n            appState.currentItemFontFamily || DEFAULT_FONT_FAMILY,\n          )}\n          onChange={(value) => updateData(value)}\n        />\n      </fieldset>\n    );\n  },\n});\n\nexport const actionChangeTextAlign = register({\n  name: \"changeTextAlign\",\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isTextElement(el)) {\n          const element: ExcalidrawTextElement = newElementWith(el, {\n            textAlign: value,\n          });\n          redrawTextBoundingBox(element);\n          return element;\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        currentItemTextAlign: value,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.textAlign\")}</legend>\n      <ButtonIconSelect<TextAlign | false>\n        group=\"text-align\"\n        options={[\n          {\n            value: \"left\",\n            text: t(\"labels.left\"),\n            icon: <TextAlignLeftIcon theme={appState.theme} />,\n          },\n          {\n            value: \"center\",\n            text: t(\"labels.center\"),\n            icon: <TextAlignCenterIcon theme={appState.theme} />,\n          },\n          {\n            value: \"right\",\n            text: t(\"labels.right\"),\n            icon: <TextAlignRightIcon theme={appState.theme} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => isTextElement(element) && element.textAlign,\n          appState.currentItemTextAlign,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeSharpness = register({\n  name: \"changeSharpness\",\n  perform: (elements, appState, value) => {\n    const targetElements = getTargetElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    const shouldUpdateForNonLinearElements = targetElements.length\n      ? targetElements.every((el) => !isLinearElement(el))\n      : !isLinearElementType(appState.elementType);\n    const shouldUpdateForLinearElements = targetElements.length\n      ? targetElements.every(isLinearElement)\n      : isLinearElementType(appState.elementType);\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          strokeSharpness: value,\n        }),\n      ),\n      appState: {\n        ...appState,\n        currentItemStrokeSharpness: shouldUpdateForNonLinearElements\n          ? value\n          : appState.currentItemStrokeSharpness,\n        currentItemLinearStrokeSharpness: shouldUpdateForLinearElements\n          ? value\n          : appState.currentItemLinearStrokeSharpness,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <fieldset>\n      <legend>{t(\"labels.edges\")}</legend>\n      <ButtonIconSelect\n        group=\"edges\"\n        options={[\n          {\n            value: \"sharp\",\n            text: t(\"labels.sharp\"),\n            icon: <EdgeSharpIcon theme={appState.theme} />,\n          },\n          {\n            value: \"round\",\n            text: t(\"labels.round\"),\n            icon: <EdgeRoundIcon theme={appState.theme} />,\n          },\n        ]}\n        value={getFormValue(\n          elements,\n          appState,\n          (element) => element.strokeSharpness,\n          (canChangeSharpness(appState.elementType) &&\n            (isLinearElementType(appState.elementType)\n              ? appState.currentItemLinearStrokeSharpness\n              : appState.currentItemStrokeSharpness)) ||\n            null,\n        )}\n        onChange={(value) => updateData(value)}\n      />\n    </fieldset>\n  ),\n});\n\nexport const actionChangeArrowhead = register({\n  name: \"changeArrowhead\",\n  perform: (\n    elements,\n    appState,\n    value: { position: \"start\" | \"end\"; type: Arrowhead },\n  ) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isLinearElement(el)) {\n          const { position, type } = value;\n\n          if (position === \"start\") {\n            const element: ExcalidrawLinearElement = newElementWith(el, {\n              startArrowhead: type,\n            });\n            return element;\n          } else if (position === \"end\") {\n            const element: ExcalidrawLinearElement = newElementWith(el, {\n              endArrowhead: type,\n            });\n            return element;\n          }\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        [value.position === \"start\"\n          ? \"currentItemStartArrowhead\"\n          : \"currentItemEndArrowhead\"]: value.type,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => {\n    const isRTL = getLanguage().rtl;\n\n    return (\n      <fieldset>\n        <legend>{t(\"labels.arrowheads\")}</legend>\n        <div className=\"iconSelectList\">\n          <IconPicker\n            label=\"arrowhead_start\"\n            options={[\n              {\n                value: null,\n                text: t(\"labels.arrowhead_none\"),\n                icon: <ArrowheadNoneIcon theme={appState.theme} />,\n                keyBinding: \"q\",\n              },\n              {\n                value: \"arrow\",\n                text: t(\"labels.arrowhead_arrow\"),\n                icon: (\n                  <ArrowheadArrowIcon theme={appState.theme} flip={!isRTL} />\n                ),\n                keyBinding: \"w\",\n              },\n              {\n                value: \"bar\",\n                text: t(\"labels.arrowhead_bar\"),\n                icon: <ArrowheadBarIcon theme={appState.theme} flip={!isRTL} />,\n                keyBinding: \"e\",\n              },\n              {\n                value: \"dot\",\n                text: t(\"labels.arrowhead_dot\"),\n                icon: <ArrowheadDotIcon theme={appState.theme} flip={!isRTL} />,\n                keyBinding: \"r\",\n              },\n            ]}\n            value={getFormValue<Arrowhead | null>(\n              elements,\n              appState,\n              (element) =>\n                isLinearElement(element) && canHaveArrowheads(element.type)\n                  ? element.startArrowhead\n                  : appState.currentItemStartArrowhead,\n              appState.currentItemStartArrowhead,\n            )}\n            onChange={(value) => updateData({ position: \"start\", type: value })}\n          />\n          <IconPicker\n            label=\"arrowhead_end\"\n            group=\"arrowheads\"\n            options={[\n              {\n                value: null,\n                text: t(\"labels.arrowhead_none\"),\n                keyBinding: \"q\",\n                icon: <ArrowheadNoneIcon theme={appState.theme} />,\n              },\n              {\n                value: \"arrow\",\n                text: t(\"labels.arrowhead_arrow\"),\n                keyBinding: \"w\",\n                icon: (\n                  <ArrowheadArrowIcon theme={appState.theme} flip={isRTL} />\n                ),\n              },\n              {\n                value: \"bar\",\n                text: t(\"labels.arrowhead_bar\"),\n                keyBinding: \"e\",\n                icon: <ArrowheadBarIcon theme={appState.theme} flip={isRTL} />,\n              },\n              {\n                value: \"dot\",\n                text: t(\"labels.arrowhead_dot\"),\n                keyBinding: \"r\",\n                icon: <ArrowheadDotIcon theme={appState.theme} flip={isRTL} />,\n              },\n            ]}\n            value={getFormValue<Arrowhead | null>(\n              elements,\n              appState,\n              (element) =>\n                isLinearElement(element) && canHaveArrowheads(element.type)\n                  ? element.endArrowhead\n                  : appState.currentItemEndArrowhead,\n              appState.currentItemEndArrowhead,\n            )}\n            onChange={(value) => updateData({ position: \"end\", type: value })}\n          />\n        </div>\n      </fieldset>\n    );\n  },\n});\n","import \"./ToolIcon.scss\";\n\nimport React from \"react\";\nimport { t } from \"../i18n\";\nimport { ToolButton } from \"./ToolButton\";\n\nexport type Appearence = \"light\" | \"dark\";\n\n// We chose to use only explicit toggle and not a third option for system value,\n// but this could be added in the future.\nexport const DarkModeToggle = (props: {\n  value: Appearence;\n  onChange: (value: Appearence) => void;\n  title?: string;\n}) => {\n  const title =\n    props.title ||\n    (props.value === \"dark\" ? t(\"buttons.lightMode\") : t(\"buttons.darkMode\"));\n\n  return (\n    <ToolButton\n      type=\"icon\"\n      icon={props.value === \"light\" ? ICONS.MOON : ICONS.SUN}\n      title={title}\n      aria-label={title}\n      onClick={() => props.onChange(props.value === \"dark\" ? \"light\" : \"dark\")}\n      data-testid=\"toggle-dark-mode\"\n    />\n  );\n};\n\nconst ICONS = {\n  SUN: (\n    <svg width=\"512\" height=\"512\" className=\"rtl-mirror\" viewBox=\"0 0 512 512\">\n      <path\n        fill=\"currentColor\"\n        d=\"M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z\"\n      ></path>\n    </svg>\n  ),\n  MOON: (\n    <svg width=\"512\" height=\"512\" className=\"rtl-mirror\" viewBox=\"0 0 512 512\">\n      <path\n        fill=\"currentColor\"\n        d=\"M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z\"\n      ></path>\n    </svg>\n  ),\n};\n","import React from \"react\";\nimport { getDefaultAppState } from \"../appState\";\nimport { ColorPicker } from \"../components/ColorPicker\";\nimport { resetZoom, trash, zoomIn, zoomOut } from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { DarkModeToggle } from \"../components/DarkModeToggle\";\nimport { ZOOM_STEP } from \"../constants\";\nimport { getCommonBounds, getNonDeletedElements } from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport { CODES, KEYS } from \"../keys\";\nimport { getNormalizedZoom, getSelectedElements } from \"../scene\";\nimport { centerScrollOn } from \"../scene/scroll\";\nimport { getNewZoom } from \"../scene/zoom\";\nimport { AppState, NormalizedZoomValue } from \"../types\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\n\nexport const actionChangeViewBackgroundColor = register({\n  name: \"changeViewBackgroundColor\",\n  perform: (_, appState, value) => {\n    return {\n      appState: { ...appState, ...value },\n      commitToHistory: !!value.viewBackgroundColor,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => {\n    return (\n      <div style={{ position: \"relative\" }}>\n        <ColorPicker\n          label={t(\"labels.canvasBackground\")}\n          type=\"canvasBackground\"\n          color={appState.viewBackgroundColor}\n          onChange={(color) => updateData({ viewBackgroundColor: color })}\n          isActive={appState.openPopup === \"canvasColorPicker\"}\n          setActive={(active) =>\n            updateData({ openPopup: active ? \"canvasColorPicker\" : null })\n          }\n          data-testid=\"canvas-background-picker\"\n        />\n      </div>\n    );\n  },\n});\n\nexport const actionClearCanvas = register({\n  name: \"clearCanvas\",\n  perform: (elements, appState: AppState) => {\n    return {\n      elements: elements.map((element) =>\n        newElementWith(element, { isDeleted: true }),\n      ),\n      appState: {\n        ...getDefaultAppState(),\n        theme: appState.theme,\n        elementLocked: appState.elementLocked,\n        exportBackground: appState.exportBackground,\n        exportEmbedScene: appState.exportEmbedScene,\n        gridSize: appState.gridSize,\n        showStats: appState.showStats,\n        pasteDialog: appState.pasteDialog,\n      },\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={trash}\n      title={t(\"buttons.clearReset\")}\n      aria-label={t(\"buttons.clearReset\")}\n      showAriaLabel={useIsMobile()}\n      onClick={() => {\n        if (window.confirm(t(\"alerts.clearReset\"))) {\n          updateData(null);\n        }\n      }}\n      data-testid=\"clear-canvas-button\"\n    />\n  ),\n});\n\nexport const actionZoomIn = register({\n  name: \"zoomIn\",\n  perform: (_elements, appState) => {\n    const zoom = getNewZoom(\n      getNormalizedZoom(appState.zoom.value + ZOOM_STEP),\n      appState.zoom,\n      { left: appState.offsetLeft, top: appState.offsetTop },\n      { x: appState.width / 2, y: appState.height / 2 },\n    );\n    return {\n      appState: {\n        ...appState,\n        zoom,\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={zoomIn}\n      title={`${t(\"buttons.zoomIn\")} — ${getShortcutKey(\"CtrlOrCmd++\")}`}\n      aria-label={t(\"buttons.zoomIn\")}\n      onClick={() => {\n        updateData(null);\n      }}\n    />\n  ),\n  keyTest: (event) =>\n    (event.code === CODES.EQUAL || event.code === CODES.NUM_ADD) &&\n    (event[KEYS.CTRL_OR_CMD] || event.shiftKey),\n});\n\nexport const actionZoomOut = register({\n  name: \"zoomOut\",\n  perform: (_elements, appState) => {\n    const zoom = getNewZoom(\n      getNormalizedZoom(appState.zoom.value - ZOOM_STEP),\n      appState.zoom,\n      { left: appState.offsetLeft, top: appState.offsetTop },\n      { x: appState.width / 2, y: appState.height / 2 },\n    );\n\n    return {\n      appState: {\n        ...appState,\n        zoom,\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={zoomOut}\n      title={`${t(\"buttons.zoomOut\")} — ${getShortcutKey(\"CtrlOrCmd+-\")}`}\n      aria-label={t(\"buttons.zoomOut\")}\n      onClick={() => {\n        updateData(null);\n      }}\n    />\n  ),\n  keyTest: (event) =>\n    (event.code === CODES.MINUS || event.code === CODES.NUM_SUBTRACT) &&\n    (event[KEYS.CTRL_OR_CMD] || event.shiftKey),\n});\n\nexport const actionResetZoom = register({\n  name: \"resetZoom\",\n  perform: (_elements, appState) => {\n    return {\n      appState: {\n        ...appState,\n        zoom: getNewZoom(\n          1 as NormalizedZoomValue,\n          appState.zoom,\n          { left: appState.offsetLeft, top: appState.offsetTop },\n          {\n            x: appState.width / 2,\n            y: appState.height / 2,\n          },\n        ),\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={resetZoom}\n      title={t(\"buttons.resetZoom\")}\n      aria-label={t(\"buttons.resetZoom\")}\n      onClick={() => {\n        updateData(null);\n      }}\n    />\n  ),\n  keyTest: (event) =>\n    (event.code === CODES.ZERO || event.code === CODES.NUM_ZERO) &&\n    (event[KEYS.CTRL_OR_CMD] || event.shiftKey),\n});\n\nconst zoomValueToFitBoundsOnViewport = (\n  bounds: [number, number, number, number],\n  viewportDimensions: { width: number; height: number },\n) => {\n  const [x1, y1, x2, y2] = bounds;\n  const commonBoundsWidth = x2 - x1;\n  const zoomValueForWidth = viewportDimensions.width / commonBoundsWidth;\n  const commonBoundsHeight = y2 - y1;\n  const zoomValueForHeight = viewportDimensions.height / commonBoundsHeight;\n  const smallestZoomValue = Math.min(zoomValueForWidth, zoomValueForHeight);\n  const zoomAdjustedToSteps =\n    Math.floor(smallestZoomValue / ZOOM_STEP) * ZOOM_STEP;\n  const clampedZoomValueToFitElements = Math.min(\n    Math.max(zoomAdjustedToSteps, ZOOM_STEP),\n    1,\n  );\n  return clampedZoomValueToFitElements as NormalizedZoomValue;\n};\n\nconst zoomToFitElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  zoomToSelection: boolean,\n) => {\n  const nonDeletedElements = getNonDeletedElements(elements);\n  const selectedElements = getSelectedElements(nonDeletedElements, appState);\n\n  const commonBounds =\n    zoomToSelection && selectedElements.length > 0\n      ? getCommonBounds(selectedElements)\n      : getCommonBounds(nonDeletedElements);\n\n  const zoomValue = zoomValueToFitBoundsOnViewport(commonBounds, {\n    width: appState.width,\n    height: appState.height,\n  });\n  const newZoom = getNewZoom(zoomValue, appState.zoom, {\n    left: appState.offsetLeft,\n    top: appState.offsetTop,\n  });\n\n  const [x1, y1, x2, y2] = commonBounds;\n  const centerX = (x1 + x2) / 2;\n  const centerY = (y1 + y2) / 2;\n  return {\n    appState: {\n      ...appState,\n      ...centerScrollOn({\n        scenePoint: { x: centerX, y: centerY },\n        viewportDimensions: {\n          width: appState.width,\n          height: appState.height,\n        },\n        zoom: newZoom,\n      }),\n      zoom: newZoom,\n    },\n    commitToHistory: false,\n  };\n};\n\nexport const actionZoomToSelected = register({\n  name: \"zoomToSelection\",\n  perform: (elements, appState) => zoomToFitElements(elements, appState, true),\n  keyTest: (event) =>\n    event.code === CODES.TWO &&\n    event.shiftKey &&\n    !event.altKey &&\n    !event[KEYS.CTRL_OR_CMD],\n});\n\nexport const actionZoomToFit = register({\n  name: \"zoomToFit\",\n  perform: (elements, appState) => zoomToFitElements(elements, appState, false),\n  keyTest: (event) =>\n    event.code === CODES.ONE &&\n    event.shiftKey &&\n    !event.altKey &&\n    !event[KEYS.CTRL_OR_CMD],\n});\n\nexport const actionToggleTheme = register({\n  name: \"toggleTheme\",\n  perform: (_, appState, value) => {\n    return {\n      appState: {\n        ...appState,\n        theme: value || (appState.theme === \"light\" ? \"dark\" : \"light\"),\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <div style={{ marginInlineStart: \"0.25rem\" }}>\n      <DarkModeToggle\n        value={appState.theme}\n        onChange={(theme) => {\n          updateData(theme);\n        }}\n      />\n    </div>\n  ),\n  keyTest: (event) => event.altKey && event.shiftKey && event.code === CODES.D,\n});\n","import { KEYS } from \"../keys\";\nimport { isInvisiblySmallElement } from \"../element\";\nimport { resetCursor } from \"../utils\";\nimport React from \"react\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { done } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { isPathALoop } from \"../math\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport Scene from \"../scene/Scene\";\nimport {\n  maybeBindLinearElement,\n  bindOrUnbindLinearElement,\n} from \"../element/binding\";\nimport { isBindingElement } from \"../element/typeChecks\";\n\nexport const actionFinalize = register({\n  name: \"finalize\",\n  perform: (elements, appState, _, { canvas, focusContainer }) => {\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId);\n\n      if (element) {\n        if (isBindingElement(element)) {\n          bindOrUnbindLinearElement(\n            element,\n            startBindingElement,\n            endBindingElement,\n          );\n        }\n        return {\n          elements:\n            element.points.length < 2 || isInvisiblySmallElement(element)\n              ? elements.filter((el) => el.id !== element.id)\n              : undefined,\n          appState: {\n            ...appState,\n            editingLinearElement: null,\n          },\n          commitToHistory: true,\n        };\n      }\n    }\n\n    let newElements = elements;\n    if (window.document.activeElement instanceof HTMLElement) {\n      focusContainer();\n    }\n\n    const multiPointElement = appState.multiElement\n      ? appState.multiElement\n      : appState.editingElement?.type === \"freedraw\"\n      ? appState.editingElement\n      : null;\n\n    if (multiPointElement) {\n      // pen and mouse have hover\n      if (\n        multiPointElement.type !== \"freedraw\" &&\n        appState.lastPointerDownWith !== \"touch\"\n      ) {\n        const { points, lastCommittedPoint } = multiPointElement;\n        if (\n          !lastCommittedPoint ||\n          points[points.length - 1] !== lastCommittedPoint\n        ) {\n          mutateElement(multiPointElement, {\n            points: multiPointElement.points.slice(0, -1),\n          });\n        }\n      }\n      if (isInvisiblySmallElement(multiPointElement)) {\n        newElements = newElements.slice(0, -1);\n      }\n\n      // If the multi point line closes the loop,\n      // set the last point to first point.\n      // This ensures that loop remains closed at different scales.\n      const isLoop = isPathALoop(multiPointElement.points, appState.zoom.value);\n      if (\n        multiPointElement.type === \"line\" ||\n        multiPointElement.type === \"freedraw\"\n      ) {\n        if (isLoop) {\n          const linePoints = multiPointElement.points;\n          const firstPoint = linePoints[0];\n          mutateElement(multiPointElement, {\n            points: linePoints.map((point, index) =>\n              index === linePoints.length - 1\n                ? ([firstPoint[0], firstPoint[1]] as const)\n                : point,\n            ),\n          });\n        }\n      }\n\n      if (\n        isBindingElement(multiPointElement) &&\n        !isLoop &&\n        multiPointElement.points.length > 1\n      ) {\n        const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n          multiPointElement,\n          -1,\n        );\n        maybeBindLinearElement(\n          multiPointElement,\n          appState,\n          Scene.getScene(multiPointElement)!,\n          { x, y },\n        );\n      }\n\n      if (!appState.elementLocked && appState.elementType !== \"freedraw\") {\n        appState.selectedElementIds[multiPointElement.id] = true;\n      }\n    }\n\n    if (\n      (!appState.elementLocked && appState.elementType !== \"freedraw\") ||\n      !multiPointElement\n    ) {\n      resetCursor(canvas);\n    }\n\n    return {\n      elements: newElements,\n      appState: {\n        ...appState,\n        elementType:\n          (appState.elementLocked || appState.elementType === \"freedraw\") &&\n          multiPointElement\n            ? appState.elementType\n            : \"selection\",\n        draggingElement: null,\n        multiElement: null,\n        editingElement: null,\n        startBoundElement: null,\n        suggestedBindings: [],\n        selectedElementIds:\n          multiPointElement &&\n          !appState.elementLocked &&\n          appState.elementType !== \"freedraw\"\n            ? {\n                ...appState.selectedElementIds,\n                [multiPointElement.id]: true,\n              }\n            : appState.selectedElementIds,\n      },\n      commitToHistory: appState.elementType === \"freedraw\",\n    };\n  },\n  keyTest: (event, appState) =>\n    (event.key === KEYS.ESCAPE &&\n      (appState.editingLinearElement !== null ||\n        (!appState.draggingElement && appState.multiElement === null))) ||\n    ((event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) &&\n      appState.multiElement !== null),\n  PanelComponent: ({ appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={done}\n      title={t(\"buttons.done\")}\n      aria-label={t(\"buttons.done\")}\n      onClick={updateData}\n      visible={appState.multiElement != null}\n    />\n  ),\n});\n","import \"./TextInput.scss\";\n\nimport React, { useState } from \"react\";\nimport { focusNearestParent } from \"../utils\";\n\nimport \"./ProjectName.scss\";\nimport { useExcalidrawContainer } from \"./App\";\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n  label: string;\n  isNameEditable: boolean;\n};\n\nexport const ProjectName = (props: Props) => {\n  const { id } = useExcalidrawContainer();\n  const [fileName, setFileName] = useState<string>(props.value);\n\n  const handleBlur = (event: any) => {\n    focusNearestParent(event.target);\n    const value = event.target.value;\n    if (value !== props.value) {\n      props.onChange(value);\n    }\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent<HTMLElement>) => {\n    if (event.key === \"Enter\") {\n      event.preventDefault();\n      if (event.nativeEvent.isComposing || event.keyCode === 229) {\n        return;\n      }\n      event.currentTarget.blur();\n    }\n  };\n\n  return (\n    <div className=\"ProjectName\">\n      <label className=\"ProjectName-label\" htmlFor=\"filename\">\n        {`${props.label}${props.isNameEditable ? \"\" : \":\"}`}\n      </label>\n      {props.isNameEditable ? (\n        <input\n          className=\"TextInput\"\n          onBlur={handleBlur}\n          onKeyDown={handleKeyDown}\n          id={`${id}-filename`}\n          value={fileName}\n          onChange={(event) => setFileName(event.target.value)}\n        />\n      ) : (\n        <span className=\"TextInput TextInput--readonly\" id={`${id}-filename`}>\n          {props.value}\n        </span>\n      )}\n    </div>\n  );\n};\n","import \"./Tooltip.scss\";\n\nimport React, { useEffect } from \"react\";\n\nconst getTooltipDiv = () => {\n  const existingDiv = document.querySelector<HTMLDivElement>(\n    \".excalidraw-tooltip\",\n  );\n  if (existingDiv) {\n    return existingDiv;\n  }\n  const div = document.createElement(\"div\");\n  document.body.appendChild(div);\n  div.classList.add(\"excalidraw-tooltip\");\n  return div;\n};\n\nconst updateTooltip = (\n  item: HTMLDivElement,\n  tooltip: HTMLDivElement,\n  label: string,\n  long: boolean,\n) => {\n  tooltip.classList.add(\"excalidraw-tooltip--visible\");\n  tooltip.style.minWidth = long ? \"50ch\" : \"10ch\";\n  tooltip.style.maxWidth = long ? \"50ch\" : \"15ch\";\n\n  tooltip.textContent = label;\n\n  const {\n    x: itemX,\n    bottom: itemBottom,\n    top: itemTop,\n    width: itemWidth,\n  } = item.getBoundingClientRect();\n\n  const {\n    width: labelWidth,\n    height: labelHeight,\n  } = tooltip.getBoundingClientRect();\n\n  const viewportWidth = window.innerWidth;\n  const viewportHeight = window.innerHeight;\n\n  const margin = 5;\n\n  const left = itemX + itemWidth / 2 - labelWidth / 2;\n  const offsetLeft =\n    left + labelWidth >= viewportWidth ? left + labelWidth - viewportWidth : 0;\n\n  const top = itemBottom + margin;\n  const offsetTop =\n    top + labelHeight >= viewportHeight\n      ? itemBottom - itemTop + labelHeight + margin * 2\n      : 0;\n\n  Object.assign(tooltip.style, {\n    top: `${top - offsetTop}px`,\n    left: `${left - offsetLeft}px`,\n  });\n};\n\ntype TooltipProps = {\n  children: React.ReactNode;\n  label: string;\n  long?: boolean;\n};\n\nexport const Tooltip = ({ children, label, long = false }: TooltipProps) => {\n  useEffect(() => {\n    return () =>\n      getTooltipDiv().classList.remove(\"excalidraw-tooltip--visible\");\n  }, []);\n\n  return (\n    <div\n      onPointerEnter={(event) =>\n        updateTooltip(\n          event.currentTarget as HTMLDivElement,\n          getTooltipDiv(),\n          label,\n          long,\n        )\n      }\n      onPointerLeave={() =>\n        getTooltipDiv().classList.remove(\"excalidraw-tooltip--visible\")\n      }\n    >\n      {children}\n    </div>\n  );\n};\n","import colors from \"./colors\";\nimport { AppState } from \"./types\";\n\nexport const getClientColors = (clientId: string, appState: AppState) => {\n  if (appState?.collaborators) {\n    const currentUser = appState.collaborators.get(clientId);\n    if (currentUser?.color) {\n      return currentUser.color;\n    }\n  }\n  // Naive way of getting an integer out of the clientId\n  const sum = clientId.split(\"\").reduce((a, str) => a + str.charCodeAt(0), 0);\n\n  // Skip transparent background.\n  const backgrounds = colors.elementBackground.slice(1);\n  const strokes = colors.elementStroke.slice(1);\n  return {\n    background: backgrounds[sum % backgrounds.length],\n    stroke: strokes[sum % strokes.length],\n  };\n};\n\nexport const getClientInitials = (username?: string | null) => {\n  if (!username) {\n    return \"?\";\n  }\n  const names = username.trim().split(\" \");\n\n  if (names.length < 2) {\n    return names[0].substring(0, 2).toUpperCase();\n  }\n\n  const firstName = names[0];\n  const lastName = names[names.length - 1];\n\n  return (firstName[0] + lastName[0]).toUpperCase();\n};\n","import {\n  PointerType,\n  ExcalidrawLinearElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  TextAlign,\n  ExcalidrawElement,\n  GroupId,\n  ExcalidrawBindableElement,\n  Arrowhead,\n  ChartType,\n  FontFamilyValues,\n} from \"./element/types\";\nimport { SHAPES } from \"./shapes\";\nimport { Point as RoughPoint } from \"roughjs/bin/geometry\";\nimport { LinearElementEditor } from \"./element/linearElementEditor\";\nimport { SuggestedBinding } from \"./element/binding\";\nimport { ImportedDataState } from \"./data/types\";\nimport type App from \"./components/App\";\nimport type { ResolvablePromise } from \"./utils\";\nimport { Spreadsheet } from \"./charts\";\nimport { Language } from \"./i18n\";\nimport { ClipboardData } from \"./clipboard\";\nimport { isOverScrollBars } from \"./scene\";\nimport { MaybeTransformHandleType } from \"./element/transformHandles\";\n\nexport type Point = Readonly<RoughPoint>;\n\nexport type Collaborator = {\n  pointer?: {\n    x: number;\n    y: number;\n  };\n  button?: \"up\" | \"down\";\n  selectedElementIds?: AppState[\"selectedElementIds\"];\n  username?: string | null;\n  userState?: UserIdleState;\n  color?: {\n    background: string;\n    stroke: string;\n  };\n};\n\nexport type AppState = {\n  isLoading: boolean;\n  errorMessage: string | null;\n  draggingElement: NonDeletedExcalidrawElement | null;\n  resizingElement: NonDeletedExcalidrawElement | null;\n  multiElement: NonDeleted<ExcalidrawLinearElement> | null;\n  selectionElement: NonDeletedExcalidrawElement | null;\n  isBindingEnabled: boolean;\n  startBoundElement: NonDeleted<ExcalidrawBindableElement> | null;\n  suggestedBindings: SuggestedBinding[];\n  // element being edited, but not necessarily added to elements array yet\n  // (e.g. text element when typing into the input)\n  editingElement: NonDeletedExcalidrawElement | null;\n  editingLinearElement: LinearElementEditor | null;\n  elementType: typeof SHAPES[number][\"value\"];\n  elementLocked: boolean;\n  exportBackground: boolean;\n  exportEmbedScene: boolean;\n  exportWithDarkMode: boolean;\n  exportScale: number;\n  currentItemStrokeColor: string;\n  currentItemBackgroundColor: string;\n  currentItemFillStyle: ExcalidrawElement[\"fillStyle\"];\n  currentItemStrokeWidth: number;\n  currentItemStrokeStyle: ExcalidrawElement[\"strokeStyle\"];\n  currentItemRoughness: number;\n  currentItemOpacity: number;\n  currentItemFontFamily: FontFamilyValues;\n  currentItemFontSize: number;\n  currentItemTextAlign: TextAlign;\n  currentItemStrokeSharpness: ExcalidrawElement[\"strokeSharpness\"];\n  currentItemStartArrowhead: Arrowhead | null;\n  currentItemEndArrowhead: Arrowhead | null;\n  currentItemLinearStrokeSharpness: ExcalidrawElement[\"strokeSharpness\"];\n  viewBackgroundColor: string;\n  scrollX: number;\n  scrollY: number;\n  cursorButton: \"up\" | \"down\";\n  scrolledOutside: boolean;\n  name: string;\n  isResizing: boolean;\n  isRotating: boolean;\n  zoom: Zoom;\n  openMenu: \"canvas\" | \"shape\" | null;\n  openPopup:\n    | \"canvasColorPicker\"\n    | \"backgroundColorPicker\"\n    | \"strokeColorPicker\"\n    | null;\n  lastPointerDownWith: PointerType;\n  selectedElementIds: { [id: string]: boolean };\n  previousSelectedElementIds: { [id: string]: boolean };\n  shouldCacheIgnoreZoom: boolean;\n  showHelpDialog: boolean;\n  toastMessage: string | null;\n  zenModeEnabled: boolean;\n  theme: \"light\" | \"dark\";\n  gridSize: number | null;\n  viewModeEnabled: boolean;\n\n  /** top-most selected groups (i.e. does not include nested groups) */\n  selectedGroupIds: { [groupId: string]: boolean };\n  /** group being edited when you drill down to its constituent element\n    (e.g. when you double-click on a group's element) */\n  editingGroupId: GroupId | null;\n  width: number;\n  height: number;\n  offsetTop: number;\n  offsetLeft: number;\n\n  isLibraryOpen: boolean;\n  fileHandle: import(\"browser-fs-access\").FileSystemHandle | null;\n  collaborators: Map<string, Collaborator>;\n  showStats: boolean;\n  currentChartType: ChartType;\n  pasteDialog:\n    | {\n        shown: false;\n        data: null;\n      }\n    | {\n        shown: true;\n        data: Spreadsheet;\n      };\n};\n\nexport type NormalizedZoomValue = number & { _brand: \"normalizedZoom\" };\n\nexport type Zoom = Readonly<{\n  value: NormalizedZoomValue;\n  translation: Readonly<{\n    x: number;\n    y: number;\n  }>;\n}>;\n\nexport type PointerCoords = Readonly<{\n  x: number;\n  y: number;\n}>;\n\nexport type Gesture = {\n  pointers: Map<number, PointerCoords>;\n  lastCenter: { x: number; y: number } | null;\n  initialDistance: number | null;\n  initialScale: number | null;\n};\n\nexport declare class GestureEvent extends UIEvent {\n  readonly rotation: number;\n  readonly scale: number;\n}\n\nexport type LibraryItem = readonly NonDeleted<ExcalidrawElement>[];\nexport type LibraryItems = readonly LibraryItem[];\n\n// NOTE ready/readyPromise props are optional for host apps' sake (our own\n// implem guarantees existence)\nexport type ExcalidrawAPIRefValue =\n  | ExcalidrawImperativeAPI\n  | {\n      readyPromise?: ResolvablePromise<ExcalidrawImperativeAPI>;\n      ready?: false;\n    };\n\nexport interface ExcalidrawProps {\n  onChange?: (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState,\n  ) => void;\n  initialData?: ImportedDataState | null | Promise<ImportedDataState | null>;\n  excalidrawRef?: ForwardRef<ExcalidrawAPIRefValue>;\n  onCollabButtonClick?: () => void;\n  isCollaborating?: boolean;\n  onPointerUpdate?: (payload: {\n    pointer: { x: number; y: number };\n    button: \"down\" | \"up\";\n    pointersMap: Gesture[\"pointers\"];\n  }) => void;\n  onPaste?: (\n    data: ClipboardData,\n    event: ClipboardEvent | null,\n  ) => Promise<boolean> | boolean;\n  renderTopRightUI?: (isMobile: boolean, appState: AppState) => JSX.Element;\n  renderFooter?: (isMobile: boolean, appState: AppState) => JSX.Element;\n  langCode?: Language[\"code\"];\n  viewModeEnabled?: boolean;\n  zenModeEnabled?: boolean;\n  gridModeEnabled?: boolean;\n  libraryReturnUrl?: string;\n  theme?: \"dark\" | \"light\";\n  name?: string;\n  renderCustomStats?: (\n    elements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n  ) => JSX.Element;\n  UIOptions?: UIOptions;\n  detectScroll?: boolean;\n  handleKeyboardGlobally?: boolean;\n  onLibraryChange?: (libraryItems: LibraryItems) => void | Promise<any>;\n  autoFocus?: boolean;\n}\n\nexport type SceneData = {\n  elements?: ImportedDataState[\"elements\"];\n  appState?: ImportedDataState[\"appState\"];\n  collaborators?: Map<string, Collaborator>;\n  commitToHistory?: boolean;\n};\n\nexport enum UserIdleState {\n  ACTIVE = \"active\",\n  AWAY = \"away\",\n  IDLE = \"idle\",\n}\n\nexport type ExportOpts = {\n  saveFileToDisk?: boolean;\n  onExportToBackend?: (\n    exportedElements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n    canvas: HTMLCanvasElement | null,\n  ) => void;\n  renderCustomUI?: (\n    exportedElements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n    canvas: HTMLCanvasElement | null,\n  ) => JSX.Element;\n};\n\ntype CanvasActions = {\n  changeViewBackgroundColor?: boolean;\n  clearCanvas?: boolean;\n  export?: false | ExportOpts;\n  loadScene?: boolean;\n  saveToActiveFile?: boolean;\n  theme?: boolean;\n  saveAsImage?: boolean;\n};\n\nexport type UIOptions = {\n  canvasActions?: CanvasActions;\n};\n\nexport type AppProps = ExcalidrawProps & {\n  UIOptions: {\n    canvasActions: Required<CanvasActions> & { export: ExportOpts };\n  };\n  detectScroll: boolean;\n  handleKeyboardGlobally: boolean;\n};\n\nexport type PointerDownState = Readonly<{\n  // The first position at which pointerDown happened\n  origin: Readonly<{ x: number; y: number }>;\n  // Same as \"origin\" but snapped to the grid, if grid is on\n  originInGrid: Readonly<{ x: number; y: number }>;\n  // Scrollbar checks\n  scrollbars: ReturnType<typeof isOverScrollBars>;\n  // The previous pointer position\n  lastCoords: { x: number; y: number };\n  // map of original elements data\n  originalElements: Map<string, NonDeleted<ExcalidrawElement>>;\n  resize: {\n    // Handle when resizing, might change during the pointer interaction\n    handleType: MaybeTransformHandleType;\n    // This is determined on the initial pointer down event\n    isResizing: boolean;\n    // This is determined on the initial pointer down event\n    offset: { x: number; y: number };\n    // This is determined on the initial pointer down event\n    arrowDirection: \"origin\" | \"end\";\n    // This is a center point of selected elements determined on the initial pointer down event (for rotation only)\n    center: { x: number; y: number };\n  };\n  hit: {\n    // The element the pointer is \"hitting\", is determined on the initial\n    // pointer down event\n    element: NonDeleted<ExcalidrawElement> | null;\n    // The elements the pointer is \"hitting\", is determined on the initial\n    // pointer down event\n    allHitElements: NonDeleted<ExcalidrawElement>[];\n    // This is determined on the initial pointer down event\n    wasAddedToSelection: boolean;\n    // Whether selected element(s) were duplicated, might change during the\n    // pointer interaction\n    hasBeenDuplicated: boolean;\n    hasHitCommonBoundingBoxOfSelectedElements: boolean;\n  };\n  withCmdOrCtrl: boolean;\n  drag: {\n    // Might change during the pointer interation\n    hasOccurred: boolean;\n    // Might change during the pointer interation\n    offset: { x: number; y: number } | null;\n  };\n  // We need to have these in the state so that we can unsubscribe them\n  eventListeners: {\n    // It's defined on the initial pointer down event\n    onMove: null | ((event: PointerEvent) => void);\n    // It's defined on the initial pointer down event\n    onUp: null | ((event: PointerEvent) => void);\n    // It's defined on the initial pointer down event\n    onKeyDown: null | ((event: KeyboardEvent) => void);\n    // It's defined on the initial pointer down event\n    onKeyUp: null | ((event: KeyboardEvent) => void);\n  };\n}>;\n\nexport type ExcalidrawImperativeAPI = {\n  updateScene: InstanceType<typeof App>[\"updateScene\"];\n  resetScene: InstanceType<typeof App>[\"resetScene\"];\n  getSceneElementsIncludingDeleted: InstanceType<\n    typeof App\n  >[\"getSceneElementsIncludingDeleted\"];\n  history: {\n    clear: InstanceType<typeof App>[\"resetHistory\"];\n  };\n  scrollToContent: InstanceType<typeof App>[\"scrollToContent\"];\n  getSceneElements: InstanceType<typeof App>[\"getSceneElements\"];\n  getAppState: () => InstanceType<typeof App>[\"state\"];\n  refresh: InstanceType<typeof App>[\"refresh\"];\n  importLibrary: InstanceType<typeof App>[\"importLibraryFromUrl\"];\n  setToastMessage: InstanceType<typeof App>[\"setToastMessage\"];\n  readyPromise: ResolvablePromise<ExcalidrawImperativeAPI>;\n  ready: true;\n  id: string;\n};\n","import { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport oc from \"open-color\";\n\nimport { AppState, Zoom } from \"../types\";\nimport {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawLinearElement,\n  NonDeleted,\n  GroupId,\n  ExcalidrawBindableElement,\n} from \"../element/types\";\nimport {\n  getElementAbsoluteCoords,\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n  getElementBounds,\n  getCommonBounds,\n} from \"../element\";\n\nimport { roundRect } from \"./roundRect\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  getScrollBars,\n  SCROLLBAR_COLOR,\n  SCROLLBAR_WIDTH,\n} from \"../scene/scrollbars\";\nimport { getSelectedElements } from \"../scene/selection\";\n\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\nimport { getClientColors } from \"../clients\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport {\n  isSelectedViaGroup,\n  getSelectedGroupIds,\n  getElementsInGroup,\n} from \"../groups\";\nimport { maxBindingGap } from \"../element/collision\";\nimport {\n  SuggestedBinding,\n  SuggestedPointBinding,\n  isBindingEnabled,\n} from \"../element/binding\";\nimport {\n  TransformHandles,\n  TransformHandleType,\n} from \"../element/transformHandles\";\nimport { viewportCoordsToSceneCoords, supportsEmoji } from \"../utils\";\nimport { UserIdleState } from \"../types\";\nimport { THEME_FILTER } from \"../constants\";\n\nconst hasEmojiSupport = supportsEmoji();\n\nconst strokeRectWithRotation = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n  fill: boolean = false,\n) => {\n  context.translate(cx, cy);\n  context.rotate(angle);\n  if (fill) {\n    context.fillRect(x - cx, y - cy, width, height);\n  }\n  context.strokeRect(x - cx, y - cy, width, height);\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n};\n\nconst strokeDiamondWithRotation = (\n  context: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n) => {\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.beginPath();\n  context.moveTo(0, height / 2);\n  context.lineTo(width / 2, 0);\n  context.lineTo(0, -height / 2);\n  context.lineTo(-width / 2, 0);\n  context.closePath();\n  context.stroke();\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n};\n\nconst strokeEllipseWithRotation = (\n  context: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n) => {\n  context.beginPath();\n  context.ellipse(cx, cy, width / 2, height / 2, angle, 0, Math.PI * 2);\n  context.stroke();\n};\n\nconst fillCircle = (\n  context: CanvasRenderingContext2D,\n  cx: number,\n  cy: number,\n  radius: number,\n) => {\n  context.beginPath();\n  context.arc(cx, cy, radius, 0, Math.PI * 2);\n  context.fill();\n  context.stroke();\n};\n\nconst strokeGrid = (\n  context: CanvasRenderingContext2D,\n  gridSize: number,\n  offsetX: number,\n  offsetY: number,\n  width: number,\n  height: number,\n) => {\n  const origStrokeStyle = context.strokeStyle;\n  context.strokeStyle = \"rgba(0,0,0,0.1)\";\n  context.beginPath();\n  for (let x = offsetX; x < offsetX + width + gridSize * 2; x += gridSize) {\n    context.moveTo(x, offsetY - gridSize);\n    context.lineTo(x, offsetY + height + gridSize * 2);\n  }\n  for (let y = offsetY; y < offsetY + height + gridSize * 2; y += gridSize) {\n    context.moveTo(offsetX - gridSize, y);\n    context.lineTo(offsetX + width + gridSize * 2, y);\n  }\n  context.stroke();\n  context.strokeStyle = origStrokeStyle;\n};\n\nconst renderLinearPointHandles = (\n  context: CanvasRenderingContext2D,\n  appState: AppState,\n  sceneState: SceneState,\n  element: NonDeleted<ExcalidrawLinearElement>,\n) => {\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  const origStrokeStyle = context.strokeStyle;\n  const lineWidth = context.lineWidth;\n  context.lineWidth = 1 / sceneState.zoom.value;\n\n  LinearElementEditor.getPointsGlobalCoordinates(element).forEach(\n    (point, idx) => {\n      context.strokeStyle = \"red\";\n      context.setLineDash([]);\n      context.fillStyle =\n        appState.editingLinearElement?.activePointIndex === idx\n          ? \"rgba(255, 127, 127, 0.9)\"\n          : \"rgba(255, 255, 255, 0.9)\";\n      const { POINT_HANDLE_SIZE } = LinearElementEditor;\n      fillCircle(\n        context,\n        point[0],\n        point[1],\n        POINT_HANDLE_SIZE / 2 / sceneState.zoom.value,\n      );\n    },\n  );\n  context.setLineDash([]);\n  context.lineWidth = lineWidth;\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n  context.strokeStyle = origStrokeStyle;\n};\n\nexport const renderScene = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  selectionElement: NonDeletedExcalidrawElement | null,\n  scale: number,\n  rc: RoughCanvas,\n  canvas: HTMLCanvasElement,\n  sceneState: SceneState,\n  // extra options, currently passed by export helper\n  {\n    renderScrollbars = true,\n    renderSelection = true,\n    // Whether to employ render optimizations to improve performance.\n    // Should not be turned on for export operations and similar, because it\n    // doesn't guarantee pixel-perfect output.\n    renderOptimizations = false,\n    renderGrid = true,\n  }: {\n    renderScrollbars?: boolean;\n    renderSelection?: boolean;\n    renderOptimizations?: boolean;\n    renderGrid?: boolean;\n  } = {},\n) => {\n  if (canvas === null) {\n    return { atLeastOneVisibleElement: false };\n  }\n\n  const context = canvas.getContext(\"2d\")!;\n\n  context.scale(scale, scale);\n\n  // When doing calculations based on canvas width we should used normalized one\n  const normalizedCanvasWidth = canvas.width / scale;\n  const normalizedCanvasHeight = canvas.height / scale;\n\n  if (sceneState.exportWithDarkMode) {\n    context.filter = THEME_FILTER;\n  }\n\n  // Paint background\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    const hasTransparence =\n      sceneState.viewBackgroundColor === \"transparent\" ||\n      sceneState.viewBackgroundColor.length === 5 || // #RGBA\n      sceneState.viewBackgroundColor.length === 9 || // #RRGGBBA\n      /(hsla|rgba)\\(/.test(sceneState.viewBackgroundColor);\n    if (hasTransparence) {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n    const fillStyle = context.fillStyle;\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    context.fillStyle = fillStyle;\n  } else {\n    context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  }\n\n  // Apply zoom\n  const zoomTranslationX = sceneState.zoom.translation.x;\n  const zoomTranslationY = sceneState.zoom.translation.y;\n  context.translate(zoomTranslationX, zoomTranslationY);\n  context.scale(sceneState.zoom.value, sceneState.zoom.value);\n\n  // Grid\n  if (renderGrid && appState.gridSize) {\n    strokeGrid(\n      context,\n      appState.gridSize,\n      -Math.ceil(zoomTranslationX / sceneState.zoom.value / appState.gridSize) *\n        appState.gridSize +\n        (sceneState.scrollX % appState.gridSize),\n      -Math.ceil(zoomTranslationY / sceneState.zoom.value / appState.gridSize) *\n        appState.gridSize +\n        (sceneState.scrollY % appState.gridSize),\n      normalizedCanvasWidth / sceneState.zoom.value,\n      normalizedCanvasHeight / sceneState.zoom.value,\n    );\n  }\n\n  // Paint visible elements\n  const visibleElements = elements.filter((element) =>\n    isVisibleElement(element, normalizedCanvasWidth, normalizedCanvasHeight, {\n      zoom: sceneState.zoom,\n      offsetLeft: appState.offsetLeft,\n      offsetTop: appState.offsetTop,\n      scrollX: sceneState.scrollX,\n      scrollY: sceneState.scrollY,\n    }),\n  );\n\n  visibleElements.forEach((element) => {\n    try {\n      renderElement(element, rc, context, renderOptimizations, sceneState);\n    } catch (error) {\n      console.error(error);\n    }\n  });\n\n  if (appState.editingLinearElement) {\n    const element = LinearElementEditor.getElement(\n      appState.editingLinearElement.elementId,\n    );\n    if (element) {\n      renderLinearPointHandles(context, appState, sceneState, element);\n    }\n  }\n\n  // Paint selection element\n  if (selectionElement) {\n    try {\n      renderElement(\n        selectionElement,\n        rc,\n        context,\n        renderOptimizations,\n        sceneState,\n      );\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  if (isBindingEnabled(appState)) {\n    appState.suggestedBindings\n      .filter((binding) => binding != null)\n      .forEach((suggestedBinding) => {\n        renderBindingHighlight(context, sceneState, suggestedBinding!);\n      });\n  }\n\n  // Paint selected elements\n  if (\n    renderSelection &&\n    !appState.multiElement &&\n    !appState.editingLinearElement\n  ) {\n    const selections = elements.reduce((acc, element) => {\n      const selectionColors = [];\n      // local user\n      if (\n        appState.selectedElementIds[element.id] &&\n        !isSelectedViaGroup(appState, element)\n      ) {\n        selectionColors.push(oc.black);\n      }\n      // remote users\n      if (sceneState.remoteSelectedElementIds[element.id]) {\n        selectionColors.push(\n          ...sceneState.remoteSelectedElementIds[element.id].map((socketId) => {\n            const { background } = getClientColors(socketId, appState);\n            return background;\n          }),\n        );\n      }\n      if (selectionColors.length) {\n        const [\n          elementX1,\n          elementY1,\n          elementX2,\n          elementY2,\n        ] = getElementAbsoluteCoords(element);\n        acc.push({\n          angle: element.angle,\n          elementX1,\n          elementY1,\n          elementX2,\n          elementY2,\n          selectionColors,\n        });\n      }\n      return acc;\n    }, [] as { angle: number; elementX1: number; elementY1: number; elementX2: number; elementY2: number; selectionColors: string[] }[]);\n\n    const addSelectionForGroupId = (groupId: GroupId) => {\n      const groupElements = getElementsInGroup(elements, groupId);\n      const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(\n        groupElements,\n      );\n      selections.push({\n        angle: 0,\n        elementX1,\n        elementX2,\n        elementY1,\n        elementY2,\n        selectionColors: [oc.black],\n      });\n    };\n\n    for (const groupId of getSelectedGroupIds(appState)) {\n      // TODO: support multiplayer selected group IDs\n      addSelectionForGroupId(groupId);\n    }\n\n    if (appState.editingGroupId) {\n      addSelectionForGroupId(appState.editingGroupId);\n    }\n\n    selections.forEach((selection) =>\n      renderSelectionBorder(context, sceneState, selection),\n    );\n\n    const locallySelectedElements = getSelectedElements(elements, appState);\n\n    // Paint resize transformHandles\n    context.translate(sceneState.scrollX, sceneState.scrollY);\n    if (locallySelectedElements.length === 1) {\n      context.fillStyle = oc.white;\n      const transformHandles = getTransformHandles(\n        locallySelectedElements[0],\n        sceneState.zoom,\n        \"mouse\", // when we render we don't know which pointer type so use mouse\n      );\n      if (!appState.viewModeEnabled) {\n        renderTransformHandles(\n          context,\n          sceneState,\n          transformHandles,\n          locallySelectedElements[0].angle,\n        );\n      }\n    } else if (locallySelectedElements.length > 1 && !appState.isRotating) {\n      const dashedLinePadding = 4 / sceneState.zoom.value;\n      context.fillStyle = oc.white;\n      const [x1, y1, x2, y2] = getCommonBounds(locallySelectedElements);\n      const initialLineDash = context.getLineDash();\n      context.setLineDash([2 / sceneState.zoom.value]);\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / sceneState.zoom.value;\n      strokeRectWithRotation(\n        context,\n        x1 - dashedLinePadding,\n        y1 - dashedLinePadding,\n        x2 - x1 + dashedLinePadding * 2,\n        y2 - y1 + dashedLinePadding * 2,\n        (x1 + x2) / 2,\n        (y1 + y2) / 2,\n        0,\n      );\n      context.lineWidth = lineWidth;\n      context.setLineDash(initialLineDash);\n      const transformHandles = getTransformHandlesFromCoords(\n        [x1, y1, x2, y2],\n        0,\n        sceneState.zoom,\n        \"mouse\",\n        OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n      );\n      renderTransformHandles(context, sceneState, transformHandles, 0);\n    }\n    context.translate(-sceneState.scrollX, -sceneState.scrollY);\n  }\n\n  // Reset zoom\n  context.scale(1 / sceneState.zoom.value, 1 / sceneState.zoom.value);\n  context.translate(-zoomTranslationX, -zoomTranslationY);\n\n  // Paint remote pointers\n  for (const clientId in sceneState.remotePointerViewportCoords) {\n    let { x, y } = sceneState.remotePointerViewportCoords[clientId];\n\n    x -= appState.offsetLeft;\n    y -= appState.offsetTop;\n\n    const width = 9;\n    const height = 14;\n\n    const isOutOfBounds =\n      x < 0 ||\n      x > normalizedCanvasWidth - width ||\n      y < 0 ||\n      y > normalizedCanvasHeight - height;\n\n    x = Math.max(x, 0);\n    x = Math.min(x, normalizedCanvasWidth - width);\n    y = Math.max(y, 0);\n    y = Math.min(y, normalizedCanvasHeight - height);\n\n    const { background, stroke } = getClientColors(clientId, appState);\n\n    const strokeStyle = context.strokeStyle;\n    const fillStyle = context.fillStyle;\n    const globalAlpha = context.globalAlpha;\n    context.strokeStyle = stroke;\n    context.fillStyle = background;\n\n    const userState = sceneState.remotePointerUserStates[clientId];\n    if (isOutOfBounds || userState === UserIdleState.AWAY) {\n      context.globalAlpha = 0.48;\n    }\n\n    if (\n      sceneState.remotePointerButton &&\n      sceneState.remotePointerButton[clientId] === \"down\"\n    ) {\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 3;\n      context.strokeStyle = \"#ffffff88\";\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 1;\n      context.strokeStyle = stroke;\n      context.stroke();\n      context.closePath();\n    }\n\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x + 1, y + 14);\n    context.lineTo(x + 4, y + 9);\n    context.lineTo(x + 9, y + 10);\n    context.lineTo(x, y);\n    context.fill();\n    context.stroke();\n\n    const username = sceneState.remotePointerUsernames[clientId];\n\n    let idleState = \"\";\n    if (userState === UserIdleState.AWAY) {\n      idleState = hasEmojiSupport ? \"⚫️\" : ` (${UserIdleState.AWAY})`;\n    } else if (userState === UserIdleState.IDLE) {\n      idleState = hasEmojiSupport ? \"💤\" : ` (${UserIdleState.IDLE})`;\n    } else if (userState === UserIdleState.ACTIVE) {\n      idleState = hasEmojiSupport ? \"🟢\" : \"\";\n    }\n\n    const usernameAndIdleState = `${\n      username ? `${username} ` : \"\"\n    }${idleState}`;\n\n    if (!isOutOfBounds && usernameAndIdleState) {\n      const offsetX = x + width;\n      const offsetY = y + height;\n      const paddingHorizontal = 4;\n      const paddingVertical = 4;\n      const measure = context.measureText(usernameAndIdleState);\n      const measureHeight =\n        measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;\n\n      // Border\n      context.fillStyle = stroke;\n      context.fillRect(\n        offsetX - 1,\n        offsetY - 1,\n        measure.width + 2 * paddingHorizontal + 2,\n        measureHeight + 2 * paddingVertical + 2,\n      );\n      // Background\n      context.fillStyle = background;\n      context.fillRect(\n        offsetX,\n        offsetY,\n        measure.width + 2 * paddingHorizontal,\n        measureHeight + 2 * paddingVertical,\n      );\n      context.fillStyle = oc.white;\n\n      context.fillText(\n        usernameAndIdleState,\n        offsetX + paddingHorizontal,\n        offsetY + paddingVertical + measure.actualBoundingBoxAscent,\n      );\n    }\n\n    context.strokeStyle = strokeStyle;\n    context.fillStyle = fillStyle;\n    context.globalAlpha = globalAlpha;\n    context.closePath();\n  }\n\n  // Paint scrollbars\n  let scrollBars;\n  if (renderScrollbars) {\n    scrollBars = getScrollBars(\n      elements,\n      normalizedCanvasWidth,\n      normalizedCanvasHeight,\n      sceneState,\n    );\n\n    const fillStyle = context.fillStyle;\n    const strokeStyle = context.strokeStyle;\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {\n      if (scrollBar) {\n        roundRect(\n          context,\n          scrollBar.x,\n          scrollBar.y,\n          scrollBar.width,\n          scrollBar.height,\n          SCROLLBAR_WIDTH / 2,\n        );\n      }\n    });\n    context.fillStyle = fillStyle;\n    context.strokeStyle = strokeStyle;\n  }\n\n  context.scale(1 / scale, 1 / scale);\n\n  return { atLeastOneVisibleElement: visibleElements.length > 0, scrollBars };\n};\n\nconst renderTransformHandles = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  transformHandles: TransformHandles,\n  angle: number,\n): void => {\n  Object.keys(transformHandles).forEach((key) => {\n    const transformHandle = transformHandles[key as TransformHandleType];\n    if (transformHandle !== undefined) {\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / sceneState.zoom.value;\n      if (key === \"rotation\") {\n        fillCircle(\n          context,\n          transformHandle[0] + transformHandle[2] / 2,\n          transformHandle[1] + transformHandle[3] / 2,\n          transformHandle[2] / 2,\n        );\n      } else {\n        strokeRectWithRotation(\n          context,\n          transformHandle[0],\n          transformHandle[1],\n          transformHandle[2],\n          transformHandle[3],\n          transformHandle[0] + transformHandle[2] / 2,\n          transformHandle[1] + transformHandle[3] / 2,\n          angle,\n          true, // fill before stroke\n        );\n      }\n      context.lineWidth = lineWidth;\n    }\n  });\n};\n\nconst renderSelectionBorder = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  elementProperties: {\n    angle: number;\n    elementX1: number;\n    elementY1: number;\n    elementX2: number;\n    elementY2: number;\n    selectionColors: string[];\n  },\n) => {\n  const {\n    angle,\n    elementX1,\n    elementY1,\n    elementX2,\n    elementY2,\n    selectionColors,\n  } = elementProperties;\n  const elementWidth = elementX2 - elementX1;\n  const elementHeight = elementY2 - elementY1;\n\n  const initialLineDash = context.getLineDash();\n  const lineWidth = context.lineWidth;\n  const lineDashOffset = context.lineDashOffset;\n  const strokeStyle = context.strokeStyle;\n\n  const dashedLinePadding = 4 / sceneState.zoom.value;\n  const dashWidth = 8 / sceneState.zoom.value;\n  const spaceWidth = 4 / sceneState.zoom.value;\n\n  context.lineWidth = 1 / sceneState.zoom.value;\n\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n\n  const count = selectionColors.length;\n  for (let index = 0; index < count; ++index) {\n    context.strokeStyle = selectionColors[index];\n    context.setLineDash([\n      dashWidth,\n      spaceWidth + (dashWidth + spaceWidth) * (count - 1),\n    ]);\n    context.lineDashOffset = (dashWidth + spaceWidth) * index;\n    strokeRectWithRotation(\n      context,\n      elementX1 - dashedLinePadding,\n      elementY1 - dashedLinePadding,\n      elementWidth + dashedLinePadding * 2,\n      elementHeight + dashedLinePadding * 2,\n      elementX1 + elementWidth / 2,\n      elementY1 + elementHeight / 2,\n      angle,\n    );\n  }\n  context.lineDashOffset = lineDashOffset;\n  context.strokeStyle = strokeStyle;\n  context.lineWidth = lineWidth;\n  context.setLineDash(initialLineDash);\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n};\n\nconst renderBindingHighlight = (\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n  suggestedBinding: SuggestedBinding,\n) => {\n  // preserve context settings to restore later\n  const originalStrokeStyle = context.strokeStyle;\n  const originalLineWidth = context.lineWidth;\n\n  const renderHighlight = Array.isArray(suggestedBinding)\n    ? renderBindingHighlightForSuggestedPointBinding\n    : renderBindingHighlightForBindableElement;\n\n  context.translate(sceneState.scrollX, sceneState.scrollY);\n  renderHighlight(context, suggestedBinding as any);\n\n  // restore context settings\n  context.strokeStyle = originalStrokeStyle;\n  context.lineWidth = originalLineWidth;\n  context.translate(-sceneState.scrollX, -sceneState.scrollY);\n};\n\nconst renderBindingHighlightForBindableElement = (\n  context: CanvasRenderingContext2D,\n  element: ExcalidrawBindableElement,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const threshold = maxBindingGap(element, width, height);\n\n  // So that we don't overlap the element itself\n  const strokeOffset = 4;\n  context.strokeStyle = \"rgba(0,0,0,.05)\";\n  context.lineWidth = threshold - strokeOffset;\n  const padding = strokeOffset / 2 + threshold / 2;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n      strokeRectWithRotation(\n        context,\n        x1 - padding,\n        y1 - padding,\n        width + padding * 2,\n        height + padding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    case \"diamond\":\n      const side = Math.hypot(width, height);\n      const wPadding = (padding * side) / height;\n      const hPadding = (padding * side) / width;\n      strokeDiamondWithRotation(\n        context,\n        width + wPadding * 2,\n        height + hPadding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    case \"ellipse\":\n      strokeEllipseWithRotation(\n        context,\n        width + padding * 2,\n        height + padding * 2,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n  }\n};\n\nconst renderBindingHighlightForSuggestedPointBinding = (\n  context: CanvasRenderingContext2D,\n  suggestedBinding: SuggestedPointBinding,\n) => {\n  const [element, startOrEnd, bindableElement] = suggestedBinding;\n\n  const threshold = maxBindingGap(\n    bindableElement,\n    bindableElement.width,\n    bindableElement.height,\n  );\n\n  context.strokeStyle = \"rgba(0,0,0,0)\";\n  context.fillStyle = \"rgba(0,0,0,.05)\";\n\n  const pointIndices =\n    startOrEnd === \"both\" ? [0, -1] : startOrEnd === \"start\" ? [0] : [-1];\n  pointIndices.forEach((index) => {\n    const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n      element,\n      index,\n    );\n    fillCircle(context, x, y, threshold);\n  });\n};\n\nconst isVisibleElement = (\n  element: ExcalidrawElement,\n  canvasWidth: number,\n  canvasHeight: number,\n  viewTransformations: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n) => {\n  const [x1, y1, x2, y2] = getElementBounds(element); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft,\n      clientY: viewTransformations.offsetTop,\n    },\n    viewTransformations,\n  );\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + canvasWidth,\n      clientY: viewTransformations.offsetTop + canvasHeight,\n    },\n    viewTransformations,\n  );\n\n  return (\n    topLeftSceneCoords.x <= x2 &&\n    topLeftSceneCoords.y <= y2 &&\n    bottomRightSceneCoords.x >= x1 &&\n    bottomRightSceneCoords.y >= y1\n  );\n};\n\n// This should be only called for exporting purposes\nexport const renderSceneToSvg = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  {\n    offsetX = 0,\n    offsetY = 0,\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n  } = {},\n) => {\n  if (!svgRoot) {\n    return;\n  }\n  // render elements\n  elements.forEach((element) => {\n    if (!element.isDeleted) {\n      try {\n        renderElementToSvg(\n          element,\n          rsvg,\n          svgRoot,\n          element.x + offsetX,\n          element.y + offsetY,\n        );\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  });\n};\n","/**\n * https://stackoverflow.com/a/3368118\n * Draws a rounded rectangle using the current state of the canvas.\n * @param {CanvasRenderingContext2D} context\n * @param {Number} x The top left x coordinate\n * @param {Number} y The top left y coordinate\n * @param {Number} width The width of the rectangle\n * @param {Number} height The height of the rectangle\n * @param {Number} radius The corner radius\n */\nexport const roundRect = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  radius: number,\n) => {\n  context.beginPath();\n  context.moveTo(x + radius, y);\n  context.lineTo(x + width - radius, y);\n  context.quadraticCurveTo(x + width, y, x + width, y + radius);\n  context.lineTo(x + width, y + height - radius);\n  context.quadraticCurveTo(\n    x + width,\n    y + height,\n    x + width - radius,\n    y + height,\n  );\n  context.lineTo(x + radius, y + height);\n  context.quadraticCurveTo(x, y + height, x, y + height - radius);\n  context.lineTo(x, y + radius);\n  context.quadraticCurveTo(x, y, x + radius, y);\n  context.closePath();\n  context.fill();\n  context.stroke();\n};\n","type CANVAS_ERROR_NAMES = \"CANVAS_ERROR\" | \"CANVAS_POSSIBLY_TOO_BIG\";\nexport class CanvasError extends Error {\n  constructor(\n    message: string = \"Couldn't export canvas.\",\n    name: CANVAS_ERROR_NAMES = \"CANVAS_ERROR\",\n  ) {\n    super();\n    this.name = name;\n    this.message = message;\n  }\n}\n","import {\n  ExcalidrawElement,\n  ExcalidrawSelectionElement,\n  FontFamilyValues,\n} from \"../element/types\";\nimport { AppState, NormalizedZoomValue } from \"../types\";\nimport { ImportedDataState } from \"./types\";\nimport {\n  getElementMap,\n  getNormalizedDimensions,\n  isInvisiblySmallElement,\n} from \"../element\";\nimport { isLinearElementType } from \"../element/typeChecks\";\nimport { randomId } from \"../random\";\nimport {\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n  DEFAULT_VERTICAL_ALIGN,\n  FONT_FAMILY,\n} from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { bumpVersion } from \"../element/mutateElement\";\n\ntype RestoredAppState = Omit<\n  AppState,\n  \"offsetTop\" | \"offsetLeft\" | \"width\" | \"height\"\n>;\n\nexport const AllowedExcalidrawElementTypes: Record<\n  ExcalidrawElement[\"type\"],\n  true\n> = {\n  selection: true,\n  text: true,\n  rectangle: true,\n  diamond: true,\n  ellipse: true,\n  line: true,\n  arrow: true,\n  freedraw: true,\n};\n\nexport type RestoredDataState = {\n  elements: ExcalidrawElement[];\n  appState: RestoredAppState;\n};\n\nconst getFontFamilyByName = (fontFamilyName: string): FontFamilyValues => {\n  if (Object.keys(FONT_FAMILY).includes(fontFamilyName)) {\n    return FONT_FAMILY[\n      fontFamilyName as keyof typeof FONT_FAMILY\n    ] as FontFamilyValues;\n  }\n  return DEFAULT_FONT_FAMILY;\n};\n\nconst restoreElementWithProperties = <\n  T extends ExcalidrawElement,\n  K extends keyof Omit<\n    Required<T>,\n    Exclude<keyof ExcalidrawElement, \"type\" | \"x\" | \"y\">\n  >\n>(\n  element: Required<T>,\n  extra: Pick<T, K>,\n): T => {\n  const base: Pick<T, keyof ExcalidrawElement> = {\n    type: (extra as Partial<T>).type || element.type,\n    // all elements must have version > 0 so getSceneVersion() will pick up\n    // newly added elements\n    version: element.version || 1,\n    versionNonce: element.versionNonce ?? 0,\n    isDeleted: element.isDeleted ?? false,\n    id: element.id || randomId(),\n    fillStyle: element.fillStyle || \"hachure\",\n    strokeWidth: element.strokeWidth || 1,\n    strokeStyle: element.strokeStyle ?? \"solid\",\n    roughness: element.roughness ?? 1,\n    opacity: element.opacity == null ? 100 : element.opacity,\n    angle: element.angle || 0,\n    x: (extra as Partial<T>).x ?? element.x ?? 0,\n    y: (extra as Partial<T>).y ?? element.y ?? 0,\n    strokeColor: element.strokeColor,\n    backgroundColor: element.backgroundColor,\n    width: element.width || 0,\n    height: element.height || 0,\n    seed: element.seed ?? 1,\n    groupIds: element.groupIds ?? [],\n    strokeSharpness:\n      element.strokeSharpness ??\n      (isLinearElementType(element.type) ? \"round\" : \"sharp\"),\n    boundElementIds: element.boundElementIds ?? [],\n  };\n\n  return ({\n    ...base,\n    ...getNormalizedDimensions(base),\n    ...extra,\n  } as unknown) as T;\n};\n\nconst restoreElement = (\n  element: Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n): typeof element => {\n  switch (element.type) {\n    case \"text\":\n      let fontSize = element.fontSize;\n      let fontFamily = element.fontFamily;\n      if (\"font\" in element) {\n        const [fontPx, _fontFamily]: [\n          string,\n          string,\n        ] = (element as any).font.split(\" \");\n        fontSize = parseInt(fontPx, 10);\n        fontFamily = getFontFamilyByName(_fontFamily);\n      }\n      return restoreElementWithProperties(element, {\n        fontSize,\n        fontFamily,\n        text: element.text ?? \"\",\n        baseline: element.baseline,\n        textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,\n        verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN,\n      });\n    case \"freedraw\": {\n      return restoreElementWithProperties(element, {\n        points: element.points,\n        lastCommittedPoint: null,\n        simulatePressure: element.simulatePressure,\n        pressures: element.pressures,\n      });\n    }\n    case \"line\":\n    // @ts-ignore LEGACY type\n    // eslint-disable-next-line no-fallthrough\n    case \"draw\":\n    case \"arrow\": {\n      const {\n        startArrowhead = null,\n        endArrowhead = element.type === \"arrow\" ? \"arrow\" : null,\n      } = element;\n\n      let x = element.x;\n      let y = element.y;\n      let points = // migrate old arrow model to new one\n        !Array.isArray(element.points) || element.points.length < 2\n          ? [\n              [0, 0],\n              [element.width, element.height],\n            ]\n          : element.points;\n\n      if (points[0][0] !== 0 || points[0][1] !== 0) {\n        ({ points, x, y } = LinearElementEditor.getNormalizedPoints(element));\n      }\n\n      return restoreElementWithProperties(element, {\n        type:\n          (element.type as ExcalidrawElement[\"type\"] | \"draw\") === \"draw\"\n            ? \"line\"\n            : element.type,\n        startBinding: element.startBinding,\n        endBinding: element.endBinding,\n        lastCommittedPoint: null,\n        startArrowhead,\n        endArrowhead,\n        points,\n        x,\n        y,\n      });\n    }\n    // generic elements\n    case \"ellipse\":\n      return restoreElementWithProperties(element, {});\n    case \"rectangle\":\n      return restoreElementWithProperties(element, {});\n    case \"diamond\":\n      return restoreElementWithProperties(element, {});\n\n    // Don't use default case so as to catch a missing an element type case.\n    // We also don't want to throw, but instead return void so we filter\n    // out these unsupported elements from the restored array.\n  }\n};\n\nexport const restoreElements = (\n  elements: ImportedDataState[\"elements\"],\n  /** NOTE doesn't serve for reconciliation */\n  localElements: readonly ExcalidrawElement[] | null | undefined,\n): ExcalidrawElement[] => {\n  const localElementsMap = localElements ? getElementMap(localElements) : null;\n  return (elements || []).reduce((elements, element) => {\n    // filtering out selection, which is legacy, no longer kept in elements,\n    // and causing issues if retained\n    if (element.type !== \"selection\" && !isInvisiblySmallElement(element)) {\n      let migratedElement: ExcalidrawElement = restoreElement(element);\n      if (migratedElement) {\n        const localElement = localElementsMap?.[element.id];\n        if (localElement && localElement.version > migratedElement.version) {\n          migratedElement = bumpVersion(migratedElement, localElement.version);\n        }\n        elements.push(migratedElement);\n      }\n    }\n    return elements;\n  }, [] as ExcalidrawElement[]);\n};\n\nexport const restoreAppState = (\n  appState: ImportedDataState[\"appState\"],\n  localAppState: Partial<AppState> | null | undefined,\n): RestoredAppState => {\n  appState = appState || {};\n\n  const defaultAppState = getDefaultAppState();\n  const nextAppState = {} as typeof defaultAppState;\n\n  for (const [key, defaultValue] of Object.entries(defaultAppState) as [\n    keyof typeof defaultAppState,\n    any,\n  ][]) {\n    const suppliedValue = appState[key];\n    const localValue = localAppState ? localAppState[key] : undefined;\n    (nextAppState as any)[key] =\n      suppliedValue !== undefined\n        ? suppliedValue\n        : localValue !== undefined\n        ? localValue\n        : defaultValue;\n  }\n\n  return {\n    ...nextAppState,\n    elementType: AllowedExcalidrawElementTypes[nextAppState.elementType]\n      ? nextAppState.elementType\n      : \"selection\",\n    // Migrates from previous version where appState.zoom was a number\n    zoom:\n      typeof appState.zoom === \"number\"\n        ? {\n            value: appState.zoom as NormalizedZoomValue,\n            translation: defaultAppState.zoom.translation,\n          }\n        : appState.zoom || defaultAppState.zoom,\n  };\n};\n\nexport const restore = (\n  data: ImportedDataState | null,\n  /**\n   * Local AppState (`this.state` or initial state from localStorage) so that we\n   * don't overwrite local state with default values (when values not\n   * explicitly specified).\n   * Supply `null` if you can't get access to it.\n   */\n  localAppState: Partial<AppState> | null | undefined,\n  localElements: readonly ExcalidrawElement[] | null | undefined,\n): RestoredDataState => {\n  return {\n    elements: restoreElements(data?.elements, localElements),\n    appState: restoreAppState(data?.appState, localAppState || null),\n  };\n};\n","import { cleanAppStateForExport } from \"../appState\";\nimport { EXPORT_DATA_TYPES } from \"../constants\";\nimport { clearElementsForExport } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { CanvasError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { isValidExcalidrawData } from \"./json\";\nimport { restore } from \"./restore\";\nimport { ImportedLibraryData } from \"./types\";\n\nconst parseFileContents = async (blob: Blob | File) => {\n  let contents: string;\n\n  if (blob.type === \"image/png\") {\n    try {\n      return await (\n        await import(/* webpackChunkName: \"image\" */ \"./image\")\n      ).decodePngMetadata(blob);\n    } catch (error) {\n      if (error.message === \"INVALID\") {\n        throw new Error(t(\"alerts.imageDoesNotContainScene\"));\n      } else {\n        throw new Error(t(\"alerts.cannotRestoreFromImage\"));\n      }\n    }\n  } else {\n    if (\"text\" in Blob) {\n      contents = await blob.text();\n    } else {\n      contents = await new Promise((resolve) => {\n        const reader = new FileReader();\n        reader.readAsText(blob, \"utf8\");\n        reader.onloadend = () => {\n          if (reader.readyState === FileReader.DONE) {\n            resolve(reader.result as string);\n          }\n        };\n      });\n    }\n    if (blob.type === \"image/svg+xml\") {\n      try {\n        return await (\n          await import(/* webpackChunkName: \"image\" */ \"./image\")\n        ).decodeSvgMetadata({\n          svg: contents,\n        });\n      } catch (error) {\n        if (error.message === \"INVALID\") {\n          throw new Error(t(\"alerts.imageDoesNotContainScene\"));\n        } else {\n          throw new Error(t(\"alerts.cannotRestoreFromImage\"));\n        }\n      }\n    }\n  }\n  return contents;\n};\n\nexport const getMimeType = (blob: Blob | string): string => {\n  let name: string;\n  if (typeof blob === \"string\") {\n    name = blob;\n  } else {\n    if (blob.type) {\n      return blob.type;\n    }\n    name = blob.name || \"\";\n  }\n  if (/\\.(excalidraw|json)$/.test(name)) {\n    return \"application/json\";\n  } else if (/\\.png$/.test(name)) {\n    return \"image/png\";\n  } else if (/\\.jpe?g$/.test(name)) {\n    return \"image/jpeg\";\n  } else if (/\\.svg$/.test(name)) {\n    return \"image/svg+xml\";\n  }\n  return \"\";\n};\n\nexport const loadFromBlob = async (\n  blob: Blob,\n  /** @see restore.localAppState */\n  localAppState: AppState | null,\n  localElements: readonly ExcalidrawElement[] | null,\n) => {\n  const contents = await parseFileContents(blob);\n  try {\n    const data = JSON.parse(contents);\n    if (!isValidExcalidrawData(data)) {\n      throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n    }\n    const result = restore(\n      {\n        elements: clearElementsForExport(data.elements || []),\n        appState: {\n          theme: localAppState?.theme,\n          fileHandle: (!blob.type.startsWith(\"image/\") && blob.handle) || null,\n          ...cleanAppStateForExport(data.appState || {}),\n          ...(localAppState\n            ? calculateScrollCenter(data.elements || [], localAppState, null)\n            : {}),\n        },\n      },\n      localAppState,\n      localElements,\n    );\n\n    return result;\n  } catch (error) {\n    console.error(error.message);\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n};\n\nexport const loadLibraryFromBlob = async (blob: Blob) => {\n  const contents = await parseFileContents(blob);\n  const data: ImportedLibraryData = JSON.parse(contents);\n  if (data.type !== EXPORT_DATA_TYPES.excalidrawLibrary) {\n    throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n  }\n  return data;\n};\n\nexport const canvasToBlob = async (\n  canvas: HTMLCanvasElement,\n): Promise<Blob> => {\n  return new Promise((resolve, reject) => {\n    try {\n      canvas.toBlob((blob) => {\n        if (!blob) {\n          return reject(\n            new CanvasError(\n              t(\"canvasError.canvasTooBig\"),\n              \"CANVAS_POSSIBLY_TOO_BIG\",\n            ),\n          );\n        }\n        resolve(blob);\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n","import { fileOpen, fileSave } from \"browser-fs-access\";\nimport { cleanAppStateForExport } from \"../appState\";\nimport { EXPORT_DATA_TYPES, EXPORT_SOURCE, MIME_TYPES } from \"../constants\";\nimport { clearElementsForExport } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { loadFromBlob } from \"./blob\";\n\nimport {\n  ExportedDataState,\n  ImportedDataState,\n  ExportedLibraryData,\n} from \"./types\";\nimport Library from \"./library\";\n\nexport const serializeAsJSON = (\n  elements: readonly ExcalidrawElement[],\n  appState: Partial<AppState>,\n): string => {\n  const data: ExportedDataState = {\n    type: EXPORT_DATA_TYPES.excalidraw,\n    version: 2,\n    source: EXPORT_SOURCE,\n    elements: clearElementsForExport(elements),\n    appState: cleanAppStateForExport(appState),\n  };\n\n  return JSON.stringify(data, null, 2);\n};\n\nexport const saveAsJSON = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const serialized = serializeAsJSON(elements, appState);\n  const blob = new Blob([serialized], {\n    type: MIME_TYPES.excalidraw,\n  });\n\n  const fileHandle = await fileSave(\n    blob,\n    {\n      fileName: `${appState.name}.excalidraw`,\n      description: \"Excalidraw file\",\n      extensions: [\".excalidraw\"],\n    },\n    appState.fileHandle,\n  );\n  return { fileHandle };\n};\n\nexport const loadFromJSON = async (\n  localAppState: AppState,\n  localElements: readonly ExcalidrawElement[] | null,\n) => {\n  const blob = await fileOpen({\n    description: \"Excalidraw files\",\n    // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442\n    // gets resolved. Else, iOS users cannot open `.excalidraw` files.\n    /*\n    extensions: [\".json\", \".excalidraw\", \".png\", \".svg\"],\n    mimeTypes: [\n      MIME_TYPES.excalidraw,\n      \"application/json\",\n      \"image/png\",\n      \"image/svg+xml\",\n    ],\n    */\n  });\n  return loadFromBlob(blob, localAppState, localElements);\n};\n\nexport const isValidExcalidrawData = (data?: {\n  type?: any;\n  elements?: any;\n  appState?: any;\n}): data is ImportedDataState => {\n  return (\n    data?.type === EXPORT_DATA_TYPES.excalidraw &&\n    (!data.elements ||\n      (Array.isArray(data.elements) &&\n        (!data.appState || typeof data.appState === \"object\")))\n  );\n};\n\nexport const isValidLibrary = (json: any) => {\n  return (\n    typeof json === \"object\" &&\n    json &&\n    json.type === EXPORT_DATA_TYPES.excalidrawLibrary &&\n    json.version === 1\n  );\n};\n\nexport const saveLibraryAsJSON = async (library: Library) => {\n  const libraryItems = await library.loadLibrary();\n  const data: ExportedLibraryData = {\n    type: EXPORT_DATA_TYPES.excalidrawLibrary,\n    version: 1,\n    source: EXPORT_SOURCE,\n    library: libraryItems,\n  };\n  const serialized = JSON.stringify(data, null, 2);\n  const fileName = \"library.excalidrawlib\";\n  const blob = new Blob([serialized], {\n    type: MIME_TYPES.excalidrawlib,\n  });\n  await fileSave(blob, {\n    fileName,\n    description: \"Excalidraw library file\",\n    extensions: [\".excalidrawlib\"],\n  });\n};\n\nexport const importLibraryFromJSON = async (library: Library) => {\n  const blob = await fileOpen({\n    description: \"Excalidraw library files\",\n    // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442\n    // gets resolved. Else, iOS users cannot open `.excalidraw` files.\n    /*\n    extensions: [\".json\", \".excalidrawlib\"],\n    */\n  });\n  await library.importLibrary(blob);\n};\n","import rough from \"roughjs/bin/rough\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds } from \"../element/bounds\";\nimport { renderScene, renderSceneToSvg } from \"../renderer/renderScene\";\nimport { distance, SVG_NS } from \"../utils\";\nimport { AppState } from \"../types\";\nimport { DEFAULT_EXPORT_PADDING, THEME_FILTER } from \"../constants\";\nimport { getDefaultAppState } from \"../appState\";\nimport { serializeAsJSON } from \"../data/json\";\n\nexport const SVG_EXPORT_TAG = `<!-- svg-source:excalidraw -->`;\n\nexport const exportToCanvas = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  {\n    exportBackground,\n    exportPadding = DEFAULT_EXPORT_PADDING,\n    viewBackgroundColor,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n  },\n  createCanvas: (\n    width: number,\n    height: number,\n  ) => { canvas: HTMLCanvasElement; scale: number } = (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width * appState.exportScale;\n    canvas.height = height * appState.exportScale;\n    return { canvas, scale: appState.exportScale };\n  },\n) => {\n  const [minX, minY, width, height] = getCanvasSize(elements, exportPadding);\n\n  const { canvas, scale = 1 } = createCanvas(width, height);\n\n  renderScene(\n    elements,\n    appState,\n    null,\n    scale,\n    rough.canvas(canvas),\n    canvas,\n    {\n      viewBackgroundColor: exportBackground ? viewBackgroundColor : null,\n      exportWithDarkMode: appState.exportWithDarkMode,\n      scrollX: -minX + exportPadding,\n      scrollY: -minY + exportPadding,\n      zoom: getDefaultAppState().zoom,\n      remotePointerViewportCoords: {},\n      remoteSelectedElementIds: {},\n      shouldCacheIgnoreZoom: false,\n      remotePointerUsernames: {},\n      remotePointerUserStates: {},\n    },\n    {\n      renderScrollbars: false,\n      renderSelection: false,\n      renderOptimizations: false,\n      renderGrid: false,\n    },\n  );\n\n  return canvas;\n};\n\nexport const exportToSvg = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    exportScale?: number;\n    viewBackgroundColor: string;\n    exportWithDarkMode?: boolean;\n    exportEmbedScene?: boolean;\n  },\n): Promise<SVGSVGElement> => {\n  const {\n    exportPadding = DEFAULT_EXPORT_PADDING,\n    viewBackgroundColor,\n    exportScale = 1,\n    exportEmbedScene,\n  } = appState;\n  let metadata = \"\";\n  if (exportEmbedScene) {\n    try {\n      metadata = await (\n        await import(/* webpackChunkName: \"image\" */ \"../../src/data/image\")\n      ).encodeSvgMetadata({\n        text: serializeAsJSON(elements, appState),\n      });\n    } catch (err) {\n      console.error(err);\n    }\n  }\n  const [minX, minY, width, height] = getCanvasSize(elements, exportPadding);\n\n  // initialze SVG root\n  const svgRoot = document.createElementNS(SVG_NS, \"svg\");\n  svgRoot.setAttribute(\"version\", \"1.1\");\n  svgRoot.setAttribute(\"xmlns\", SVG_NS);\n  svgRoot.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n  svgRoot.setAttribute(\"width\", `${width * exportScale}`);\n  svgRoot.setAttribute(\"height\", `${height * exportScale}`);\n  if (appState.exportWithDarkMode) {\n    svgRoot.setAttribute(\"filter\", THEME_FILTER);\n  }\n\n  svgRoot.innerHTML = `\n  ${SVG_EXPORT_TAG}\n  ${metadata}\n  <defs>\n    <style>\n      @font-face {\n        font-family: \"Virgil\";\n        src: url(\"https://excalidraw.com/Virgil.woff2\");\n      }\n      @font-face {\n        font-family: \"Cascadia\";\n        src: url(\"https://excalidraw.com/Cascadia.woff2\");\n      }\n    </style>\n  </defs>\n  `;\n\n  // render background rect\n  if (appState.exportBackground && viewBackgroundColor) {\n    const rect = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"rect\");\n    rect.setAttribute(\"x\", \"0\");\n    rect.setAttribute(\"y\", \"0\");\n    rect.setAttribute(\"width\", `${width}`);\n    rect.setAttribute(\"height\", `${height}`);\n    rect.setAttribute(\"fill\", viewBackgroundColor);\n    svgRoot.appendChild(rect);\n  }\n\n  const rsvg = rough.svg(svgRoot);\n  renderSceneToSvg(elements, rsvg, svgRoot, {\n    offsetX: -minX + exportPadding,\n    offsetY: -minY + exportPadding,\n  });\n\n  return svgRoot;\n};\n\n// calculate smallest area to fit the contents in\nconst getCanvasSize = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  exportPadding: number,\n): [number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  const width = distance(minX, maxX) + exportPadding * 2;\n  const height = distance(minY, maxY) + exportPadding + exportPadding;\n\n  return [minX, minY, width, height];\n};\n\nexport const getExportSize = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  exportPadding: number,\n  scale: number,\n): [number, number] => {\n  const [, , width, height] = getCanvasSize(\n    elements,\n    exportPadding,\n  ).map((dimension) => Math.trunc(dimension * scale));\n\n  return [width, height];\n};\n","import colors from \"./colors\";\nimport { DEFAULT_FONT_FAMILY, DEFAULT_FONT_SIZE, ENV } from \"./constants\";\nimport { newElement, newLinearElement, newTextElement } from \"./element\";\nimport { NonDeletedExcalidrawElement } from \"./element/types\";\nimport { randomId } from \"./random\";\n\nexport type ChartElements = readonly NonDeletedExcalidrawElement[];\n\nconst BAR_WIDTH = 32;\nconst BAR_GAP = 12;\nconst BAR_HEIGHT = 256;\nconst GRID_OPACITY = 50;\n\nexport interface Spreadsheet {\n  title: string | null;\n  labels: string[] | null;\n  values: number[];\n}\n\nexport const NOT_SPREADSHEET = \"NOT_SPREADSHEET\";\nexport const VALID_SPREADSHEET = \"VALID_SPREADSHEET\";\n\ntype ParseSpreadsheetResult =\n  | { type: typeof NOT_SPREADSHEET; reason: string }\n  | { type: typeof VALID_SPREADSHEET; spreadsheet: Spreadsheet };\n\nconst tryParseNumber = (s: string): number | null => {\n  const match = /^[$€£¥₩]?([0-9,]+(\\.[0-9]+)?)$/.exec(s);\n  if (!match) {\n    return null;\n  }\n  return parseFloat(match[1].replace(/,/g, \"\"));\n};\n\nconst isNumericColumn = (lines: string[][], columnIndex: number) =>\n  lines.slice(1).every((line) => tryParseNumber(line[columnIndex]) !== null);\n\nconst tryParseCells = (cells: string[][]): ParseSpreadsheetResult => {\n  const numCols = cells[0].length;\n\n  if (numCols > 2) {\n    return { type: NOT_SPREADSHEET, reason: \"More than 2 columns\" };\n  }\n\n  if (numCols === 1) {\n    if (!isNumericColumn(cells, 0)) {\n      return { type: NOT_SPREADSHEET, reason: \"Value is not numeric\" };\n    }\n\n    const hasHeader = tryParseNumber(cells[0][0]) === null;\n    const values = (hasHeader ? cells.slice(1) : cells).map((line) =>\n      tryParseNumber(line[0]),\n    );\n\n    if (values.length < 2) {\n      return { type: NOT_SPREADSHEET, reason: \"Less than two rows\" };\n    }\n\n    return {\n      type: VALID_SPREADSHEET,\n      spreadsheet: {\n        title: hasHeader ? cells[0][0] : null,\n        labels: null,\n        values: values as number[],\n      },\n    };\n  }\n\n  const valueColumnIndex = isNumericColumn(cells, 0) ? 0 : 1;\n\n  if (!isNumericColumn(cells, valueColumnIndex)) {\n    return { type: NOT_SPREADSHEET, reason: \"Value is not numeric\" };\n  }\n\n  const labelColumnIndex = (valueColumnIndex + 1) % 2;\n  const hasHeader = tryParseNumber(cells[0][valueColumnIndex]) === null;\n  const rows = hasHeader ? cells.slice(1) : cells;\n\n  if (rows.length < 2) {\n    return { type: NOT_SPREADSHEET, reason: \"Less than 2 rows\" };\n  }\n\n  return {\n    type: VALID_SPREADSHEET,\n    spreadsheet: {\n      title: hasHeader ? cells[0][valueColumnIndex] : null,\n      labels: rows.map((row) => row[labelColumnIndex]),\n      values: rows.map((row) => tryParseNumber(row[valueColumnIndex])!),\n    },\n  };\n};\n\nconst transposeCells = (cells: string[][]) => {\n  const nextCells: string[][] = [];\n  for (let col = 0; col < cells[0].length; col++) {\n    const nextCellRow: string[] = [];\n    for (let row = 0; row < cells.length; row++) {\n      nextCellRow.push(cells[row][col]);\n    }\n    nextCells.push(nextCellRow);\n  }\n  return nextCells;\n};\n\nexport const tryParseSpreadsheet = (text: string): ParseSpreadsheetResult => {\n  // Copy/paste from excel, spreadhseets, tsv, csv.\n  // For now we only accept 2 columns with an optional header\n\n  // Check for tab separated values\n  let lines = text\n    .trim()\n    .split(\"\\n\")\n    .map((line) => line.trim().split(\"\\t\"));\n\n  // Check for comma separated files\n  if (lines.length && lines[0].length !== 2) {\n    lines = text\n      .trim()\n      .split(\"\\n\")\n      .map((line) => line.trim().split(\",\"));\n  }\n\n  if (lines.length === 0) {\n    return { type: NOT_SPREADSHEET, reason: \"No values\" };\n  }\n\n  const numColsFirstLine = lines[0].length;\n  const isSpreadsheet = lines.every((line) => line.length === numColsFirstLine);\n\n  if (!isSpreadsheet) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"All rows don't have same number of columns\",\n    };\n  }\n\n  const result = tryParseCells(lines);\n  if (result.type !== VALID_SPREADSHEET) {\n    const transposedResults = tryParseCells(transposeCells(lines));\n    if (transposedResults.type === VALID_SPREADSHEET) {\n      return transposedResults;\n    }\n  }\n  return result;\n};\n\nconst bgColors = colors.elementBackground.slice(\n  2,\n  colors.elementBackground.length,\n);\n\n// Put all the common properties here so when the whole chart is selected\n// the properties dialog shows the correct selected values\nconst commonProps = {\n  fillStyle: \"hachure\",\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontSize: DEFAULT_FONT_SIZE,\n  opacity: 100,\n  roughness: 1,\n  strokeColor: colors.elementStroke[0],\n  strokeSharpness: \"sharp\",\n  strokeStyle: \"solid\",\n  strokeWidth: 1,\n  verticalAlign: \"middle\",\n} as const;\n\nconst getChartDimentions = (spreadsheet: Spreadsheet) => {\n  const chartWidth =\n    (BAR_WIDTH + BAR_GAP) * spreadsheet.values.length + BAR_GAP;\n  const chartHeight = BAR_HEIGHT + BAR_GAP * 2;\n  return { chartWidth, chartHeight };\n};\n\nconst chartXLabels = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  return (\n    spreadsheet.labels?.map((label, index) => {\n      return newTextElement({\n        groupIds: [groupId],\n        backgroundColor,\n        ...commonProps,\n        text: label.length > 8 ? `${label.slice(0, 5)}...` : label,\n        x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP * 2,\n        y: y + BAR_GAP / 2,\n        width: BAR_WIDTH,\n        angle: 5.87,\n        fontSize: 16,\n        textAlign: \"center\",\n        verticalAlign: \"top\",\n      });\n    }) || []\n  );\n};\n\nconst chartYLabels = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  const minYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_GAP,\n    text: \"0\",\n    textAlign: \"right\",\n  });\n\n  const maxYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_HEIGHT - minYLabel.height / 2,\n    text: Math.max(...spreadsheet.values).toLocaleString(),\n    textAlign: \"right\",\n  });\n\n  return [minYLabel, maxYLabel];\n};\n\nconst chartLines = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  const { chartWidth, chartHeight } = getChartDimentions(spreadsheet);\n  const xLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    width: chartWidth,\n    points: [\n      [0, 0],\n      [chartWidth, 0],\n    ],\n  });\n\n  const yLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: chartHeight,\n    points: [\n      [0, 0],\n      [0, -chartHeight],\n    ],\n  });\n\n  const maxLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y: y - BAR_HEIGHT - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    strokeStyle: \"dotted\",\n    width: chartWidth,\n    opacity: GRID_OPACITY,\n    points: [\n      [0, 0],\n      [chartWidth, 0],\n    ],\n  });\n\n  return [xLine, yLine, maxLine];\n};\n\n// For the maths behind it https://excalidraw.com/#json=6320864370884608,O_5xfD-Agh32tytHpRJx1g\nconst chartBaseElements = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n  debug?: boolean,\n): ChartElements => {\n  const { chartWidth, chartHeight } = getChartDimentions(spreadsheet);\n\n  const title = spreadsheet.title\n    ? newTextElement({\n        backgroundColor,\n        groupIds: [groupId],\n        ...commonProps,\n        text: spreadsheet.title,\n        x: x + chartWidth / 2,\n        y: y - BAR_HEIGHT - BAR_GAP * 2 - DEFAULT_FONT_SIZE,\n        strokeSharpness: \"sharp\",\n        strokeStyle: \"solid\",\n        textAlign: \"center\",\n      })\n    : null;\n\n  const debugRect = debug\n    ? newElement({\n        backgroundColor,\n        groupIds: [groupId],\n        ...commonProps,\n        type: \"rectangle\",\n        x,\n        y: y - chartHeight,\n        width: chartWidth,\n        height: chartHeight,\n        strokeColor: colors.elementStroke[0],\n        fillStyle: \"solid\",\n        opacity: 6,\n      })\n    : null;\n\n  return [\n    ...(debugRect ? [debugRect] : []),\n    ...(title ? [title] : []),\n    ...chartXLabels(spreadsheet, x, y, groupId, backgroundColor),\n    ...chartYLabels(spreadsheet, x, y, groupId, backgroundColor),\n    ...chartLines(spreadsheet, x, y, groupId, backgroundColor),\n  ];\n};\n\nconst chartTypeBar = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n\n  const bars = spreadsheet.values.map((value, index) => {\n    const barHeight = (value / max) * BAR_HEIGHT;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"rectangle\",\n      x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP,\n      y: y - barHeight - BAR_GAP,\n      width: BAR_WIDTH,\n      height: barHeight,\n    });\n  });\n\n  return [\n    ...bars,\n    ...chartBaseElements(\n      spreadsheet,\n      x,\n      y,\n      groupId,\n      backgroundColor,\n      process.env.NODE_ENV === ENV.DEVELOPMENT,\n    ),\n  ];\n};\n\nconst chartTypeLine = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n\n  let index = 0;\n  const points = [];\n  for (const value of spreadsheet.values) {\n    const cx = index * (BAR_WIDTH + BAR_GAP);\n    const cy = -(value / max) * BAR_HEIGHT;\n    points.push([cx, cy]);\n    index++;\n  }\n\n  const maxX = Math.max(...points.map((element) => element[0]));\n  const maxY = Math.max(...points.map((element) => element[1]));\n  const minX = Math.min(...points.map((element) => element[0]));\n  const minY = Math.min(...points.map((element) => element[1]));\n\n  const line = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x: x + BAR_GAP + BAR_WIDTH / 2,\n    y: y - BAR_GAP,\n    startArrowhead: null,\n    endArrowhead: null,\n    height: maxY - minY,\n    width: maxX - minX,\n    strokeWidth: 2,\n    points: points as any,\n  });\n\n  const dots = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = -(value / max) * BAR_HEIGHT + BAR_GAP / 2;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      fillStyle: \"solid\",\n      strokeWidth: 2,\n      type: \"ellipse\",\n      x: x + cx + BAR_WIDTH / 2,\n      y: y + cy - BAR_GAP * 2,\n      width: BAR_GAP,\n      height: BAR_GAP,\n    });\n  });\n\n  const lines = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = (value / max) * BAR_HEIGHT + BAR_GAP / 2 + BAR_GAP;\n    return newLinearElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"line\",\n      x: x + cx + BAR_WIDTH / 2 + BAR_GAP / 2,\n      y: y - cy,\n      startArrowhead: null,\n      endArrowhead: null,\n      height: cy,\n      strokeStyle: \"dotted\",\n      opacity: GRID_OPACITY,\n      points: [\n        [0, 0],\n        [0, cy],\n      ],\n    });\n  });\n\n  return [\n    ...chartBaseElements(\n      spreadsheet,\n      x,\n      y,\n      groupId,\n      backgroundColor,\n      process.env.NODE_ENV === ENV.DEVELOPMENT,\n    ),\n    line,\n    ...lines,\n    ...dots,\n  ];\n};\n\nexport const renderSpreadsheet = (\n  chartType: string,\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  if (chartType === \"line\") {\n    return chartTypeLine(spreadsheet, x, y);\n  }\n  return chartTypeBar(spreadsheet, x, y);\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./element/types\";\nimport { getSelectedElements } from \"./scene\";\nimport { AppState } from \"./types\";\nimport { SVG_EXPORT_TAG } from \"./scene/export\";\nimport { tryParseSpreadsheet, Spreadsheet, VALID_SPREADSHEET } from \"./charts\";\nimport { EXPORT_DATA_TYPES } from \"./constants\";\n\ntype ElementsClipboard = {\n  type: typeof EXPORT_DATA_TYPES.excalidrawClipboard;\n  elements: ExcalidrawElement[];\n};\n\nexport interface ClipboardData {\n  spreadsheet?: Spreadsheet;\n  elements?: readonly ExcalidrawElement[];\n  text?: string;\n  errorMessage?: string;\n}\n\nlet CLIPBOARD = \"\";\nlet PREFER_APP_CLIPBOARD = false;\n\nexport const probablySupportsClipboardReadText =\n  \"clipboard\" in navigator && \"readText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardWriteText =\n  \"clipboard\" in navigator && \"writeText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardBlob =\n  \"clipboard\" in navigator &&\n  \"write\" in navigator.clipboard &&\n  \"ClipboardItem\" in window &&\n  \"toBlob\" in HTMLCanvasElement.prototype;\n\nconst clipboardContainsElements = (\n  contents: any,\n): contents is { elements: ExcalidrawElement[] } => {\n  if (\n    [\n      EXPORT_DATA_TYPES.excalidraw,\n      EXPORT_DATA_TYPES.excalidrawClipboard,\n    ].includes(contents?.type) &&\n    Array.isArray(contents.elements)\n  ) {\n    return true;\n  }\n  return false;\n};\n\nexport const copyToClipboard = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  const contents: ElementsClipboard = {\n    type: EXPORT_DATA_TYPES.excalidrawClipboard,\n    elements: getSelectedElements(elements, appState),\n  };\n  const json = JSON.stringify(contents);\n  CLIPBOARD = json;\n  try {\n    PREFER_APP_CLIPBOARD = false;\n    await copyTextToSystemClipboard(json);\n  } catch (error) {\n    PREFER_APP_CLIPBOARD = true;\n    console.error(error);\n  }\n};\n\nconst getAppClipboard = (): Partial<ElementsClipboard> => {\n  if (!CLIPBOARD) {\n    return {};\n  }\n\n  try {\n    return JSON.parse(CLIPBOARD);\n  } catch (error) {\n    console.error(error);\n    return {};\n  }\n};\n\nconst parsePotentialSpreadsheet = (\n  text: string,\n): { spreadsheet: Spreadsheet } | { errorMessage: string } | null => {\n  const result = tryParseSpreadsheet(text);\n  if (result.type === VALID_SPREADSHEET) {\n    return { spreadsheet: result.spreadsheet };\n  }\n  return null;\n};\n\n/**\n * Retrieves content from system clipboard (either from ClipboardEvent or\n *  via async clipboard API if supported)\n */\nconst getSystemClipboard = async (\n  event: ClipboardEvent | null,\n): Promise<string> => {\n  try {\n    const text = event\n      ? event.clipboardData?.getData(\"text/plain\").trim()\n      : probablySupportsClipboardReadText &&\n        (await navigator.clipboard.readText());\n\n    return text || \"\";\n  } catch {\n    return \"\";\n  }\n};\n\n/**\n * Attemps to parse clipboard. Prefers system clipboard.\n */\nexport const parseClipboard = async (\n  event: ClipboardEvent | null,\n): Promise<ClipboardData> => {\n  const systemClipboard = await getSystemClipboard(event);\n\n  // if system clipboard empty, couldn't be resolved, or contains previously\n  // copied excalidraw scene as SVG, fall back to previously copied excalidraw\n  // elements\n  if (!systemClipboard || systemClipboard.includes(SVG_EXPORT_TAG)) {\n    return getAppClipboard();\n  }\n\n  // if system clipboard contains spreadsheet, use it even though it's\n  // technically possible it's staler than in-app clipboard\n  const spreadsheetResult = parsePotentialSpreadsheet(systemClipboard);\n  if (spreadsheetResult) {\n    return spreadsheetResult;\n  }\n\n  const appClipboardData = getAppClipboard();\n\n  try {\n    const systemClipboardData = JSON.parse(systemClipboard);\n    if (clipboardContainsElements(systemClipboardData)) {\n      return { elements: systemClipboardData.elements };\n    }\n    return appClipboardData;\n  } catch {\n    // system clipboard doesn't contain excalidraw elements → return plaintext\n    // unless we set a flag to prefer in-app clipboard because browser didn't\n    // support storing to system clipboard on copy\n    return PREFER_APP_CLIPBOARD && appClipboardData.elements\n      ? appClipboardData\n      : { text: systemClipboard };\n  }\n};\n\nexport const copyBlobToClipboardAsPng = async (blob: Blob) => {\n  await navigator.clipboard.write([\n    new window.ClipboardItem({ \"image/png\": blob }),\n  ]);\n};\n\nexport const copyTextToSystemClipboard = async (text: string | null) => {\n  let copied = false;\n  if (probablySupportsClipboardWriteText) {\n    try {\n      // NOTE: doesn't work on FF on non-HTTPS domains, or when document\n      // not focused\n      await navigator.clipboard.writeText(text || \"\");\n      copied = true;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  // Note that execCommand doesn't allow copying empty strings, so if we're\n  // clearing clipboard using this API, we must copy at least an empty char\n  if (!copied && !copyTextViaExecCommand(text || \" \")) {\n    throw new Error(\"couldn't copy\");\n  }\n};\n\n// adapted from https://github.com/zenorocha/clipboard.js/blob/ce79f170aa655c408b6aab33c9472e8e4fa52e19/src/clipboard-action.js#L48\nconst copyTextViaExecCommand = (text: string) => {\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const textarea = document.createElement(\"textarea\");\n\n  textarea.style.border = \"0\";\n  textarea.style.padding = \"0\";\n  textarea.style.margin = \"0\";\n  textarea.style.position = \"absolute\";\n  textarea.style[isRTL ? \"right\" : \"left\"] = \"-9999px\";\n  const yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  textarea.style.top = `${yPosition}px`;\n  // Prevent zooming on iOS\n  textarea.style.fontSize = \"12pt\";\n\n  textarea.setAttribute(\"readonly\", \"\");\n  textarea.value = text;\n\n  document.body.appendChild(textarea);\n\n  let success = false;\n\n  try {\n    textarea.select();\n    textarea.setSelectionRange(0, textarea.value.length);\n\n    success = document.execCommand(\"copy\");\n  } catch (error) {\n    console.error(error);\n  }\n\n  textarea.remove();\n\n  return success;\n};\n","import { fileSave } from \"browser-fs-access\";\nimport {\n  copyBlobToClipboardAsPng,\n  copyTextToSystemClipboard,\n} from \"../clipboard\";\nimport { DEFAULT_EXPORT_PADDING } from \"../constants\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { exportToCanvas, exportToSvg } from \"../scene/export\";\nimport { ExportType } from \"../scene/types\";\nimport { AppState } from \"../types\";\nimport { canvasToBlob } from \"./blob\";\nimport { serializeAsJSON } from \"./json\";\n\nexport { loadFromBlob } from \"./blob\";\nexport { loadFromJSON, saveAsJSON } from \"./json\";\n\nexport const exportCanvas = async (\n  type: ExportType,\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  {\n    exportBackground,\n    exportPadding = DEFAULT_EXPORT_PADDING,\n    viewBackgroundColor,\n    name,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n    name: string;\n  },\n) => {\n  if (elements.length === 0) {\n    throw new Error(t(\"alerts.cannotExportEmptyCanvas\"));\n  }\n  if (type === \"svg\" || type === \"clipboard-svg\") {\n    const tempSvg = await exportToSvg(elements, {\n      exportBackground,\n      exportWithDarkMode: appState.exportWithDarkMode,\n      viewBackgroundColor,\n      exportPadding,\n      exportScale: appState.exportScale,\n      exportEmbedScene: appState.exportEmbedScene && type === \"svg\",\n    });\n    if (type === \"svg\") {\n      await fileSave(new Blob([tempSvg.outerHTML], { type: \"image/svg+xml\" }), {\n        fileName: `${name}.svg`,\n        extensions: [\".svg\"],\n      });\n      return;\n    } else if (type === \"clipboard-svg\") {\n      await copyTextToSystemClipboard(tempSvg.outerHTML);\n      return;\n    }\n  }\n\n  const tempCanvas = exportToCanvas(elements, appState, {\n    exportBackground,\n    viewBackgroundColor,\n    exportPadding,\n  });\n  tempCanvas.style.display = \"none\";\n  document.body.appendChild(tempCanvas);\n  let blob = await canvasToBlob(tempCanvas);\n  tempCanvas.remove();\n\n  if (type === \"png\") {\n    const fileName = `${name}.png`;\n    if (appState.exportEmbedScene) {\n      blob = await (\n        await import(/* webpackChunkName: \"image\" */ \"./image\")\n      ).encodePngMetadata({\n        blob,\n        metadata: serializeAsJSON(elements, appState),\n      });\n    }\n\n    await fileSave(blob, {\n      fileName,\n      extensions: [\".png\"],\n    });\n  } else if (type === \"clipboard\") {\n    try {\n      await copyBlobToClipboardAsPng(blob);\n    } catch (error) {\n      if (error.name === \"CANVAS_POSSIBLY_TOO_BIG\") {\n        throw error;\n      }\n      throw new Error(t(\"alerts.couldNotCopyToClipboard\"));\n    }\n  }\n};\n","import React from \"react\";\nimport clsx from \"clsx\";\nimport { checkIcon } from \"./icons\";\n\nimport \"./CheckboxItem.scss\";\n\nexport const CheckboxItem: React.FC<{\n  checked: boolean;\n  onChange: (checked: boolean) => void;\n}> = ({ children, checked, onChange }) => {\n  return (\n    <div\n      className={clsx(\"Checkbox\", { \"is-checked\": checked })}\n      onClick={(event) => {\n        onChange(!checked);\n        ((event.currentTarget as HTMLDivElement).querySelector(\n          \".Checkbox-box\",\n        ) as HTMLButtonElement).focus();\n      }}\n    >\n      <button className=\"Checkbox-box\" role=\"checkbox\" aria-checked={checked}>\n        {checkIcon}\n      </button>\n      <div className=\"Checkbox-label\">{children}</div>\n    </div>\n  );\n};\n","import \"./Stack.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype StackProps = {\n  children: React.ReactNode;\n  gap?: number;\n  align?: \"start\" | \"center\" | \"end\" | \"baseline\";\n  justifyContent?: \"center\" | \"space-around\" | \"space-between\";\n  className?: string | boolean;\n  style?: React.CSSProperties;\n};\n\nconst RowStack = ({\n  children,\n  gap,\n  align,\n  justifyContent,\n  className,\n  style,\n}: StackProps) => {\n  return (\n    <div\n      className={clsx(\"Stack Stack_horizontal\", className)}\n      style={{\n        \"--gap\": gap,\n        alignItems: align,\n        justifyContent,\n        ...style,\n      }}\n    >\n      {children}\n    </div>\n  );\n};\n\nconst ColStack = ({\n  children,\n  gap,\n  align,\n  justifyContent,\n  className,\n}: StackProps) => {\n  return (\n    <div\n      className={clsx(\"Stack Stack_vertical\", className)}\n      style={{\n        \"--gap\": gap,\n        justifyItems: align,\n        justifyContent,\n      }}\n    >\n      {children}\n    </div>\n  );\n};\n\nexport default {\n  Row: RowStack,\n  Col: ColStack,\n};\n","import React from \"react\";\nimport Stack from \"../components/Stack\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { save, file } from \"../components/icons\";\nimport { t } from \"../i18n\";\n\nimport \"./ActiveFile.scss\";\n\ntype ActiveFileProps = {\n  fileName?: string;\n  onSave: () => void;\n};\n\nexport const ActiveFile = ({ fileName, onSave }: ActiveFileProps) => (\n  <Stack.Row className=\"ActiveFile\" gap={1} align=\"center\">\n    <span className=\"ActiveFile__fileName\">\n      {file}\n      <span>{fileName}</span>\n    </span>\n    <ToolButton\n      type=\"icon\"\n      icon={save}\n      title={t(\"buttons.save\")}\n      aria-label={t(\"buttons.save\")}\n      onClick={onSave}\n      data-testid=\"save-button\"\n    />\n  </Stack.Row>\n);\n","import React from \"react\";\nimport { trackEvent } from \"../analytics\";\nimport { load, questionCircle, saveAs } from \"../components/icons\";\nimport { ProjectName } from \"../components/ProjectName\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport \"../components/ToolIcon.scss\";\nimport { Tooltip } from \"../components/Tooltip\";\nimport { DarkModeToggle, Appearence } from \"../components/DarkModeToggle\";\nimport { loadFromJSON, saveAsJSON } from \"../data\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport { KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { supported as fsSupported } from \"browser-fs-access\";\nimport { CheckboxItem } from \"../components/CheckboxItem\";\nimport { getExportSize } from \"../scene/export\";\nimport { DEFAULT_EXPORT_PADDING, EXPORT_SCALES } from \"../constants\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { getNonDeletedElements } from \"../element\";\nimport { ActiveFile } from \"../components/ActiveFile\";\n\nexport const actionChangeProjectName = register({\n  name: \"changeProjectName\",\n  perform: (_elements, appState, value) => {\n    trackEvent(\"change\", \"title\");\n    return { appState: { ...appState, name: value }, commitToHistory: false };\n  },\n  PanelComponent: ({ appState, updateData, appProps }) => (\n    <ProjectName\n      label={t(\"labels.fileTitle\")}\n      value={appState.name || \"Unnamed\"}\n      onChange={(name: string) => updateData(name)}\n      isNameEditable={\n        typeof appProps.name === \"undefined\" && !appState.viewModeEnabled\n      }\n    />\n  ),\n});\n\nexport const actionChangeExportScale = register({\n  name: \"changeExportScale\",\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportScale: value },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ elements: allElements, appState, updateData }) => {\n    const elements = getNonDeletedElements(allElements);\n    const exportSelected = isSomeElementSelected(elements, appState);\n    const exportedElements = exportSelected\n      ? getSelectedElements(elements, appState)\n      : elements;\n\n    return (\n      <>\n        {EXPORT_SCALES.map((s) => {\n          const [width, height] = getExportSize(\n            exportedElements,\n            DEFAULT_EXPORT_PADDING,\n            s,\n          );\n\n          const scaleButtonTitle = `${t(\n            \"buttons.scale\",\n          )} ${s}x (${width}x${height})`;\n\n          return (\n            <ToolButton\n              key={s}\n              size=\"s\"\n              type=\"radio\"\n              icon={`${s}x`}\n              name=\"export-canvas-scale\"\n              title={scaleButtonTitle}\n              aria-label={scaleButtonTitle}\n              id=\"export-canvas-scale\"\n              checked={s === appState.exportScale}\n              onChange={() => updateData(s)}\n            />\n          );\n        })}\n      </>\n    );\n  },\n});\n\nexport const actionChangeExportBackground = register({\n  name: \"changeExportBackground\",\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportBackground: value },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <CheckboxItem\n      checked={appState.exportBackground}\n      onChange={(checked) => updateData(checked)}\n    >\n      {t(\"labels.withBackground\")}\n    </CheckboxItem>\n  ),\n});\n\nexport const actionChangeExportEmbedScene = register({\n  name: \"changeExportEmbedScene\",\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportEmbedScene: value },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <CheckboxItem\n      checked={appState.exportEmbedScene}\n      onChange={(checked) => updateData(checked)}\n    >\n      {t(\"labels.exportEmbedScene\")}\n      <Tooltip label={t(\"labels.exportEmbedScene_details\")} long={true}>\n        <div className=\"Tooltip-icon\">{questionCircle}</div>\n      </Tooltip>\n    </CheckboxItem>\n  ),\n});\n\nexport const actionSaveToActiveFile = register({\n  name: \"saveToActiveFile\",\n  perform: async (elements, appState, value) => {\n    const fileHandleExists = !!appState.fileHandle;\n    try {\n      const { fileHandle } = await saveAsJSON(elements, appState);\n      return {\n        commitToHistory: false,\n        appState: {\n          ...appState,\n          fileHandle,\n          toastMessage: fileHandleExists\n            ? fileHandle.name\n              ? t(\"toast.fileSavedToFilename\").replace(\n                  \"{filename}\",\n                  `\"${fileHandle.name}\"`,\n                )\n              : t(\"toast.fileSaved\")\n            : null,\n        },\n      };\n    } catch (error) {\n      if (error?.name !== \"AbortError\") {\n        console.error(error);\n      }\n      return { commitToHistory: false };\n    }\n  },\n  keyTest: (event) =>\n    event.key === KEYS.S && event[KEYS.CTRL_OR_CMD] && !event.shiftKey,\n  PanelComponent: ({ updateData, appState }) => (\n    <ActiveFile\n      onSave={() => updateData(null)}\n      fileName={appState.fileHandle?.name}\n    />\n  ),\n});\n\nexport const actionSaveFileToDisk = register({\n  name: \"saveFileToDisk\",\n  perform: async (elements, appState, value) => {\n    try {\n      const { fileHandle } = await saveAsJSON(elements, {\n        ...appState,\n        fileHandle: null,\n      });\n      return { commitToHistory: false, appState: { ...appState, fileHandle } };\n    } catch (error) {\n      if (error?.name !== \"AbortError\") {\n        console.error(error);\n      }\n      return { commitToHistory: false };\n    }\n  },\n  keyTest: (event) =>\n    event.key === KEYS.S && event.shiftKey && event[KEYS.CTRL_OR_CMD],\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={saveAs}\n      title={t(\"buttons.saveAs\")}\n      aria-label={t(\"buttons.saveAs\")}\n      showAriaLabel={useIsMobile()}\n      hidden={!fsSupported}\n      onClick={() => updateData(null)}\n      data-testid=\"save-as-button\"\n    />\n  ),\n});\n\nexport const actionLoadScene = register({\n  name: \"loadScene\",\n  perform: async (elements, appState) => {\n    try {\n      const {\n        elements: loadedElements,\n        appState: loadedAppState,\n      } = await loadFromJSON(appState, elements);\n      return {\n        elements: loadedElements,\n        appState: loadedAppState,\n        commitToHistory: true,\n      };\n    } catch (error) {\n      if (error?.name === \"AbortError\") {\n        return false;\n      }\n      return {\n        elements,\n        appState: { ...appState, errorMessage: error.message },\n        commitToHistory: false,\n      };\n    }\n  },\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.O,\n  PanelComponent: ({ updateData, appState }) => (\n    <ToolButton\n      type=\"button\"\n      icon={load}\n      title={t(\"buttons.load\")}\n      aria-label={t(\"buttons.load\")}\n      showAriaLabel={useIsMobile()}\n      onClick={updateData}\n      data-testid=\"load-button\"\n    />\n  ),\n});\n\nexport const actionExportWithDarkMode = register({\n  name: \"exportWithDarkMode\",\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportWithDarkMode: value },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <div\n      style={{\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        marginTop: \"-45px\",\n        marginBottom: \"10px\",\n      }}\n    >\n      <DarkModeToggle\n        value={appState.exportWithDarkMode ? \"dark\" : \"light\"}\n        onChange={(theme: Appearence) => {\n          updateData(theme === \"dark\");\n        }}\n        title={t(\"labels.toggleExportColorScheme\")}\n      />\n    </div>\n  ),\n});\n","import {\n  isTextElement,\n  isExcalidrawElement,\n  redrawTextBoundingBox,\n} from \"../element\";\nimport { CODES, KEYS } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { register } from \"./register\";\nimport { mutateElement, newElementWith } from \"../element/mutateElement\";\nimport {\n  DEFAULT_FONT_SIZE,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n} from \"../constants\";\n\n// `copiedStyles` is exported only for tests.\nexport let copiedStyles: string = \"{}\";\n\nexport const actionCopyStyles = register({\n  name: \"copyStyles\",\n  perform: (elements, appState) => {\n    const element = elements.find((el) => appState.selectedElementIds[el.id]);\n    if (element) {\n      copiedStyles = JSON.stringify(element);\n    }\n    return {\n      appState: {\n        ...appState,\n        toastMessage: t(\"toast.copyStyles\"),\n      },\n      commitToHistory: false,\n    };\n  },\n  contextItemLabel: \"labels.copyStyles\",\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.C,\n});\n\nexport const actionPasteStyles = register({\n  name: \"pasteStyles\",\n  perform: (elements, appState) => {\n    const pastedElement = JSON.parse(copiedStyles);\n    if (!isExcalidrawElement(pastedElement)) {\n      return { elements, commitToHistory: false };\n    }\n    return {\n      elements: elements.map((element) => {\n        if (appState.selectedElementIds[element.id]) {\n          const newElement = newElementWith(element, {\n            backgroundColor: pastedElement?.backgroundColor,\n            strokeWidth: pastedElement?.strokeWidth,\n            strokeColor: pastedElement?.strokeColor,\n            strokeStyle: pastedElement?.strokeStyle,\n            fillStyle: pastedElement?.fillStyle,\n            opacity: pastedElement?.opacity,\n            roughness: pastedElement?.roughness,\n          });\n          if (isTextElement(newElement)) {\n            mutateElement(newElement, {\n              fontSize: pastedElement?.fontSize || DEFAULT_FONT_SIZE,\n              fontFamily: pastedElement?.fontFamily || DEFAULT_FONT_FAMILY,\n              textAlign: pastedElement?.textAlign || DEFAULT_TEXT_ALIGN,\n            });\n            redrawTextBoundingBox(newElement);\n          }\n          return newElement;\n        }\n        return element;\n      }),\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.pasteStyles\",\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V,\n});\n","import React from \"react\";\nimport { questionCircle } from \"../components/icons\";\n\ntype HelpIconProps = {\n  title?: string;\n  name?: string;\n  id?: string;\n  onClick?(): void;\n};\n\nexport const HelpIcon = (props: HelpIconProps) => (\n  <button\n    className=\"help-icon\"\n    onClick={props.onClick}\n    type=\"button\"\n    title={`${props.title} — ?`}\n    aria-label={props.title}\n  >\n    {questionCircle}\n  </button>\n);\n","import React from \"react\";\nimport { CODES, KEYS } from \"../keys\";\nimport { t } from \"../i18n\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\nimport { UngroupIcon, GroupIcon } from \"../components/icons\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport {\n  getSelectedGroupIds,\n  selectGroup,\n  selectGroupsForSelectedElements,\n  getElementsInGroup,\n  addToGroup,\n  removeFromSelectedGroups,\n  isElementInGroup,\n} from \"../groups\";\nimport { getNonDeletedElements } from \"../element\";\nimport { randomId } from \"../random\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\n\nconst allElementsInSameGroup = (elements: readonly ExcalidrawElement[]) => {\n  if (elements.length >= 2) {\n    const groupIds = elements[0].groupIds;\n    for (const groupId of groupIds) {\n      if (\n        elements.reduce(\n          (acc, element) => acc && isElementInGroup(element, groupId),\n          true,\n        )\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nconst enableActionGroup = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n  return (\n    selectedElements.length >= 2 && !allElementsInSameGroup(selectedElements)\n  );\n};\n\nexport const actionGroup = register({\n  name: \"group\",\n  perform: (elements, appState) => {\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    if (selectedElements.length < 2) {\n      // nothing to group\n      return { appState, elements, commitToHistory: false };\n    }\n    // if everything is already grouped into 1 group, there is nothing to do\n    const selectedGroupIds = getSelectedGroupIds(appState);\n    if (selectedGroupIds.length === 1) {\n      const selectedGroupId = selectedGroupIds[0];\n      const elementIdsInGroup = new Set(\n        getElementsInGroup(elements, selectedGroupId).map(\n          (element) => element.id,\n        ),\n      );\n      const selectedElementIds = new Set(\n        selectedElements.map((element) => element.id),\n      );\n      const combinedSet = new Set([\n        ...Array.from(elementIdsInGroup),\n        ...Array.from(selectedElementIds),\n      ]);\n      if (combinedSet.size === elementIdsInGroup.size) {\n        // no incremental ids in the selected ids\n        return { appState, elements, commitToHistory: false };\n      }\n    }\n    const newGroupId = randomId();\n    const updatedElements = elements.map((element) => {\n      if (!appState.selectedElementIds[element.id]) {\n        return element;\n      }\n      return newElementWith(element, {\n        groupIds: addToGroup(\n          element.groupIds,\n          newGroupId,\n          appState.editingGroupId,\n        ),\n      });\n    });\n    // keep the z order within the group the same, but move them\n    // to the z order of the highest element in the layer stack\n    const elementsInGroup = getElementsInGroup(updatedElements, newGroupId);\n    const lastElementInGroup = elementsInGroup[elementsInGroup.length - 1];\n    const lastGroupElementIndex = updatedElements.lastIndexOf(\n      lastElementInGroup,\n    );\n    const elementsAfterGroup = updatedElements.slice(lastGroupElementIndex + 1);\n    const elementsBeforeGroup = updatedElements\n      .slice(0, lastGroupElementIndex)\n      .filter(\n        (updatedElement) => !isElementInGroup(updatedElement, newGroupId),\n      );\n    const updatedElementsInOrder = [\n      ...elementsBeforeGroup,\n      ...elementsInGroup,\n      ...elementsAfterGroup,\n    ];\n\n    return {\n      appState: selectGroup(\n        newGroupId,\n        { ...appState, selectedGroupIds: {} },\n        getNonDeletedElements(updatedElementsInOrder),\n      ),\n      elements: updatedElementsInOrder,\n      commitToHistory: true,\n    };\n  },\n  contextItemLabel: \"labels.group\",\n  contextItemPredicate: (elements, appState) =>\n    enableActionGroup(elements, appState),\n  keyTest: (event) =>\n    !event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.code === CODES.G,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<GroupIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.group\")} — ${getShortcutKey(\"CtrlOrCmd+G\")}`}\n      aria-label={t(\"labels.group\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    ></ToolButton>\n  ),\n});\n\nexport const actionUngroup = register({\n  name: \"ungroup\",\n  perform: (elements, appState) => {\n    const groupIds = getSelectedGroupIds(appState);\n    if (groupIds.length === 0) {\n      return { appState, elements, commitToHistory: false };\n    }\n    const nextElements = elements.map((element) => {\n      const nextGroupIds = removeFromSelectedGroups(\n        element.groupIds,\n        appState.selectedGroupIds,\n      );\n      if (nextGroupIds.length === element.groupIds.length) {\n        return element;\n      }\n      return newElementWith(element, {\n        groupIds: nextGroupIds,\n      });\n    });\n    return {\n      appState: selectGroupsForSelectedElements(\n        { ...appState, selectedGroupIds: {} },\n        getNonDeletedElements(nextElements),\n      ),\n      elements: nextElements,\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.code === CODES.G,\n  contextItemLabel: \"labels.ungroup\",\n  contextItemPredicate: (elements, appState) =>\n    getSelectedGroupIds(appState).length > 0,\n\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      hidden={getSelectedGroupIds(appState).length === 0}\n      icon={<UngroupIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.ungroup\")} — ${getShortcutKey(\"CtrlOrCmd+Shift+G\")}`}\n      aria-label={t(\"labels.ungroup\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    ></ToolButton>\n  ),\n});\n","import React from \"react\";\nimport { menu, palette } from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { t } from \"../i18n\";\nimport { showSelectedShapeActions, getNonDeletedElements } from \"../element\";\nimport { register } from \"./register\";\nimport { allowFullScreen, exitFullScreen, isFullScreen } from \"../utils\";\nimport { CODES, KEYS } from \"../keys\";\nimport { HelpIcon } from \"../components/HelpIcon\";\n\nexport const actionToggleCanvasMenu = register({\n  name: \"toggleCanvasMenu\",\n  perform: (_, appState) => ({\n    appState: {\n      ...appState,\n      openMenu: appState.openMenu === \"canvas\" ? null : \"canvas\",\n    },\n    commitToHistory: false,\n  }),\n  PanelComponent: ({ appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={menu}\n      aria-label={t(\"buttons.menu\")}\n      onClick={updateData}\n      selected={appState.openMenu === \"canvas\"}\n    />\n  ),\n});\n\nexport const actionToggleEditMenu = register({\n  name: \"toggleEditMenu\",\n  perform: (_elements, appState) => ({\n    appState: {\n      ...appState,\n      openMenu: appState.openMenu === \"shape\" ? null : \"shape\",\n    },\n    commitToHistory: false,\n  }),\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      visible={showSelectedShapeActions(\n        appState,\n        getNonDeletedElements(elements),\n      )}\n      type=\"button\"\n      icon={palette}\n      aria-label={t(\"buttons.edit\")}\n      onClick={updateData}\n      selected={appState.openMenu === \"shape\"}\n    />\n  ),\n});\n\nexport const actionFullScreen = register({\n  name: \"toggleFullScreen\",\n  perform: () => {\n    if (!isFullScreen()) {\n      allowFullScreen();\n    }\n    if (isFullScreen()) {\n      exitFullScreen();\n    }\n    return {\n      commitToHistory: false,\n    };\n  },\n  keyTest: (event) => event.code === CODES.F && !event[KEYS.CTRL_OR_CMD],\n});\n\nexport const actionShortcuts = register({\n  name: \"toggleShortcuts\",\n  perform: (_elements, appState, _, { focusContainer }) => {\n    if (appState.showHelpDialog) {\n      focusContainer();\n    }\n    return {\n      appState: {\n        ...appState,\n        showHelpDialog: !appState.showHelpDialog,\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ updateData }) => (\n    <HelpIcon title={t(\"helpDialog.title\")} onClick={updateData} />\n  ),\n  keyTest: (event) => event.key === KEYS.QUESTION_MARK,\n});\n","import \"./Avatar.scss\";\n\nimport React from \"react\";\n\ntype AvatarProps = {\n  children: string;\n  onClick: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;\n  color: string;\n  border: string;\n};\n\nexport const Avatar = ({ children, color, border, onClick }: AvatarProps) => (\n  <div\n    className=\"Avatar\"\n    style={{ background: color, border: `1px solid ${border}` }}\n    onClick={onClick}\n  >\n    {children}\n  </div>\n);\n","import { register } from \"./register\";\nimport { getSelectedElements } from \"../scene\";\nimport { getNonDeletedElements } from \"../element\";\nimport { deepCopyElement } from \"../element/newElement\";\n\nexport const actionAddToLibrary = register({\n  name: \"addToLibrary\",\n  perform: (elements, appState, _, app) => {\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n\n    app.library.loadLibrary().then((items) => {\n      app.library.saveLibrary([\n        ...items,\n        selectedElements.map(deepCopyElement),\n      ]);\n    });\n    return false;\n  },\n  contextItemLabel: \"labels.addToLibrary\",\n});\n","import React from \"react\";\nimport { getClientColors, getClientInitials } from \"../clients\";\nimport { Avatar } from \"../components/Avatar\";\nimport { centerScrollOn } from \"../scene/scroll\";\nimport { Collaborator } from \"../types\";\nimport { register } from \"./register\";\n\nexport const actionGoToCollaborator = register({\n  name: \"goToCollaborator\",\n  perform: (_elements, appState, value) => {\n    const point = value as Collaborator[\"pointer\"];\n    if (!point) {\n      return { appState, commitToHistory: false };\n    }\n\n    return {\n      appState: {\n        ...appState,\n        ...centerScrollOn({\n          scenePoint: point,\n          viewportDimensions: {\n            width: appState.width,\n            height: appState.height,\n          },\n          zoom: appState.zoom,\n        }),\n        // Close mobile menu\n        openMenu: appState.openMenu === \"canvas\" ? null : appState.openMenu,\n      },\n      commitToHistory: false,\n    };\n  },\n  PanelComponent: ({ appState, updateData, id }) => {\n    const clientId = id;\n    if (!clientId) {\n      return null;\n    }\n\n    const collaborator = appState.collaborators.get(clientId);\n\n    if (!collaborator) {\n      return null;\n    }\n\n    const { background, stroke } = getClientColors(clientId, appState);\n    const shortName = getClientInitials(collaborator.username);\n\n    return (\n      <Avatar\n        color={background}\n        border={stroke}\n        onClick={() => updateData(collaborator.pointer)}\n      >\n        {shortName}\n      </Avatar>\n    );\n  },\n});\n","import { ExcalidrawElement } from \"./element/types\";\nimport { newElementWith } from \"./element/mutateElement\";\nimport { getCommonBounds } from \"./element\";\n\ninterface Box {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n}\n\nexport interface Alignment {\n  position: \"start\" | \"center\" | \"end\";\n  axis: \"x\" | \"y\";\n}\n\nexport const alignElements = (\n  selectedElements: ExcalidrawElement[],\n  alignment: Alignment,\n): ExcalidrawElement[] => {\n  const groups: ExcalidrawElement[][] = getMaximumGroups(selectedElements);\n\n  const selectionBoundingBox = getCommonBoundingBox(selectedElements);\n\n  return groups.flatMap((group) => {\n    const translation = calculateTranslation(\n      group,\n      selectionBoundingBox,\n      alignment,\n    );\n    return group.map((element) =>\n      newElementWith(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      }),\n    );\n  });\n};\n\nexport const getMaximumGroups = (\n  elements: ExcalidrawElement[],\n): ExcalidrawElement[][] => {\n  const groups: Map<String, ExcalidrawElement[]> = new Map<\n    String,\n    ExcalidrawElement[]\n  >();\n\n  elements.forEach((element: ExcalidrawElement) => {\n    const groupId =\n      element.groupIds.length === 0\n        ? element.id\n        : element.groupIds[element.groupIds.length - 1];\n\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n\n  return Array.from(groups.values());\n};\n\nconst calculateTranslation = (\n  group: ExcalidrawElement[],\n  selectionBoundingBox: Box,\n  { axis, position }: Alignment,\n): { x: number; y: number } => {\n  const groupBoundingBox = getCommonBoundingBox(group);\n\n  const [min, max]: [\"minX\" | \"minY\", \"maxX\" | \"maxY\"] =\n    axis === \"x\" ? [\"minX\", \"maxX\"] : [\"minY\", \"maxY\"];\n\n  const noTranslation = { x: 0, y: 0 };\n  if (position === \"start\") {\n    return {\n      ...noTranslation,\n      [axis]: selectionBoundingBox[min] - groupBoundingBox[min],\n    };\n  } else if (position === \"end\") {\n    return {\n      ...noTranslation,\n      [axis]: selectionBoundingBox[max] - groupBoundingBox[max],\n    };\n  } // else if (position === \"center\") {\n  return {\n    ...noTranslation,\n    [axis]:\n      (selectionBoundingBox[min] + selectionBoundingBox[max]) / 2 -\n      (groupBoundingBox[min] + groupBoundingBox[max]) / 2,\n  };\n};\n\nconst getCommonBoundingBox = (elements: ExcalidrawElement[]): Box => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return { minX, minY, maxX, maxY };\n};\n","import React from \"react\";\nimport { alignElements, Alignment } from \"../align\";\nimport {\n  AlignBottomIcon,\n  AlignLeftIcon,\n  AlignRightIcon,\n  AlignTopIcon,\n  CenterHorizontallyIcon,\n  CenterVerticallyIcon,\n} from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { getElementMap, getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { KEYS } from \"../keys\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\n\nconst enableActionGroup = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => getSelectedElements(getNonDeletedElements(elements), appState).length > 1;\n\nconst alignSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  alignment: Alignment,\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n\n  const updatedElements = alignElements(selectedElements, alignment);\n\n  const updatedElementsMap = getElementMap(updatedElements);\n\n  return elements.map((element) => updatedElementsMap[element.id] || element);\n};\n\nexport const actionAlignTop = register({\n  name: \"alignTop\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"start\",\n        axis: \"y\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_UP,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<AlignTopIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignTop\")} — ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Up\",\n      )}`}\n      aria-label={t(\"labels.alignTop\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignBottom = register({\n  name: \"alignBottom\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"end\",\n        axis: \"y\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_DOWN,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<AlignBottomIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignBottom\")} — ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Down\",\n      )}`}\n      aria-label={t(\"labels.alignBottom\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignLeft = register({\n  name: \"alignLeft\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"start\",\n        axis: \"x\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_LEFT,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<AlignLeftIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignLeft\")} — ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Left\",\n      )}`}\n      aria-label={t(\"labels.alignLeft\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignRight = register({\n  name: \"alignRight\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"end\",\n        axis: \"x\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_RIGHT,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<AlignRightIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignRight\")} — ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Right\",\n      )}`}\n      aria-label={t(\"labels.alignRight\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignVerticallyCentered = register({\n  name: \"alignVerticallyCentered\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"center\",\n        axis: \"y\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<CenterVerticallyIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={t(\"labels.centerVertically\")}\n      aria-label={t(\"labels.centerVertically\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignHorizontallyCentered = register({\n  name: \"alignHorizontallyCentered\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, {\n        position: \"center\",\n        axis: \"x\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<CenterHorizontallyIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={t(\"labels.centerHorizontally\")}\n      aria-label={t(\"labels.centerHorizontally\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n","import { ExcalidrawElement } from \"./element/types\";\nimport { newElementWith } from \"./element/mutateElement\";\nimport { getCommonBounds } from \"./element\";\n\ninterface Box {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n  midX: number;\n  midY: number;\n  width: number;\n  height: number;\n}\n\nexport interface Distribution {\n  space: \"between\";\n  axis: \"x\" | \"y\";\n}\n\nexport const distributeElements = (\n  selectedElements: ExcalidrawElement[],\n  distribution: Distribution,\n): ExcalidrawElement[] => {\n  const [start, mid, end, extent] =\n    distribution.axis === \"x\"\n      ? ([\"minX\", \"midX\", \"maxX\", \"width\"] as const)\n      : ([\"minY\", \"midY\", \"maxY\", \"height\"] as const);\n\n  const bounds = getCommonBoundingBox(selectedElements);\n  const groups = getMaximumGroups(selectedElements)\n    .map((group) => [group, getCommonBoundingBox(group)] as const)\n    .sort((a, b) => a[1][mid] - b[1][mid]);\n\n  let span = 0;\n  for (const group of groups) {\n    span += group[1][extent];\n  }\n\n  const step = (bounds[extent] - span) / (groups.length - 1);\n\n  if (step < 0) {\n    // If we have a negative step, we'll need to distribute from centers\n    // rather than from gaps. Buckle up, this is a weird one.\n\n    // Get indices of boxes that define start and end of our bounding box\n    const index0 = groups.findIndex((g) => g[1][start] === bounds[start]);\n    const index1 = groups.findIndex((g) => g[1][end] === bounds[end]);\n\n    // Get our step, based on the distance between the center points of our\n    // start and end boxes\n    const step =\n      (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);\n\n    let pos = groups[index0][1][mid];\n\n    return groups.flatMap(([group, box], index) => {\n      const translation = {\n        x: 0,\n        y: 0,\n      };\n\n      // Don't move our start and end boxes\n      if (index !== index0 && index !== index1) {\n        pos += step;\n        translation[distribution.axis] = pos - box[mid];\n      }\n\n      return group.map((element) =>\n        newElementWith(element, {\n          x: element.x + translation.x,\n          y: element.y + translation.y,\n        }),\n      );\n    });\n  }\n\n  // Distribute from gaps\n\n  let pos = bounds[start];\n\n  return groups.flatMap(([group, box]) => {\n    const translation = {\n      x: 0,\n      y: 0,\n    };\n\n    translation[distribution.axis] = pos - box[start];\n\n    pos += step;\n    pos += box[extent];\n\n    return group.map((element) =>\n      newElementWith(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      }),\n    );\n  });\n};\n\nexport const getMaximumGroups = (\n  elements: ExcalidrawElement[],\n): ExcalidrawElement[][] => {\n  const groups: Map<String, ExcalidrawElement[]> = new Map<\n    String,\n    ExcalidrawElement[]\n  >();\n\n  elements.forEach((element: ExcalidrawElement) => {\n    const groupId =\n      element.groupIds.length === 0\n        ? element.id\n        : element.groupIds[element.groupIds.length - 1];\n\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n\n  return Array.from(groups.values());\n};\n\nconst getCommonBoundingBox = (elements: ExcalidrawElement[]): Box => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n    midX: (minX + maxX) / 2,\n    midY: (minY + maxY) / 2,\n  };\n};\n","import React from \"react\";\nimport {\n  DistributeHorizontallyIcon,\n  DistributeVerticallyIcon,\n} from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { distributeElements, Distribution } from \"../disitrubte\";\nimport { getElementMap, getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { CODES } from \"../keys\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { AppState } from \"../types\";\nimport { getShortcutKey } from \"../utils\";\nimport { register } from \"./register\";\n\nconst enableActionGroup = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => getSelectedElements(getNonDeletedElements(elements), appState).length > 1;\n\nconst distributeSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  distribution: Distribution,\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n\n  const updatedElements = distributeElements(selectedElements, distribution);\n\n  const updatedElementsMap = getElementMap(updatedElements);\n\n  return elements.map((element) => updatedElementsMap[element.id] || element);\n};\n\nexport const distributeHorizontally = register({\n  name: \"distributeHorizontally\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: distributeSelectedElements(elements, appState, {\n        space: \"between\",\n        axis: \"x\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) => event.altKey && event.code === CODES.H,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<DistributeHorizontallyIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.distributeHorizontally\")} — ${getShortcutKey(\n        \"Alt+H\",\n      )}`}\n      aria-label={t(\"labels.distributeHorizontally\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const distributeVertically = register({\n  name: \"distributeVertically\",\n  perform: (elements, appState) => {\n    return {\n      appState,\n      elements: distributeSelectedElements(elements, appState, {\n        space: \"between\",\n        axis: \"y\",\n      }),\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) => event.altKey && event.code === CODES.V,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState)}\n      type=\"button\"\n      icon={<DistributeVerticallyIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.distributeVertically\")} — ${getShortcutKey(\"Alt+V\")}`}\n      aria-label={t(\"labels.distributeVertically\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n","import { register } from \"./register\";\nimport { getSelectedElements } from \"../scene\";\nimport { getElementMap, getNonDeletedElements } from \"../element\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { ExcalidrawElement, NonDeleted } from \"../element/types\";\nimport { normalizeAngle, resizeSingleElement } from \"../element/resizeElements\";\nimport { AppState } from \"../types\";\nimport { getTransformHandles } from \"../element/transformHandles\";\nimport { isFreeDrawElement, isLinearElement } from \"../element/typeChecks\";\nimport { updateBoundElements } from \"../element/binding\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\n\nconst enableActionFlipHorizontal = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const eligibleElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n  return eligibleElements.length === 1 && eligibleElements[0].type !== \"text\";\n};\n\nconst enableActionFlipVertical = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const eligibleElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n  return eligibleElements.length === 1;\n};\n\nexport const actionFlipHorizontal = register({\n  name: \"flipHorizontal\",\n  perform: (elements, appState) => {\n    return {\n      elements: flipSelectedElements(elements, appState, \"horizontal\"),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) => event.shiftKey && event.code === \"KeyH\",\n  contextItemLabel: \"labels.flipHorizontal\",\n  contextItemPredicate: (elements, appState) =>\n    enableActionFlipHorizontal(elements, appState),\n});\n\nexport const actionFlipVertical = register({\n  name: \"flipVertical\",\n  perform: (elements, appState) => {\n    return {\n      elements: flipSelectedElements(elements, appState, \"vertical\"),\n      appState,\n      commitToHistory: true,\n    };\n  },\n  keyTest: (event) => event.shiftKey && event.code === \"KeyV\",\n  contextItemLabel: \"labels.flipVertical\",\n  contextItemPredicate: (elements, appState) =>\n    enableActionFlipVertical(elements, appState),\n});\n\nconst flipSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  flipDirection: \"horizontal\" | \"vertical\",\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n\n  // remove once we allow for groups of elements to be flipped\n  if (selectedElements.length > 1) {\n    return elements;\n  }\n\n  const updatedElements = flipElements(\n    selectedElements,\n    appState,\n    flipDirection,\n  );\n\n  const updatedElementsMap = getElementMap(updatedElements);\n\n  return elements.map((element) => updatedElementsMap[element.id] || element);\n};\n\nconst flipElements = (\n  elements: NonDeleted<ExcalidrawElement>[],\n  appState: AppState,\n  flipDirection: \"horizontal\" | \"vertical\",\n): ExcalidrawElement[] => {\n  for (let i = 0; i < elements.length; i++) {\n    flipElement(elements[i], appState);\n    // If vertical flip, rotate an extra 180\n    if (flipDirection === \"vertical\") {\n      rotateElement(elements[i], Math.PI);\n    }\n  }\n  return elements;\n};\n\nconst flipElement = (\n  element: NonDeleted<ExcalidrawElement>,\n  appState: AppState,\n) => {\n  const originalX = element.x;\n  const originalY = element.y;\n  const width = element.width;\n  const height = element.height;\n  const originalAngle = normalizeAngle(element.angle);\n\n  let finalOffsetX = 0;\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    finalOffsetX =\n      element.points.reduce((max, point) => Math.max(max, point[0]), 0) * 2 -\n      element.width;\n  }\n\n  // Rotate back to zero, if necessary\n  mutateElement(element, {\n    angle: normalizeAngle(0),\n  });\n  // Flip unrotated by pulling TransformHandle to opposite side\n  const transformHandles = getTransformHandles(element, appState.zoom);\n  let usingNWHandle = true;\n  let newNCoordsX = 0;\n  let nHandle = transformHandles.nw;\n  if (!nHandle) {\n    // Use ne handle instead\n    usingNWHandle = false;\n    nHandle = transformHandles.ne;\n    if (!nHandle) {\n      mutateElement(element, {\n        angle: originalAngle,\n      });\n      return;\n    }\n  }\n\n  if (isLinearElement(element)) {\n    for (let i = 1; i < element.points.length; i++) {\n      LinearElementEditor.movePoint(element, i, [\n        -element.points[i][0],\n        element.points[i][1],\n      ]);\n    }\n    LinearElementEditor.normalizePoints(element);\n  } else {\n    // calculate new x-coord for transformation\n    newNCoordsX = usingNWHandle ? element.x + 2 * width : element.x - 2 * width;\n    resizeSingleElement(\n      element,\n      true,\n      element,\n      usingNWHandle ? \"nw\" : \"ne\",\n      false,\n      newNCoordsX,\n      nHandle[1],\n    );\n    // fix the size to account for handle sizes\n    mutateElement(element, {\n      width,\n      height,\n    });\n  }\n\n  // Rotate by (360 degrees - original angle)\n  let angle = normalizeAngle(2 * Math.PI - originalAngle);\n  if (angle < 0) {\n    // check, probably unnecessary\n    angle = normalizeAngle(angle + 2 * Math.PI);\n  }\n  mutateElement(element, {\n    angle,\n  });\n\n  // Move back to original spot to appear \"flipped in place\"\n  mutateElement(element, {\n    x: originalX + finalOffsetX,\n    y: originalY,\n  });\n\n  updateBoundElements(element);\n};\n\nconst rotateElement = (element: ExcalidrawElement, rotationAngle: number) => {\n  const originalX = element.x;\n  const originalY = element.y;\n  let angle = normalizeAngle(element.angle + rotationAngle);\n  if (angle < 0) {\n    // check, probably unnecessary\n    angle = normalizeAngle(2 * Math.PI + angle);\n  }\n  mutateElement(element, {\n    angle,\n  });\n\n  // Move back to original spot\n  mutateElement(element, {\n    x: originalX,\n    y: originalY,\n  });\n};\n","import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { copyToClipboard } from \"../clipboard\";\nimport { actionDeleteSelected } from \"./actionDeleteSelected\";\nimport { getSelectedElements } from \"../scene/selection\";\nimport { exportCanvas } from \"../data/index\";\nimport { getNonDeletedElements } from \"../element\";\nimport { t } from \"../i18n\";\n\nexport const actionCopy = register({\n  name: \"copy\",\n  perform: (elements, appState) => {\n    copyToClipboard(getNonDeletedElements(elements), appState);\n\n    return {\n      commitToHistory: false,\n    };\n  },\n  contextItemLabel: \"labels.copy\",\n  // don't supply a shortcut since we handle this conditionally via onCopy event\n  keyTest: undefined,\n});\n\nexport const actionCut = register({\n  name: \"cut\",\n  perform: (elements, appState, data, app) => {\n    actionCopy.perform(elements, appState, data, app);\n    return actionDeleteSelected.perform(elements, appState, data, app);\n  },\n  contextItemLabel: \"labels.cut\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.code === CODES.X,\n});\n\nexport const actionCopyAsSvg = register({\n  name: \"copyAsSvg\",\n  perform: async (elements, appState, _data, app) => {\n    if (!app.canvas) {\n      return {\n        commitToHistory: false,\n      };\n    }\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    try {\n      await exportCanvas(\n        \"clipboard-svg\",\n        selectedElements.length\n          ? selectedElements\n          : getNonDeletedElements(elements),\n        appState,\n        appState,\n      );\n      return {\n        commitToHistory: false,\n      };\n    } catch (error) {\n      console.error(error);\n      return {\n        appState: {\n          ...appState,\n          errorMessage: error.message,\n        },\n        commitToHistory: false,\n      };\n    }\n  },\n  contextItemLabel: \"labels.copyAsSvg\",\n});\n\nexport const actionCopyAsPng = register({\n  name: \"copyAsPng\",\n  perform: async (elements, appState, _data, app) => {\n    if (!app.canvas) {\n      return {\n        commitToHistory: false,\n      };\n    }\n    const selectedElements = getSelectedElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n    try {\n      await exportCanvas(\n        \"clipboard\",\n        selectedElements.length\n          ? selectedElements\n          : getNonDeletedElements(elements),\n        appState,\n        appState,\n      );\n      return {\n        appState: {\n          ...appState,\n          toastMessage: t(\"toast.copyToClipboardAsPng\", {\n            exportSelection: selectedElements.length\n              ? t(\"toast.selection\")\n              : t(\"toast.canvas\"),\n            exportColorScheme: appState.exportWithDarkMode\n              ? t(\"buttons.darkMode\")\n              : t(\"buttons.lightMode\"),\n          }),\n        },\n        commitToHistory: false,\n      };\n    } catch (error) {\n      console.error(error);\n      return {\n        appState: {\n          ...appState,\n          errorMessage: error.message,\n        },\n        commitToHistory: false,\n      };\n    }\n  },\n  contextItemLabel: \"labels.copyAsPng\",\n  keyTest: (event) => event.code === CODES.C && event.altKey && event.shiftKey,\n});\n","import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { GRID_SIZE } from \"../constants\";\nimport { AppState } from \"../types\";\nimport { trackEvent } from \"../analytics\";\n\nexport const actionToggleGridMode = register({\n  name: \"gridMode\",\n  perform(elements, appState) {\n    trackEvent(\"view\", \"mode\", \"grid\");\n    return {\n      appState: {\n        ...appState,\n        gridSize: this.checked!(appState) ? null : GRID_SIZE,\n      },\n      commitToHistory: false,\n    };\n  },\n  checked: (appState: AppState) => appState.gridSize !== null,\n  contextItemLabel: \"labels.showGrid\",\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.code === CODES.QUOTE,\n});\n","import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { trackEvent } from \"../analytics\";\n\nexport const actionToggleZenMode = register({\n  name: \"zenMode\",\n  perform(elements, appState) {\n    trackEvent(\"view\", \"mode\", \"zen\");\n\n    return {\n      appState: {\n        ...appState,\n        zenModeEnabled: !this.checked!(appState),\n      },\n      commitToHistory: false,\n    };\n  },\n  checked: (appState) => appState.zenModeEnabled,\n  contextItemLabel: \"buttons.zenMode\",\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.Z,\n});\n","import { register } from \"./register\";\nimport { CODES, KEYS } from \"../keys\";\n\nexport const actionToggleStats = register({\n  name: \"stats\",\n  perform(elements, appState) {\n    return {\n      appState: {\n        ...appState,\n        showStats: !this.checked!(appState),\n      },\n      commitToHistory: false,\n    };\n  },\n  checked: (appState) => appState.showStats,\n  contextItemLabel: \"stats.title\",\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.SLASH,\n});\n","import { Action, ActionResult } from \"./types\";\nimport React from \"react\";\nimport { undo, redo } from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { t } from \"../i18n\";\nimport History, { HistoryEntry } from \"../history\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { isWindows, KEYS } from \"../keys\";\nimport { getElementMap } from \"../element\";\nimport { newElementWith } from \"../element/mutateElement\";\nimport { fixBindingsAfterDeletion } from \"../element/binding\";\n\nconst writeData = (\n  prevElements: readonly ExcalidrawElement[],\n  appState: AppState,\n  updater: () => HistoryEntry | null,\n): ActionResult => {\n  const commitToHistory = false;\n  if (\n    !appState.multiElement &&\n    !appState.resizingElement &&\n    !appState.editingElement &&\n    !appState.draggingElement\n  ) {\n    const data = updater();\n    if (data === null) {\n      return { commitToHistory };\n    }\n\n    const prevElementMap = getElementMap(prevElements);\n    const nextElements = data.elements;\n    const nextElementMap = getElementMap(nextElements);\n\n    const deletedElements = prevElements.filter(\n      (prevElement) => !nextElementMap.hasOwnProperty(prevElement.id),\n    );\n    const elements = nextElements\n      .map((nextElement) =>\n        newElementWith(\n          prevElementMap[nextElement.id] || nextElement,\n          nextElement,\n        ),\n      )\n      .concat(\n        deletedElements.map((prevElement) =>\n          newElementWith(prevElement, { isDeleted: true }),\n        ),\n      );\n    fixBindingsAfterDeletion(elements, deletedElements);\n\n    return {\n      elements,\n      appState: { ...appState, ...data.appState },\n      commitToHistory,\n      syncHistory: true,\n    };\n  }\n  return { commitToHistory };\n};\n\ntype ActionCreator = (history: History) => Action;\n\nexport const createUndoAction: ActionCreator = (history) => ({\n  name: \"undo\",\n  perform: (elements, appState) =>\n    writeData(elements, appState, () => history.undoOnce()),\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] &&\n    event.key.toLowerCase() === KEYS.Z &&\n    !event.shiftKey,\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={undo}\n      aria-label={t(\"buttons.undo\")}\n      onClick={updateData}\n    />\n  ),\n  commitToHistory: () => false,\n});\n\nexport const createRedoAction: ActionCreator = (history) => ({\n  name: \"redo\",\n  perform: (elements, appState) =>\n    writeData(elements, appState, () => history.redoOnce()),\n  keyTest: (event) =>\n    (event[KEYS.CTRL_OR_CMD] &&\n      event.shiftKey &&\n      event.key.toLowerCase() === KEYS.Z) ||\n    (isWindows && event.ctrlKey && !event.shiftKey && event.key === KEYS.Y),\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={redo}\n      aria-label={t(\"buttons.redo\")}\n      onClick={updateData}\n    />\n  ),\n  commitToHistory: () => false,\n});\n","import React from \"react\";\nimport {\n  Action,\n  ActionsManagerInterface,\n  UpdaterFn,\n  ActionName,\n  ActionResult,\n} from \"./types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppProps, AppState } from \"../types\";\nimport { MODES } from \"../constants\";\nimport Library from \"../data/library\";\n\n// This is the <App> component, but for now we don't care about anything but its\n// `canvas` state.\ntype App = {\n  canvas: HTMLCanvasElement | null;\n  focusContainer: () => void;\n  props: AppProps;\n  library: Library;\n};\n\nexport class ActionManager implements ActionsManagerInterface {\n  actions = {} as ActionsManagerInterface[\"actions\"];\n\n  updater: (actionResult: ActionResult | Promise<ActionResult>) => void;\n\n  getAppState: () => Readonly<AppState>;\n  getElementsIncludingDeleted: () => readonly ExcalidrawElement[];\n  app: App;\n\n  constructor(\n    updater: UpdaterFn,\n    getAppState: () => AppState,\n    getElementsIncludingDeleted: () => readonly ExcalidrawElement[],\n    app: App,\n  ) {\n    this.updater = (actionResult) => {\n      if (actionResult && \"then\" in actionResult) {\n        actionResult.then((actionResult) => {\n          return updater(actionResult);\n        });\n      } else {\n        return updater(actionResult);\n      }\n    };\n    this.getAppState = getAppState;\n    this.getElementsIncludingDeleted = getElementsIncludingDeleted;\n    this.app = app;\n  }\n\n  registerAction(action: Action) {\n    this.actions[action.name] = action;\n  }\n\n  registerAll(actions: readonly Action[]) {\n    actions.forEach((action) => this.registerAction(action));\n  }\n\n  handleKeyDown(event: React.KeyboardEvent | KeyboardEvent) {\n    const canvasActions = this.app.props.UIOptions.canvasActions;\n    const data = Object.values(this.actions)\n      .sort((a, b) => (b.keyPriority || 0) - (a.keyPriority || 0))\n      .filter(\n        (action) =>\n          (action.name in canvasActions\n            ? canvasActions[action.name as keyof typeof canvasActions]\n            : true) &&\n          action.keyTest &&\n          action.keyTest(\n            event,\n            this.getAppState(),\n            this.getElementsIncludingDeleted(),\n          ),\n      );\n\n    if (data.length === 0) {\n      return false;\n    }\n    const { viewModeEnabled } = this.getAppState();\n    if (viewModeEnabled) {\n      if (!Object.values(MODES).includes(data[0].name)) {\n        return false;\n      }\n    }\n\n    event.preventDefault();\n    this.updater(\n      data[0].perform(\n        this.getElementsIncludingDeleted(),\n        this.getAppState(),\n        null,\n        this.app,\n      ),\n    );\n    return true;\n  }\n\n  executeAction(action: Action) {\n    this.updater(\n      action.perform(\n        this.getElementsIncludingDeleted(),\n        this.getAppState(),\n        null,\n        this.app,\n      ),\n    );\n  }\n\n  // Id is an attribute that we can use to pass in data like keys.\n  // This is needed for dynamically generated action components\n  // like the user list. We can use this key to extract more\n  // data from app state. This is an alternative to generic prop hell!\n  renderAction = (name: ActionName, id?: string) => {\n    const canvasActions = this.app.props.UIOptions.canvasActions;\n\n    if (\n      this.actions[name] &&\n      \"PanelComponent\" in this.actions[name] &&\n      (name in canvasActions\n        ? canvasActions[name as keyof typeof canvasActions]\n        : true)\n    ) {\n      const action = this.actions[name];\n      const PanelComponent = action.PanelComponent!;\n      const updateData = (formState?: any) => {\n        this.updater(\n          action.perform(\n            this.getElementsIncludingDeleted(),\n            this.getAppState(),\n            formState,\n            this.app,\n          ),\n        );\n      };\n\n      return (\n        <PanelComponent\n          elements={this.getElementsIncludingDeleted()}\n          appState={this.getAppState()}\n          updateData={updateData}\n          id={id}\n          appProps={this.app.props}\n        />\n      );\n    }\n\n    return null;\n  };\n}\n","import { loadLibraryFromBlob } from \"./blob\";\nimport { LibraryItems, LibraryItem } from \"../types\";\nimport { restoreElements } from \"./restore\";\nimport { getNonDeletedElements } from \"../element\";\nimport type App from \"../components/App\";\n\nclass Library {\n  private libraryCache: LibraryItems | null = null;\n  private app: App;\n\n  constructor(app: App) {\n    this.app = app;\n  }\n\n  resetLibrary = async () => {\n    await this.app.props.onLibraryChange?.([]);\n    this.libraryCache = [];\n  };\n\n  restoreLibraryItem = (libraryItem: LibraryItem): LibraryItem | null => {\n    const elements = getNonDeletedElements(restoreElements(libraryItem, null));\n    return elements.length ? elements : null;\n  };\n\n  /** imports library (currently merges, removing duplicates) */\n  async importLibrary(blob: Blob) {\n    const libraryFile = await loadLibraryFromBlob(blob);\n    if (!libraryFile || !libraryFile.library) {\n      return;\n    }\n\n    /**\n     * checks if library item does not exist already in current library\n     */\n    const isUniqueitem = (\n      existingLibraryItems: LibraryItems,\n      targetLibraryItem: LibraryItem,\n    ) => {\n      return !existingLibraryItems.find((libraryItem) => {\n        if (libraryItem.length !== targetLibraryItem.length) {\n          return false;\n        }\n\n        // detect z-index difference by checking the excalidraw elements\n        // are in order\n        return libraryItem.every((libItemExcalidrawItem, idx) => {\n          return (\n            libItemExcalidrawItem.id === targetLibraryItem[idx].id &&\n            libItemExcalidrawItem.versionNonce ===\n              targetLibraryItem[idx].versionNonce\n          );\n        });\n      });\n    };\n\n    const existingLibraryItems = await this.loadLibrary();\n\n    const filtered = libraryFile.library!.reduce((acc, libraryItem) => {\n      const restoredItem = this.restoreLibraryItem(libraryItem);\n      if (restoredItem && isUniqueitem(existingLibraryItems, restoredItem)) {\n        acc.push(restoredItem);\n      }\n      return acc;\n    }, [] as Mutable<LibraryItems>);\n\n    await this.saveLibrary([...existingLibraryItems, ...filtered]);\n  }\n\n  loadLibrary = (): Promise<LibraryItems> => {\n    return new Promise(async (resolve) => {\n      if (this.libraryCache) {\n        return resolve(JSON.parse(JSON.stringify(this.libraryCache)));\n      }\n\n      try {\n        const libraryItems = this.app.libraryItemsFromStorage;\n        if (!libraryItems) {\n          return resolve([]);\n        }\n\n        const items = libraryItems.reduce((acc, item) => {\n          const restoredItem = this.restoreLibraryItem(item);\n          if (restoredItem) {\n            acc.push(item);\n          }\n          return acc;\n        }, [] as Mutable<LibraryItems>);\n\n        // clone to ensure we don't mutate the cached library elements in the app\n        this.libraryCache = JSON.parse(JSON.stringify(items));\n\n        resolve(items);\n      } catch (error) {\n        console.error(error);\n        resolve([]);\n      }\n    });\n  };\n\n  saveLibrary = async (items: LibraryItems) => {\n    const prevLibraryItems = this.libraryCache;\n    try {\n      const serializedItems = JSON.stringify(items);\n      // cache optimistically so that the app has access to the latest\n      // immediately\n      this.libraryCache = JSON.parse(serializedItems);\n      await this.app.props.onLibraryChange?.(items);\n    } catch (error) {\n      this.libraryCache = prevLibraryItems;\n      throw error;\n    }\n  };\n}\n\nexport default Library;\n","import { PointerCoords } from \"./types\";\n\nexport const getCenter = (pointers: Map<number, PointerCoords>) => {\n  const allCoords = Array.from(pointers.values());\n  return {\n    x: sum(allCoords, (coords) => coords.x) / allCoords.length,\n    y: sum(allCoords, (coords) => coords.y) / allCoords.length,\n  };\n};\n\nexport const getDistance = ([a, b]: readonly PointerCoords[]) =>\n  Math.hypot(a.x - b.x, a.y - b.y);\n\nconst sum = <T>(array: readonly T[], mapper: (item: T) => number): number =>\n  array.reduce((acc, item) => acc + mapper(item), 0);\n","import { AppState } from \"./types\";\nimport { ExcalidrawElement } from \"./element/types\";\nimport { isLinearElement } from \"./element/typeChecks\";\nimport { deepCopyElement } from \"./element/newElement\";\n\nexport interface HistoryEntry {\n  appState: ReturnType<typeof clearAppStatePropertiesForHistory>;\n  elements: ExcalidrawElement[];\n}\n\ninterface DehydratedExcalidrawElement {\n  id: string;\n  versionNonce: number;\n}\n\ninterface DehydratedHistoryEntry {\n  appState: string;\n  elements: DehydratedExcalidrawElement[];\n}\n\nconst clearAppStatePropertiesForHistory = (appState: AppState) => {\n  return {\n    selectedElementIds: appState.selectedElementIds,\n    selectedGroupIds: appState.selectedGroupIds,\n    viewBackgroundColor: appState.viewBackgroundColor,\n    editingLinearElement: appState.editingLinearElement,\n    editingGroupId: appState.editingGroupId,\n    name: appState.name,\n  };\n};\n\nclass History {\n  private elementCache = new Map<string, Map<number, ExcalidrawElement>>();\n  private recording: boolean = true;\n  private stateHistory: DehydratedHistoryEntry[] = [];\n  private redoStack: DehydratedHistoryEntry[] = [];\n  private lastEntry: HistoryEntry | null = null;\n\n  private hydrateHistoryEntry({\n    appState,\n    elements,\n  }: DehydratedHistoryEntry): HistoryEntry {\n    return {\n      appState: JSON.parse(appState),\n      elements: elements.map((dehydratedExcalidrawElement) => {\n        const element = this.elementCache\n          .get(dehydratedExcalidrawElement.id)\n          ?.get(dehydratedExcalidrawElement.versionNonce);\n        if (!element) {\n          throw new Error(\n            `Element not found: ${dehydratedExcalidrawElement.id}:${dehydratedExcalidrawElement.versionNonce}`,\n          );\n        }\n        return element;\n      }),\n    };\n  }\n\n  private dehydrateHistoryEntry({\n    appState,\n    elements,\n  }: HistoryEntry): DehydratedHistoryEntry {\n    return {\n      appState: JSON.stringify(appState),\n      elements: elements.map((element: ExcalidrawElement) => {\n        if (!this.elementCache.has(element.id)) {\n          this.elementCache.set(element.id, new Map());\n        }\n        const versions = this.elementCache.get(element.id)!;\n        if (!versions.has(element.versionNonce)) {\n          versions.set(element.versionNonce, deepCopyElement(element));\n        }\n        return {\n          id: element.id,\n          versionNonce: element.versionNonce,\n        };\n      }),\n    };\n  }\n\n  getSnapshotForTest() {\n    return {\n      recording: this.recording,\n      stateHistory: this.stateHistory.map((dehydratedHistoryEntry) =>\n        this.hydrateHistoryEntry(dehydratedHistoryEntry),\n      ),\n      redoStack: this.redoStack.map((dehydratedHistoryEntry) =>\n        this.hydrateHistoryEntry(dehydratedHistoryEntry),\n      ),\n    };\n  }\n\n  clear() {\n    this.stateHistory.length = 0;\n    this.redoStack.length = 0;\n    this.lastEntry = null;\n    this.elementCache.clear();\n  }\n\n  private generateEntry = (\n    appState: AppState,\n    elements: readonly ExcalidrawElement[],\n  ): DehydratedHistoryEntry =>\n    this.dehydrateHistoryEntry({\n      appState: clearAppStatePropertiesForHistory(appState),\n      elements: elements.reduce((elements, element) => {\n        if (\n          isLinearElement(element) &&\n          appState.multiElement &&\n          appState.multiElement.id === element.id\n        ) {\n          // don't store multi-point arrow if still has only one point\n          if (\n            appState.multiElement &&\n            appState.multiElement.id === element.id &&\n            element.points.length < 2\n          ) {\n            return elements;\n          }\n\n          elements.push({\n            ...element,\n            // don't store last point if not committed\n            points:\n              element.lastCommittedPoint !==\n              element.points[element.points.length - 1]\n                ? element.points.slice(0, -1)\n                : element.points,\n          });\n        } else {\n          elements.push(element);\n        }\n        return elements;\n      }, [] as Mutable<typeof elements>),\n    });\n\n  shouldCreateEntry(nextEntry: HistoryEntry): boolean {\n    const { lastEntry } = this;\n\n    if (!lastEntry) {\n      return true;\n    }\n\n    if (nextEntry.elements.length !== lastEntry.elements.length) {\n      return true;\n    }\n\n    // loop from right to left as changes are likelier to happen on new elements\n    for (let i = nextEntry.elements.length - 1; i > -1; i--) {\n      const prev = nextEntry.elements[i];\n      const next = lastEntry.elements[i];\n      if (\n        !prev ||\n        !next ||\n        prev.id !== next.id ||\n        prev.versionNonce !== next.versionNonce\n      ) {\n        return true;\n      }\n    }\n\n    // note: this is safe because entry's appState is guaranteed no excess props\n    let key: keyof typeof nextEntry.appState;\n    for (key in nextEntry.appState) {\n      if (key === \"editingLinearElement\") {\n        if (\n          nextEntry.appState[key]?.elementId ===\n          lastEntry.appState[key]?.elementId\n        ) {\n          continue;\n        }\n      }\n      if (key === \"selectedElementIds\" || key === \"selectedGroupIds\") {\n        continue;\n      }\n      if (nextEntry.appState[key] !== lastEntry.appState[key]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  pushEntry(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    const newEntryDehydrated = this.generateEntry(appState, elements);\n    const newEntry: HistoryEntry = this.hydrateHistoryEntry(newEntryDehydrated);\n\n    if (newEntry) {\n      if (!this.shouldCreateEntry(newEntry)) {\n        return;\n      }\n\n      this.stateHistory.push(newEntryDehydrated);\n      this.lastEntry = newEntry;\n      // As a new entry was pushed, we invalidate the redo stack\n      this.clearRedoStack();\n    }\n  }\n\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n\n  redoOnce(): HistoryEntry | null {\n    if (this.redoStack.length === 0) {\n      return null;\n    }\n\n    const entryToRestore = this.redoStack.pop();\n\n    if (entryToRestore !== undefined) {\n      this.stateHistory.push(entryToRestore);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  undoOnce(): HistoryEntry | null {\n    if (this.stateHistory.length === 1) {\n      return null;\n    }\n\n    const currentEntry = this.stateHistory.pop();\n\n    const entryToRestore = this.stateHistory[this.stateHistory.length - 1];\n\n    if (currentEntry !== undefined) {\n      this.redoStack.push(currentEntry);\n      return this.hydrateHistoryEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  /**\n   * Updates history's `lastEntry` to latest app state. This is necessary\n   *  when doing undo/redo which itself doesn't commit to history, but updates\n   *  app state in a way that would break `shouldCreateEntry` which relies on\n   *  `lastEntry` to reflect last comittable history state.\n   * We can't update `lastEntry` from within history when calling undo/redo\n   *  because the action potentially mutates appState/elements before storing\n   *  it.\n   */\n  setCurrentState(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    this.lastEntry = this.hydrateHistoryEntry(\n      this.generateEntry(appState, elements),\n    );\n  }\n\n  // Suspicious that this is called so many places. Seems error-prone.\n  resumeRecording() {\n    this.recording = true;\n  }\n\n  record(state: AppState, elements: readonly ExcalidrawElement[]) {\n    if (this.recording) {\n      this.pushEntry(state, elements);\n      this.recording = false;\n    }\n  }\n}\n\nexport default History;\n","import React from \"react\";\nimport { KEYS } from \"./keys\";\n\n// We inline font-awesome icons in order to save on js size rather than including the font awesome react library\nexport const SHAPES = [\n  {\n    icon: (\n      // fa-mouse-pointer\n      <svg viewBox=\"0 0 320 512\" className=\"\">\n        <path d=\"M302.189 329.126H196.105l55.831 135.993c3.889 9.428-.555 19.999-9.444 23.999l-49.165 21.427c-9.165 4-19.443-.571-23.332-9.714l-53.053-129.136-86.664 89.138C18.729 472.71 0 463.554 0 447.977V18.299C0 1.899 19.921-6.096 30.277 5.443l284.412 292.542c11.472 11.179 3.007 31.141-12.5 31.141z\" />\n      </svg>\n    ),\n    value: \"selection\",\n    key: KEYS.V,\n  },\n  {\n    icon: (\n      // fa-square\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z\" />\n      </svg>\n    ),\n    value: \"rectangle\",\n    key: KEYS.R,\n  },\n  {\n    icon: (\n      // custom\n      <svg viewBox=\"0 0 223.646 223.646\">\n        <path d=\"M111.823 0L16.622 111.823 111.823 223.646 207.025 111.823z\" />\n      </svg>\n    ),\n    value: \"diamond\",\n    key: KEYS.D,\n  },\n  {\n    icon: (\n      // fa-circle\n      <svg viewBox=\"0 0 512 512\">\n        <path d=\"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z\" />\n      </svg>\n    ),\n    value: \"ellipse\",\n    key: KEYS.E,\n  },\n  {\n    icon: (\n      // fa-long-arrow-alt-right\n      <svg viewBox=\"0 0 448 512\" className=\"rtl-mirror\">\n        <path d=\"M313.941 216H12c-6.627 0-12 5.373-12 12v56c0 6.627 5.373 12 12 12h301.941v46.059c0 21.382 25.851 32.09 40.971 16.971l86.059-86.059c9.373-9.373 9.373-24.569 0-33.941l-86.059-86.059c-15.119-15.119-40.971-4.411-40.971 16.971V216z\" />\n      </svg>\n    ),\n    value: \"arrow\",\n    key: KEYS.A,\n  },\n  {\n    icon: (\n      // custom\n      <svg viewBox=\"0 0 6 6\">\n        <line\n          x1=\"0\"\n          y1=\"3\"\n          x2=\"6\"\n          y2=\"3\"\n          stroke=\"currentColor\"\n          strokeLinecap=\"round\"\n        />\n      </svg>\n    ),\n    value: \"line\",\n    key: [KEYS.P, KEYS.L],\n  },\n  {\n    icon: (\n      // fa-pencil\n      <svg viewBox=\"0 0 512 512\">\n        <path\n          fill=\"currentColor\"\n          d=\"M290.74 93.24l128.02 128.02-277.99 277.99-114.14 12.6C11.35 513.54-1.56 500.62.14 485.34l12.7-114.22 277.9-277.88zm207.2-19.06l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.76 18.75-49.16 0-67.91z\"\n        ></path>\n      </svg>\n    ),\n    value: \"freedraw\",\n    key: KEYS.X,\n  },\n  {\n    icon: (\n      // fa-font\n      <svg viewBox=\"0 0 448 512\">\n        <path d=\"M432 416h-23.41L277.88 53.69A32 32 0 0 0 247.58 32h-47.16a32 32 0 0 0-30.3 21.69L39.41 416H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16h-19.58l23.3-64h152.56l23.3 64H304a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM176.85 272L224 142.51 271.15 272z\" />\n      </svg>\n    ),\n    value: \"text\",\n    key: KEYS.T,\n  },\n] as const;\n\nexport const findShapeByKey = (key: string) => {\n  const shape = SHAPES.find((shape, index) => {\n    return (\n      key === (index + 1).toString() ||\n      (typeof shape.key === \"string\"\n        ? shape.key === key\n        : (shape.key as readonly string[]).includes(key))\n    );\n  });\n  return shape?.value || null;\n};\n","import { t } from \"../i18n\";\nimport { isDarwin } from \"../keys\";\nimport { getShortcutKey } from \"../utils\";\n\nexport type ShortcutName =\n  | \"cut\"\n  | \"copy\"\n  | \"paste\"\n  | \"copyStyles\"\n  | \"pasteStyles\"\n  | \"selectAll\"\n  | \"deleteSelectedElements\"\n  | \"duplicateSelection\"\n  | \"sendBackward\"\n  | \"bringForward\"\n  | \"sendToBack\"\n  | \"bringToFront\"\n  | \"copyAsPng\"\n  | \"copyAsSvg\"\n  | \"group\"\n  | \"ungroup\"\n  | \"gridMode\"\n  | \"zenMode\"\n  | \"stats\"\n  | \"addToLibrary\"\n  | \"viewMode\"\n  | \"flipHorizontal\"\n  | \"flipVertical\";\n\nconst shortcutMap: Record<ShortcutName, string[]> = {\n  cut: [getShortcutKey(\"CtrlOrCmd+X\")],\n  copy: [getShortcutKey(\"CtrlOrCmd+C\")],\n  paste: [getShortcutKey(\"CtrlOrCmd+V\")],\n  copyStyles: [getShortcutKey(\"CtrlOrCmd+Alt+C\")],\n  pasteStyles: [getShortcutKey(\"CtrlOrCmd+Alt+V\")],\n  selectAll: [getShortcutKey(\"CtrlOrCmd+A\")],\n  deleteSelectedElements: [getShortcutKey(\"Del\")],\n  duplicateSelection: [\n    getShortcutKey(\"CtrlOrCmd+D\"),\n    getShortcutKey(`Alt+${t(\"helpDialog.drag\")}`),\n  ],\n  sendBackward: [getShortcutKey(\"CtrlOrCmd+[\")],\n  bringForward: [getShortcutKey(\"CtrlOrCmd+]\")],\n  sendToBack: [\n    isDarwin\n      ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n      : getShortcutKey(\"CtrlOrCmd+Shift+[\"),\n  ],\n  bringToFront: [\n    isDarwin\n      ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n      : getShortcutKey(\"CtrlOrCmd+Shift+]\"),\n  ],\n  copyAsPng: [getShortcutKey(\"Shift+Alt+C\")],\n  copyAsSvg: [],\n  group: [getShortcutKey(\"CtrlOrCmd+G\")],\n  ungroup: [getShortcutKey(\"CtrlOrCmd+Shift+G\")],\n  gridMode: [getShortcutKey(\"CtrlOrCmd+'\")],\n  zenMode: [getShortcutKey(\"Alt+Z\")],\n  stats: [getShortcutKey(\"Alt+/\")],\n  addToLibrary: [],\n  flipHorizontal: [getShortcutKey(\"Shift+H\")],\n  flipVertical: [getShortcutKey(\"Shift+V\")],\n  viewMode: [getShortcutKey(\"Alt+R\")],\n};\n\nexport const getShortcutFromShortcutName = (name: ShortcutName) => {\n  const shortcuts = shortcutMap[name];\n  // if multiple shortcuts availiable, take the first one\n  return shortcuts && shortcuts.length > 0 ? shortcuts[0] : \"\";\n};\n","import React from \"react\";\nimport { render, unmountComponentAtNode } from \"react-dom\";\nimport clsx from \"clsx\";\nimport { Popover } from \"./Popover\";\nimport { t } from \"../i18n\";\n\nimport \"./ContextMenu.scss\";\nimport {\n  getShortcutFromShortcutName,\n  ShortcutName,\n} from \"../actions/shortcuts\";\nimport { Action } from \"../actions/types\";\nimport { ActionManager } from \"../actions/manager\";\nimport { AppState } from \"../types\";\n\nexport type ContextMenuOption = \"separator\" | Action;\n\ntype ContextMenuProps = {\n  options: ContextMenuOption[];\n  onCloseRequest?(): void;\n  top: number;\n  left: number;\n  actionManager: ActionManager;\n  appState: Readonly<AppState>;\n};\n\nconst ContextMenu = ({\n  options,\n  onCloseRequest,\n  top,\n  left,\n  actionManager,\n  appState,\n}: ContextMenuProps) => {\n  return (\n    <Popover\n      onCloseRequest={onCloseRequest}\n      top={top}\n      left={left}\n      fitInViewport={true}\n    >\n      <ul\n        className=\"context-menu\"\n        onContextMenu={(event) => event.preventDefault()}\n      >\n        {options.map((option, idx) => {\n          if (option === \"separator\") {\n            return <hr key={idx} className=\"context-menu-option-separator\" />;\n          }\n\n          const actionName = option.name;\n          const label = option.contextItemLabel\n            ? t(option.contextItemLabel)\n            : \"\";\n          return (\n            <li key={idx} data-testid={actionName} onClick={onCloseRequest}>\n              <button\n                className={clsx(\"context-menu-option\", {\n                  dangerous: actionName === \"deleteSelectedElements\",\n                  checkmark: option.checked?.(appState),\n                })}\n                onClick={() => actionManager.executeAction(option)}\n              >\n                <div className=\"context-menu-option__label\">{label}</div>\n                <kbd className=\"context-menu-option__shortcut\">\n                  {actionName\n                    ? getShortcutFromShortcutName(actionName as ShortcutName)\n                    : \"\"}\n                </kbd>\n              </button>\n            </li>\n          );\n        })}\n      </ul>\n    </Popover>\n  );\n};\n\nconst contextMenuNodeByContainer = new WeakMap<HTMLElement, HTMLDivElement>();\n\nconst getContextMenuNode = (container: HTMLElement): HTMLDivElement => {\n  let contextMenuNode = contextMenuNodeByContainer.get(container);\n  if (contextMenuNode) {\n    return contextMenuNode;\n  }\n  contextMenuNode = document.createElement(\"div\");\n  container\n    .querySelector(\".excalidraw-contextMenuContainer\")!\n    .appendChild(contextMenuNode);\n  contextMenuNodeByContainer.set(container, contextMenuNode);\n  return contextMenuNode;\n};\n\ntype ContextMenuParams = {\n  options: (ContextMenuOption | false | null | undefined)[];\n  top: ContextMenuProps[\"top\"];\n  left: ContextMenuProps[\"left\"];\n  actionManager: ContextMenuProps[\"actionManager\"];\n  appState: Readonly<AppState>;\n  container: HTMLElement;\n};\n\nconst handleClose = (container: HTMLElement) => {\n  const contextMenuNode = contextMenuNodeByContainer.get(container);\n  if (contextMenuNode) {\n    unmountComponentAtNode(contextMenuNode);\n    contextMenuNode.remove();\n    contextMenuNodeByContainer.delete(container);\n  }\n};\n\nexport default {\n  push(params: ContextMenuParams) {\n    const options = Array.of<ContextMenuOption>();\n    params.options.forEach((option) => {\n      if (option) {\n        options.push(option);\n      }\n    });\n    if (options.length) {\n      render(\n        <ContextMenu\n          top={params.top}\n          left={params.left}\n          options={options}\n          onCloseRequest={() => handleClose(params.container)}\n          actionManager={params.actionManager}\n          appState={params.appState}\n        />,\n        getContextMenuNode(params.container),\n      );\n    }\n  },\n};\n","import React from \"react\";\nimport { ActionManager } from \"../actions/manager\";\nimport { getNonDeletedElements } from \"../element\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport {\n  canChangeSharpness,\n  canHaveArrowheads,\n  getTargetElements,\n  hasBackground,\n  hasStrokeStyle,\n  hasStrokeWidth,\n  hasText,\n} from \"../scene\";\nimport { SHAPES } from \"../shapes\";\nimport { AppState, Zoom } from \"../types\";\nimport { capitalizeString, isTransparent, setCursorForShape } from \"../utils\";\nimport Stack from \"./Stack\";\nimport { ToolButton } from \"./ToolButton\";\n\nexport const SelectedShapeActions = ({\n  appState,\n  elements,\n  renderAction,\n  elementType,\n}: {\n  appState: AppState;\n  elements: readonly ExcalidrawElement[];\n  renderAction: ActionManager[\"renderAction\"];\n  elementType: ExcalidrawElement[\"type\"];\n}) => {\n  const targetElements = getTargetElements(\n    getNonDeletedElements(elements),\n    appState,\n  );\n  const isEditing = Boolean(appState.editingElement);\n  const isMobile = useIsMobile();\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const showFillIcons =\n    hasBackground(elementType) ||\n    targetElements.some(\n      (element) =>\n        hasBackground(element.type) && !isTransparent(element.backgroundColor),\n    );\n  const showChangeBackgroundIcons =\n    hasBackground(elementType) ||\n    targetElements.some((element) => hasBackground(element.type));\n\n  return (\n    <div className=\"panelColumn\">\n      {renderAction(\"changeStrokeColor\")}\n      {showChangeBackgroundIcons && renderAction(\"changeBackgroundColor\")}\n      {showFillIcons && renderAction(\"changeFillStyle\")}\n\n      {(hasStrokeWidth(elementType) ||\n        targetElements.some((element) => hasStrokeWidth(element.type))) &&\n        renderAction(\"changeStrokeWidth\")}\n\n      {(elementType === \"freedraw\" ||\n        targetElements.some((element) => element.type === \"freedraw\")) &&\n        renderAction(\"changeStrokeShape\")}\n\n      {(hasStrokeStyle(elementType) ||\n        targetElements.some((element) => hasStrokeStyle(element.type))) && (\n        <>\n          {renderAction(\"changeStrokeStyle\")}\n          {renderAction(\"changeSloppiness\")}\n        </>\n      )}\n\n      {(canChangeSharpness(elementType) ||\n        targetElements.some((element) => canChangeSharpness(element.type))) && (\n        <>{renderAction(\"changeSharpness\")}</>\n      )}\n\n      {(hasText(elementType) ||\n        targetElements.some((element) => hasText(element.type))) && (\n        <>\n          {renderAction(\"changeFontSize\")}\n\n          {renderAction(\"changeFontFamily\")}\n\n          {renderAction(\"changeTextAlign\")}\n        </>\n      )}\n\n      {(canHaveArrowheads(elementType) ||\n        targetElements.some((element) => canHaveArrowheads(element.type))) && (\n        <>{renderAction(\"changeArrowhead\")}</>\n      )}\n\n      {renderAction(\"changeOpacity\")}\n\n      <fieldset>\n        <legend>{t(\"labels.layers\")}</legend>\n        <div className=\"buttonList\">\n          {renderAction(\"sendToBack\")}\n          {renderAction(\"sendBackward\")}\n          {renderAction(\"bringToFront\")}\n          {renderAction(\"bringForward\")}\n        </div>\n      </fieldset>\n\n      {targetElements.length > 1 && (\n        <fieldset>\n          <legend>{t(\"labels.align\")}</legend>\n          <div className=\"buttonList\">\n            {\n              // swap this order for RTL so the button positions always match their action\n              // (i.e. the leftmost button aligns left)\n            }\n            {isRTL ? (\n              <>\n                {renderAction(\"alignRight\")}\n                {renderAction(\"alignHorizontallyCentered\")}\n                {renderAction(\"alignLeft\")}\n              </>\n            ) : (\n              <>\n                {renderAction(\"alignLeft\")}\n                {renderAction(\"alignHorizontallyCentered\")}\n                {renderAction(\"alignRight\")}\n              </>\n            )}\n            {targetElements.length > 2 &&\n              renderAction(\"distributeHorizontally\")}\n            <div className=\"iconRow\">\n              {renderAction(\"alignTop\")}\n              {renderAction(\"alignVerticallyCentered\")}\n              {renderAction(\"alignBottom\")}\n              {targetElements.length > 2 &&\n                renderAction(\"distributeVertically\")}\n            </div>\n          </div>\n        </fieldset>\n      )}\n      {!isMobile && !isEditing && targetElements.length > 0 && (\n        <fieldset>\n          <legend>{t(\"labels.actions\")}</legend>\n          <div className=\"buttonList\">\n            {renderAction(\"duplicateSelection\")}\n            {renderAction(\"deleteSelectedElements\")}\n            {renderAction(\"group\")}\n            {renderAction(\"ungroup\")}\n          </div>\n        </fieldset>\n      )}\n    </div>\n  );\n};\n\nexport const ShapesSwitcher = ({\n  canvas,\n  elementType,\n  setAppState,\n}: {\n  canvas: HTMLCanvasElement | null;\n  elementType: ExcalidrawElement[\"type\"];\n  setAppState: React.Component<any, AppState>[\"setState\"];\n}) => (\n  <>\n    {SHAPES.map(({ value, icon, key }, index) => {\n      const label = t(`toolBar.${value}`);\n      const letter = typeof key === \"string\" ? key : key[0];\n      const shortcut = `${capitalizeString(letter)} ${t(\"helpDialog.or\")} ${\n        index + 1\n      }`;\n      return (\n        <ToolButton\n          className=\"Shape\"\n          key={value}\n          type=\"radio\"\n          icon={icon}\n          checked={elementType === value}\n          name=\"editor-current-shape\"\n          title={`${capitalizeString(label)} — ${shortcut}`}\n          keyBindingLabel={`${index + 1}`}\n          aria-label={capitalizeString(label)}\n          aria-keyshortcuts={shortcut}\n          data-testid={value}\n          onChange={() => {\n            setAppState({\n              elementType: value,\n              multiElement: null,\n              selectedElementIds: {},\n            });\n            setCursorForShape(canvas, value);\n            setAppState({});\n          }}\n        />\n      );\n    })}\n  </>\n);\n\nexport const ZoomActions = ({\n  renderAction,\n  zoom,\n}: {\n  renderAction: ActionManager[\"renderAction\"];\n  zoom: Zoom;\n}) => (\n  <Stack.Col gap={1}>\n    <Stack.Row gap={1} align=\"center\">\n      {renderAction(\"zoomIn\")}\n      {renderAction(\"zoomOut\")}\n      {renderAction(\"resetZoom\")}\n      <div style={{ marginInlineStart: 4 }}>\n        {(zoom.value * 100).toFixed(0)}%\n      </div>\n    </Stack.Row>\n  </Stack.Col>\n);\n","import React from \"react\";\nimport { ActionManager } from \"../actions/manager\";\nimport { AppState } from \"../types\";\n\nexport const BackgroundPickerAndDarkModeToggle = ({\n  appState,\n  setAppState,\n  actionManager,\n  showThemeBtn,\n}: {\n  actionManager: ActionManager;\n  appState: AppState;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  showThemeBtn: boolean;\n}) => (\n  <div style={{ display: \"flex\" }}>\n    {actionManager.renderAction(\"changeViewBackgroundColor\")}\n    {showThemeBtn && actionManager.renderAction(\"toggleTheme\")}\n  </div>\n);\n","import React from \"react\";\nimport clsx from \"clsx\";\nimport { ToolButton } from \"./ToolButton\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport { users } from \"./icons\";\n\nimport \"./CollabButton.scss\";\n\nconst CollabButton = ({\n  isCollaborating,\n  collaboratorCount,\n  onClick,\n}: {\n  isCollaborating: boolean;\n  collaboratorCount: number;\n  onClick: () => void;\n}) => {\n  return (\n    <>\n      <ToolButton\n        className={clsx(\"CollabButton\", {\n          \"is-collaborating\": isCollaborating,\n        })}\n        onClick={onClick}\n        icon={users}\n        type=\"button\"\n        title={t(\"labels.liveCollaboration\")}\n        aria-label={t(\"labels.liveCollaboration\")}\n        showAriaLabel={useIsMobile()}\n      >\n        {collaboratorCount > 0 && (\n          <div className=\"CollabButton-collaborators\">{collaboratorCount}</div>\n        )}\n      </ToolButton>\n    </>\n  );\n};\n\nexport default CollabButton;\n","import React, { useEffect, useRef, useState } from \"react\";\nimport { render, unmountComponentAtNode } from \"react-dom\";\nimport { ActionsManagerInterface } from \"../actions/types\";\nimport { probablySupportsClipboardBlob } from \"../clipboard\";\nimport { canvasToBlob } from \"../data/blob\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { CanvasError } from \"../errors\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"./App\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { exportToCanvas } from \"../scene/export\";\nimport { AppState } from \"../types\";\nimport { Dialog } from \"./Dialog\";\nimport { clipboard, exportImage } from \"./icons\";\nimport Stack from \"./Stack\";\nimport { ToolButton } from \"./ToolButton\";\nimport \"./ExportDialog.scss\";\nimport { supported as fsSupported } from \"browser-fs-access\";\nimport OpenColor from \"open-color\";\nimport { CheckboxItem } from \"./CheckboxItem\";\nimport { DEFAULT_EXPORT_PADDING } from \"../constants\";\n\nconst supportsContextFilters =\n  \"filter\" in document.createElement(\"canvas\").getContext(\"2d\")!;\n\nexport const ErrorCanvasPreview = () => {\n  return (\n    <div>\n      <h3>{t(\"canvasError.cannotShowPreview\")}</h3>\n      <p>\n        <span>{t(\"canvasError.canvasTooBig\")}</span>\n      </p>\n      <em>({t(\"canvasError.canvasTooBigTip\")})</em>\n    </div>\n  );\n};\n\nconst renderPreview = (\n  content: HTMLCanvasElement | Error,\n  previewNode: HTMLDivElement,\n) => {\n  unmountComponentAtNode(previewNode);\n  previewNode.innerHTML = \"\";\n  if (content instanceof HTMLCanvasElement) {\n    previewNode.appendChild(content);\n  } else {\n    render(<ErrorCanvasPreview />, previewNode);\n  }\n};\n\nexport type ExportCB = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  scale?: number,\n) => void;\n\nconst ExportButton: React.FC<{\n  color: keyof OpenColor;\n  onClick: () => void;\n  title: string;\n  shade?: number;\n}> = ({ children, title, onClick, color, shade = 6 }) => {\n  return (\n    <button\n      className=\"ExportDialog-imageExportButton\"\n      style={{\n        [\"--button-color\" as any]: OpenColor[color][shade],\n        [\"--button-color-darker\" as any]: OpenColor[color][shade + 1],\n        [\"--button-color-darkest\" as any]: OpenColor[color][shade + 2],\n      }}\n      title={title}\n      aria-label={title}\n      onClick={onClick}\n    >\n      {children}\n    </button>\n  );\n};\n\nconst ImageExportModal = ({\n  elements,\n  appState,\n  exportPadding = DEFAULT_EXPORT_PADDING,\n  actionManager,\n  onExportToPng,\n  onExportToSvg,\n  onExportToClipboard,\n}: {\n  appState: AppState;\n  elements: readonly NonDeletedExcalidrawElement[];\n  exportPadding?: number;\n  actionManager: ActionsManagerInterface;\n  onExportToPng: ExportCB;\n  onExportToSvg: ExportCB;\n  onExportToClipboard: ExportCB;\n  onCloseRequest: () => void;\n}) => {\n  const someElementIsSelected = isSomeElementSelected(elements, appState);\n  const [exportSelected, setExportSelected] = useState(someElementIsSelected);\n  const previewRef = useRef<HTMLDivElement>(null);\n  const { exportBackground, viewBackgroundColor } = appState;\n\n  const exportedElements = exportSelected\n    ? getSelectedElements(elements, appState)\n    : elements;\n\n  useEffect(() => {\n    setExportSelected(someElementIsSelected);\n  }, [someElementIsSelected]);\n\n  useEffect(() => {\n    const previewNode = previewRef.current;\n    if (!previewNode) {\n      return;\n    }\n    try {\n      const canvas = exportToCanvas(exportedElements, appState, {\n        exportBackground,\n        viewBackgroundColor,\n        exportPadding,\n      });\n\n      // if converting to blob fails, there's some problem that will\n      // likely prevent preview and export (e.g. canvas too big)\n      canvasToBlob(canvas)\n        .then(() => {\n          renderPreview(canvas, previewNode);\n        })\n        .catch((error) => {\n          console.error(error);\n          renderPreview(new CanvasError(), previewNode);\n        });\n    } catch (error) {\n      console.error(error);\n      renderPreview(new CanvasError(), previewNode);\n    }\n  }, [\n    appState,\n    exportedElements,\n    exportBackground,\n    exportPadding,\n    viewBackgroundColor,\n  ]);\n\n  return (\n    <div className=\"ExportDialog\">\n      <div className=\"ExportDialog__preview\" ref={previewRef} />\n      {supportsContextFilters &&\n        actionManager.renderAction(\"exportWithDarkMode\")}\n      <div style={{ display: \"grid\", gridTemplateColumns: \"1fr\" }}>\n        <div\n          style={{\n            display: \"grid\",\n            gridTemplateColumns: \"repeat(auto-fit, minmax(190px, 1fr))\",\n            // dunno why this is needed, but when the items wrap it creates\n            // an overflow\n            overflow: \"hidden\",\n          }}\n        >\n          {actionManager.renderAction(\"changeExportBackground\")}\n          {someElementIsSelected && (\n            <CheckboxItem\n              checked={exportSelected}\n              onChange={(checked) => setExportSelected(checked)}\n            >\n              {t(\"labels.onlySelected\")}\n            </CheckboxItem>\n          )}\n          {actionManager.renderAction(\"changeExportEmbedScene\")}\n        </div>\n      </div>\n      <div style={{ display: \"flex\", alignItems: \"center\", marginTop: \".6em\" }}>\n        <Stack.Row gap={2}>\n          {actionManager.renderAction(\"changeExportScale\")}\n        </Stack.Row>\n        <p style={{ marginLeft: \"1em\", userSelect: \"none\" }}>Scale</p>\n      </div>\n      <div\n        style={{\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          margin: \".6em 0\",\n        }}\n      >\n        {!fsSupported && actionManager.renderAction(\"changeProjectName\")}\n      </div>\n      <Stack.Row gap={2} justifyContent=\"center\" style={{ margin: \"2em 0\" }}>\n        <ExportButton\n          color=\"indigo\"\n          title={t(\"buttons.exportToPng\")}\n          aria-label={t(\"buttons.exportToPng\")}\n          onClick={() => onExportToPng(exportedElements)}\n        >\n          PNG\n        </ExportButton>\n        <ExportButton\n          color=\"red\"\n          title={t(\"buttons.exportToSvg\")}\n          aria-label={t(\"buttons.exportToSvg\")}\n          onClick={() => onExportToSvg(exportedElements)}\n        >\n          SVG\n        </ExportButton>\n        {probablySupportsClipboardBlob && (\n          <ExportButton\n            title={t(\"buttons.copyPngToClipboard\")}\n            onClick={() => onExportToClipboard(exportedElements)}\n            color=\"gray\"\n            shade={7}\n          >\n            {clipboard}\n          </ExportButton>\n        )}\n      </Stack.Row>\n    </div>\n  );\n};\n\nexport const ImageExportDialog = ({\n  elements,\n  appState,\n  exportPadding = DEFAULT_EXPORT_PADDING,\n  actionManager,\n  onExportToPng,\n  onExportToSvg,\n  onExportToClipboard,\n}: {\n  appState: AppState;\n  elements: readonly NonDeletedExcalidrawElement[];\n  exportPadding?: number;\n  actionManager: ActionsManagerInterface;\n  onExportToPng: ExportCB;\n  onExportToSvg: ExportCB;\n  onExportToClipboard: ExportCB;\n}) => {\n  const [modalIsShown, setModalIsShown] = useState(false);\n\n  const handleClose = React.useCallback(() => {\n    setModalIsShown(false);\n  }, []);\n\n  return (\n    <>\n      <ToolButton\n        onClick={() => {\n          setModalIsShown(true);\n        }}\n        data-testid=\"image-export-button\"\n        icon={exportImage}\n        type=\"button\"\n        aria-label={t(\"buttons.exportImage\")}\n        showAriaLabel={useIsMobile()}\n        title={t(\"buttons.exportImage\")}\n      />\n      {modalIsShown && (\n        <Dialog onCloseRequest={handleClose} title={t(\"buttons.exportImage\")}>\n          <ImageExportModal\n            elements={elements}\n            appState={appState}\n            exportPadding={exportPadding}\n            actionManager={actionManager}\n            onExportToPng={onExportToPng}\n            onExportToSvg={onExportToSvg}\n            onExportToClipboard={onExportToClipboard}\n            onCloseRequest={handleClose}\n          />\n        </Dialog>\n      )}\n    </>\n  );\n};\n","import \"./FixedSideContainer.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype FixedSideContainerProps = {\n  children: React.ReactNode;\n  side: \"top\" | \"left\" | \"right\";\n  className?: string;\n};\n\nexport const FixedSideContainer = ({\n  children,\n  side,\n  className,\n}: FixedSideContainerProps) => (\n  <div\n    className={clsx(\n      \"FixedSideContainer\",\n      `FixedSideContainer_side_${side}`,\n      className,\n    )}\n  >\n    {children}\n  </div>\n);\n","import React from \"react\";\nimport { t } from \"../i18n\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { getSelectedElements } from \"../scene\";\n\nimport \"./HintViewer.scss\";\nimport { AppState } from \"../types\";\nimport { isLinearElement, isTextElement } from \"../element/typeChecks\";\nimport { getShortcutKey } from \"../utils\";\n\ninterface Hint {\n  appState: AppState;\n  elements: readonly NonDeletedExcalidrawElement[];\n}\n\nconst getHints = ({ appState, elements }: Hint) => {\n  const { elementType, isResizing, isRotating, lastPointerDownWith } = appState;\n  const multiMode = appState.multiElement !== null;\n  if (elementType === \"arrow\" || elementType === \"line\") {\n    if (!multiMode) {\n      return t(\"hints.linearElement\");\n    }\n    return t(\"hints.linearElementMulti\");\n  }\n\n  if (elementType === \"freedraw\") {\n    return t(\"hints.freeDraw\");\n  }\n\n  if (elementType === \"text\") {\n    return t(\"hints.text\");\n  }\n\n  const selectedElements = getSelectedElements(elements, appState);\n  if (\n    isResizing &&\n    lastPointerDownWith === \"mouse\" &&\n    selectedElements.length === 1\n  ) {\n    const targetElement = selectedElements[0];\n    if (isLinearElement(targetElement) && targetElement.points.length === 2) {\n      return t(\"hints.lockAngle\");\n    }\n    return t(\"hints.resize\");\n  }\n\n  if (isRotating && lastPointerDownWith === \"mouse\") {\n    return t(\"hints.rotate\");\n  }\n\n  if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n    if (appState.editingLinearElement) {\n      return appState.editingLinearElement.activePointIndex\n        ? t(\"hints.lineEditor_pointSelected\")\n        : t(\"hints.lineEditor_nothingSelected\");\n    }\n    return t(\"hints.lineEditor_info\");\n  }\n\n  if (selectedElements.length === 1 && isTextElement(selectedElements[0])) {\n    return t(\"hints.text_selected\");\n  }\n\n  if (appState.editingElement && isTextElement(appState.editingElement)) {\n    return t(\"hints.text_editing\");\n  }\n\n  return null;\n};\n\nexport const HintViewer = ({ appState, elements }: Hint) => {\n  let hint = getHints({\n    appState,\n    elements,\n  });\n  if (!hint) {\n    return null;\n  }\n\n  hint = getShortcutKey(hint);\n\n  return (\n    <div className=\"HintViewer\">\n      <span>{hint}</span>\n    </div>\n  );\n};\n","import \"./Island.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype IslandProps = {\n  children: React.ReactNode;\n  padding?: number;\n  className?: string | boolean;\n  style?: object;\n};\n\nexport const Island = React.forwardRef<HTMLDivElement, IslandProps>(\n  ({ children, padding, className, style }, ref) => (\n    <div\n      className={clsx(\"Island\", className)}\n      style={{ \"--padding\": padding, ...style }}\n      ref={ref}\n    >\n      {children}\n    </div>\n  ),\n);\n","import clsx from \"clsx\";\nimport oc from \"open-color\";\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { close } from \"../components/icons\";\nimport { MIME_TYPES } from \"../constants\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport { exportToSvg } from \"../scene/export\";\nimport { LibraryItem } from \"../types\";\nimport \"./LibraryUnit.scss\";\n\n// fa-plus\nconst PLUS_ICON = (\n  <svg viewBox=\"0 0 1792 1792\">\n    <path\n      fill=\"currentColor\"\n      d=\"M1600 736v192q0 40-28 68t-68 28h-416v416q0 40-28 68t-68 28h-192q-40 0-68-28t-28-68v-416h-416q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h416v-416q0-40 28-68t68-28h192q40 0 68 28t28 68v416h416q40 0 68 28t28 68z\"\n    />\n  </svg>\n);\n\nexport const LibraryUnit = ({\n  elements,\n  pendingElements,\n  onRemoveFromLibrary,\n  onClick,\n}: {\n  elements?: LibraryItem;\n  pendingElements?: LibraryItem;\n  onRemoveFromLibrary: () => void;\n  onClick: () => void;\n}) => {\n  const ref = useRef<HTMLDivElement | null>(null);\n  useEffect(() => {\n    const elementsToRender = elements || pendingElements;\n    if (!elementsToRender) {\n      return;\n    }\n    let svg: SVGSVGElement;\n    const current = ref.current!;\n\n    (async () => {\n      svg = await exportToSvg(elementsToRender, {\n        exportBackground: false,\n        viewBackgroundColor: oc.white,\n      });\n      for (const child of ref.current!.children) {\n        if (child.tagName !== \"svg\") {\n          continue;\n        }\n        current!.removeChild(child);\n      }\n      current!.appendChild(svg);\n    })();\n\n    return () => {\n      if (svg) {\n        current.removeChild(svg);\n      }\n    };\n  }, [elements, pendingElements]);\n\n  const [isHovered, setIsHovered] = useState(false);\n  const isMobile = useIsMobile();\n\n  const adder = (isHovered || isMobile) && pendingElements && (\n    <div className=\"library-unit__adder\">{PLUS_ICON}</div>\n  );\n\n  return (\n    <div\n      className={clsx(\"library-unit\", {\n        \"library-unit__active\": elements || pendingElements,\n      })}\n      onMouseEnter={() => setIsHovered(true)}\n      onMouseLeave={() => setIsHovered(false)}\n    >\n      <div\n        className={clsx(\"library-unit__dragger\", {\n          \"library-unit__pulse\": !!pendingElements,\n        })}\n        ref={ref}\n        draggable={!!elements}\n        onClick={!!elements || !!pendingElements ? onClick : undefined}\n        onDragStart={(event) => {\n          setIsHovered(false);\n          event.dataTransfer.setData(\n            MIME_TYPES.excalidrawlib,\n            JSON.stringify(elements),\n          );\n        }}\n      />\n      {adder}\n      {elements && (isHovered || isMobile) && (\n        <button\n          className=\"library-unit__removeFromLibrary\"\n          aria-label={t(\"labels.removeFromLibrary\")}\n          onClick={onRemoveFromLibrary}\n        >\n          {close}\n        </button>\n      )}\n    </div>\n  );\n};\n","import React from \"react\";\nimport { t } from \"../i18n\";\n\nexport const LoadingMessage = () => {\n  // !! KEEP THIS IN SYNC WITH index.html !!\n  return (\n    <div className=\"LoadingMessage\">\n      <span>{t(\"labels.loadingScene\")}</span>\n    </div>\n  );\n};\n","import \"./ToolIcon.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype LockIconSize = \"s\" | \"m\";\n\ntype LockIconProps = {\n  title?: string;\n  name?: string;\n  checked: boolean;\n  onChange?(): void;\n  zenModeEnabled?: boolean;\n};\n\nconst DEFAULT_SIZE: LockIconSize = \"m\";\n\nconst ICONS = {\n  CHECKED: (\n    <svg\n      width=\"1792\"\n      height=\"1792\"\n      viewBox=\"0 0 1792 1792\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <path d=\"M640 768h512v-192q0-106-75-181t-181-75-181 75-75 181v192zm832 96v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h32v-192q0-184 132-316t316-132 316 132 132 316v192h32q40 0 68 28t28 68z\" />\n    </svg>\n  ),\n  UNCHECKED: (\n    <svg\n      width=\"1792\"\n      height=\"1792\"\n      viewBox=\"0 0 1792 1792\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className=\"unlocked-icon rtl-mirror\"\n    >\n      <path d=\"M1728 576v256q0 26-19 45t-45 19h-64q-26 0-45-19t-19-45v-256q0-106-75-181t-181-75-181 75-75 181v192h96q40 0 68 28t28 68v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h672v-192q0-185 131.5-316.5t316.5-131.5 316.5 131.5 131.5 316.5z\" />\n    </svg>\n  ),\n};\n\nexport const LockButton = (props: LockIconProps) => {\n  return (\n    <label\n      className={clsx(\n        \"ToolIcon ToolIcon__lock ToolIcon_type_floating zen-mode-visibility\",\n        `ToolIcon_size_${DEFAULT_SIZE}`,\n        {\n          \"zen-mode-visibility--hidden\": props.zenModeEnabled,\n        },\n      )}\n      title={`${props.title} — Q`}\n    >\n      <input\n        className=\"ToolIcon_type_checkbox\"\n        type=\"checkbox\"\n        name={props.name}\n        onChange={props.onChange}\n        checked={props.checked}\n        aria-label={props.title}\n      />\n      <div className=\"ToolIcon__icon\">\n        {props.checked ? ICONS.CHECKED : ICONS.UNCHECKED}\n      </div>\n    </label>\n  );\n};\n","import React from \"react\";\nimport { t } from \"../i18n\";\nimport { useExcalidrawContainer } from \"./App\";\n\ninterface SectionProps extends React.HTMLProps<HTMLElement> {\n  heading: string;\n  children: React.ReactNode | ((header: React.ReactNode) => React.ReactNode);\n}\n\nexport const Section = ({ heading, children, ...props }: SectionProps) => {\n  const { id } = useExcalidrawContainer();\n  const header = (\n    <h2 className=\"visually-hidden\" id={`${id}-${heading}-title`}>\n      {t(`headings.${heading}`)}\n    </h2>\n  );\n  return (\n    <section {...props} aria-labelledby={`${id}-${heading}-title`}>\n      {typeof children === \"function\" ? (\n        children(header)\n      ) : (\n        <>\n          {header}\n          {children}\n        </>\n      )}\n    </section>\n  );\n};\n","import \"./UserList.scss\";\n\nimport React from \"react\";\nimport clsx from \"clsx\";\n\ntype UserListProps = {\n  children: React.ReactNode;\n  className?: string;\n  mobile?: boolean;\n};\n\nexport const UserList = ({ children, className, mobile }: UserListProps) => {\n  return (\n    <div className={clsx(\"UserList\", className, { UserList_mobile: mobile })}>\n      {children}\n    </div>\n  );\n};\n","import React from \"react\";\nimport clsx from \"clsx\";\nimport { t } from \"../i18n\";\nimport { AppState } from \"../types\";\nimport { capitalizeString } from \"../utils\";\n\nconst LIBRARY_ICON = (\n  <svg viewBox=\"0 0 576 512\">\n    <path\n      fill=\"currentColor\"\n      d=\"M542.22 32.05c-54.8 3.11-163.72 14.43-230.96 55.59-4.64 2.84-7.27 7.89-7.27 13.17v363.87c0 11.55 12.63 18.85 23.28 13.49 69.18-34.82 169.23-44.32 218.7-46.92 16.89-.89 30.02-14.43 30.02-30.66V62.75c.01-17.71-15.35-31.74-33.77-30.7zM264.73 87.64C197.5 46.48 88.58 35.17 33.78 32.05 15.36 31.01 0 45.04 0 62.75V400.6c0 16.24 13.13 29.78 30.02 30.66 49.49 2.6 149.59 12.11 218.77 46.95 10.62 5.35 23.21-1.94 23.21-13.46V100.63c0-5.29-2.62-10.14-7.27-12.99z\"\n    ></path>\n  </svg>\n);\n\nexport const LibraryButton: React.FC<{\n  appState: AppState;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n}> = ({ appState, setAppState }) => {\n  return (\n    <label\n      className={clsx(\n        \"ToolIcon ToolIcon_type_floating ToolIcon__library zen-mode-visibility\",\n        `ToolIcon_size_m`,\n        {\n          \"zen-mode-visibility--hidden\": appState.zenModeEnabled,\n        },\n      )}\n      title={`${capitalizeString(t(\"toolBar.library\"))} — 9`}\n      style={{ marginInlineStart: \"var(--space-factor)\" }}\n    >\n      <input\n        className=\"ToolIcon_type_checkbox\"\n        type=\"checkbox\"\n        name=\"editor-library\"\n        onChange={(event) => {\n          setAppState({ isLibraryOpen: event.target.checked });\n        }}\n        checked={appState.isLibraryOpen}\n        aria-label={capitalizeString(t(\"toolBar.library\"))}\n        aria-keyshortcuts=\"9\"\n      />\n      <div className=\"ToolIcon__icon\">{LIBRARY_ICON}</div>\n    </label>\n  );\n};\n","import React from \"react\";\nimport { AppState } from \"../types\";\nimport { ActionManager } from \"../actions/manager\";\nimport { t } from \"../i18n\";\nimport Stack from \"./Stack\";\nimport { showSelectedShapeActions } from \"../element\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { FixedSideContainer } from \"./FixedSideContainer\";\nimport { Island } from \"./Island\";\nimport { HintViewer } from \"./HintViewer\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { SelectedShapeActions, ShapesSwitcher } from \"./Actions\";\nimport { Section } from \"./Section\";\nimport CollabButton from \"./CollabButton\";\nimport { SCROLLBAR_WIDTH, SCROLLBAR_MARGIN } from \"../scene/scrollbars\";\nimport { LockButton } from \"./LockButton\";\nimport { UserList } from \"./UserList\";\nimport { BackgroundPickerAndDarkModeToggle } from \"./BackgroundPickerAndDarkModeToggle\";\nimport { LibraryButton } from \"./LibraryButton\";\n\ntype MobileMenuProps = {\n  appState: AppState;\n  actionManager: ActionManager;\n  renderJSONExportDialog: () => React.ReactNode;\n  renderImageExportDialog: () => React.ReactNode;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  elements: readonly NonDeletedExcalidrawElement[];\n  libraryMenu: JSX.Element | null;\n  onCollabButtonClick?: () => void;\n  onLockToggle: () => void;\n  canvas: HTMLCanvasElement | null;\n  isCollaborating: boolean;\n  renderCustomFooter?: (isMobile: boolean, appState: AppState) => JSX.Element;\n  viewModeEnabled: boolean;\n  showThemeBtn: boolean;\n};\n\nexport const MobileMenu = ({\n  appState,\n  elements,\n  libraryMenu,\n  actionManager,\n  renderJSONExportDialog,\n  renderImageExportDialog,\n  setAppState,\n  onCollabButtonClick,\n  onLockToggle,\n  canvas,\n  isCollaborating,\n  renderCustomFooter,\n  viewModeEnabled,\n  showThemeBtn,\n}: MobileMenuProps) => {\n  const renderToolbar = () => {\n    return (\n      <FixedSideContainer side=\"top\" className=\"App-top-bar\">\n        <Section heading=\"shapes\">\n          {(heading) => (\n            <Stack.Col gap={4} align=\"center\">\n              <Stack.Row gap={1}>\n                <Island padding={1}>\n                  {heading}\n                  <Stack.Row gap={1}>\n                    <ShapesSwitcher\n                      canvas={canvas}\n                      elementType={appState.elementType}\n                      setAppState={setAppState}\n                    />\n                  </Stack.Row>\n                </Island>\n                <LockButton\n                  checked={appState.elementLocked}\n                  onChange={onLockToggle}\n                  title={t(\"toolBar.lock\")}\n                />\n                <LibraryButton appState={appState} setAppState={setAppState} />\n              </Stack.Row>\n              {libraryMenu}\n            </Stack.Col>\n          )}\n        </Section>\n        <HintViewer appState={appState} elements={elements} />\n      </FixedSideContainer>\n    );\n  };\n\n  const renderAppToolbar = () => {\n    if (viewModeEnabled) {\n      return (\n        <div className=\"App-toolbar-content\">\n          {actionManager.renderAction(\"toggleCanvasMenu\")}\n        </div>\n      );\n    }\n    return (\n      <div className=\"App-toolbar-content\">\n        {actionManager.renderAction(\"toggleCanvasMenu\")}\n        {actionManager.renderAction(\"toggleEditMenu\")}\n        {actionManager.renderAction(\"undo\")}\n        {actionManager.renderAction(\"redo\")}\n        {actionManager.renderAction(\n          appState.multiElement ? \"finalize\" : \"duplicateSelection\",\n        )}\n        {actionManager.renderAction(\"deleteSelectedElements\")}\n      </div>\n    );\n  };\n\n  const renderCanvasActions = () => {\n    if (viewModeEnabled) {\n      return (\n        <>\n          {renderJSONExportDialog()}\n          {renderImageExportDialog()}\n        </>\n      );\n    }\n    return (\n      <>\n        {actionManager.renderAction(\"clearCanvas\")}\n        {actionManager.renderAction(\"loadScene\")}\n        {renderJSONExportDialog()}\n        {renderImageExportDialog()}\n        {onCollabButtonClick && (\n          <CollabButton\n            isCollaborating={isCollaborating}\n            collaboratorCount={appState.collaborators.size}\n            onClick={onCollabButtonClick}\n          />\n        )}\n        {\n          <BackgroundPickerAndDarkModeToggle\n            actionManager={actionManager}\n            appState={appState}\n            setAppState={setAppState}\n            showThemeBtn={showThemeBtn}\n          />\n        }\n      </>\n    );\n  };\n  return (\n    <>\n      {!viewModeEnabled && renderToolbar()}\n      <div\n        className=\"App-bottom-bar\"\n        style={{\n          marginBottom: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,\n          marginLeft: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,\n          marginRight: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,\n        }}\n      >\n        <Island padding={0}>\n          {appState.openMenu === \"canvas\" ? (\n            <Section className=\"App-mobile-menu\" heading=\"canvasActions\">\n              <div className=\"panelColumn\">\n                <Stack.Col gap={4}>\n                  {renderCanvasActions()}\n                  {renderCustomFooter?.(true, appState)}\n                  {appState.collaborators.size > 0 && (\n                    <fieldset>\n                      <legend>{t(\"labels.collaborators\")}</legend>\n                      <UserList mobile>\n                        {Array.from(appState.collaborators)\n                          // Collaborator is either not initialized or is actually the current user.\n                          .filter(\n                            ([_, client]) => Object.keys(client).length !== 0,\n                          )\n                          .map(([clientId, client]) => (\n                            <React.Fragment key={clientId}>\n                              {actionManager.renderAction(\n                                \"goToCollaborator\",\n                                clientId,\n                              )}\n                            </React.Fragment>\n                          ))}\n                      </UserList>\n                    </fieldset>\n                  )}\n                </Stack.Col>\n              </div>\n            </Section>\n          ) : appState.openMenu === \"shape\" &&\n            !viewModeEnabled &&\n            showSelectedShapeActions(appState, elements) ? (\n            <Section className=\"App-mobile-menu\" heading=\"selectedShapeActions\">\n              <SelectedShapeActions\n                appState={appState}\n                elements={elements}\n                renderAction={actionManager.renderAction}\n                elementType={appState.elementType}\n              />\n            </Section>\n          ) : null}\n          <footer className=\"App-toolbar\">\n            {renderAppToolbar()}\n            {appState.scrolledOutside && !appState.openMenu && (\n              <button\n                className=\"scroll-back-to-content\"\n                onClick={() => {\n                  setAppState({\n                    ...calculateScrollCenter(elements, appState, canvas),\n                  });\n                }}\n              >\n                {t(\"buttons.scrollBackToContent\")}\n              </button>\n            )}\n          </footer>\n        </Island>\n      </div>\n    </>\n  );\n};\n","import oc from \"open-color\";\nimport React, { useLayoutEffect, useRef, useState } from \"react\";\nimport { trackEvent } from \"../analytics\";\nimport { ChartElements, renderSpreadsheet, Spreadsheet } from \"../charts\";\nimport { ChartType } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { exportToSvg } from \"../scene/export\";\nimport { AppState, LibraryItem } from \"../types\";\nimport { Dialog } from \"./Dialog\";\nimport \"./PasteChartDialog.scss\";\n\ntype OnInsertChart = (chartType: ChartType, elements: ChartElements) => void;\n\nconst ChartPreviewBtn = (props: {\n  spreadsheet: Spreadsheet | null;\n  chartType: ChartType;\n  selected: boolean;\n  onClick: OnInsertChart;\n}) => {\n  const previewRef = useRef<HTMLDivElement | null>(null);\n  const [chartElements, setChartElements] = useState<ChartElements | null>(\n    null,\n  );\n\n  useLayoutEffect(() => {\n    if (!props.spreadsheet) {\n      return;\n    }\n\n    const elements = renderSpreadsheet(\n      props.chartType,\n      props.spreadsheet,\n      0,\n      0,\n    );\n    setChartElements(elements);\n    let svg: SVGSVGElement;\n    const previewNode = previewRef.current!;\n\n    (async () => {\n      svg = await exportToSvg(elements, {\n        exportBackground: false,\n        viewBackgroundColor: oc.white,\n      });\n\n      previewNode.appendChild(svg);\n\n      if (props.selected) {\n        (previewNode.parentNode as HTMLDivElement).focus();\n      }\n    })();\n\n    return () => {\n      previewNode.removeChild(svg);\n    };\n  }, [props.spreadsheet, props.chartType, props.selected]);\n\n  return (\n    <button\n      className=\"ChartPreview\"\n      onClick={() => {\n        if (chartElements) {\n          props.onClick(props.chartType, chartElements);\n        }\n      }}\n    >\n      <div ref={previewRef} />\n    </button>\n  );\n};\n\nexport const PasteChartDialog = ({\n  setAppState,\n  appState,\n  onClose,\n  onInsertChart,\n}: {\n  appState: AppState;\n  onClose: () => void;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  onInsertChart: (elements: LibraryItem) => void;\n}) => {\n  const handleClose = React.useCallback(() => {\n    if (onClose) {\n      onClose();\n    }\n  }, [onClose]);\n\n  const handleChartClick = (chartType: ChartType, elements: ChartElements) => {\n    onInsertChart(elements);\n    trackEvent(\"magic\", \"chart\", chartType);\n    setAppState({\n      currentChartType: chartType,\n      pasteDialog: {\n        shown: false,\n        data: null,\n      },\n    });\n  };\n\n  return (\n    <Dialog\n      small\n      onCloseRequest={handleClose}\n      title={t(\"labels.pasteCharts\")}\n      className={\"PasteChartDialog\"}\n      autofocus={false}\n    >\n      <div className={\"container\"}>\n        <ChartPreviewBtn\n          chartType=\"bar\"\n          spreadsheet={appState.pasteDialog.data}\n          selected={appState.currentChartType === \"bar\"}\n          onClick={handleChartClick}\n        />\n        <ChartPreviewBtn\n          chartType=\"line\"\n          spreadsheet={appState.pasteDialog.data}\n          selected={appState.currentChartType === \"line\"}\n          onClick={handleChartClick}\n        />\n      </div>\n    </Dialog>\n  );\n};\n","import React from \"react\";\nimport { t } from \"../i18n\";\nimport { isDarwin, isWindows } from \"../keys\";\nimport { Dialog } from \"./Dialog\";\nimport { getShortcutKey } from \"../utils\";\nimport \"./HelpDialog.scss\";\n\nconst Header = () => (\n  <div className=\"HelpDialog--header\">\n    <a\n      className=\"HelpDialog--btn\"\n      href=\"https://github.com/excalidraw/excalidraw#documentation\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      {t(\"helpDialog.documentation\")}\n    </a>\n    <a\n      className=\"HelpDialog--btn\"\n      href=\"https://blog.excalidraw.com\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      {t(\"helpDialog.blog\")}\n    </a>\n    <a\n      className=\"HelpDialog--btn\"\n      href=\"https://github.com/excalidraw/excalidraw/issues\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      {t(\"helpDialog.github\")}\n    </a>\n  </div>\n);\n\nconst Section = (props: { title: string; children: React.ReactNode }) => (\n  <>\n    <h3>{props.title}</h3>\n    {props.children}\n  </>\n);\n\nconst Columns = (props: { children: React.ReactNode }) => (\n  <div\n    style={{\n      display: \"flex\",\n      flexDirection: \"row\",\n      flexWrap: \"wrap\",\n      justifyContent: \"space-between\",\n    }}\n  >\n    {props.children}\n  </div>\n);\n\nconst Column = (props: { children: React.ReactNode }) => (\n  <div style={{ width: \"49%\" }}>{props.children}</div>\n);\n\nconst ShortcutIsland = (props: {\n  caption: string;\n  children: React.ReactNode;\n}) => (\n  <div className=\"HelpDialog--island\">\n    <h3 className=\"HelpDialog--island-title\">{props.caption}</h3>\n    {props.children}\n  </div>\n);\n\nconst Shortcut = (props: {\n  label: string;\n  shortcuts: string[];\n  isOr: boolean;\n}) => {\n  return (\n    <div className=\"HelpDialog--shortcut\">\n      <div\n        style={{\n          display: \"flex\",\n          margin: \"0\",\n          padding: \"4px 8px\",\n          alignItems: \"center\",\n        }}\n      >\n        <div\n          style={{\n            lineHeight: 1.4,\n          }}\n        >\n          {props.label}\n        </div>\n        <div\n          style={{\n            display: \"flex\",\n            flex: \"0 0 auto\",\n            justifyContent: \"flex-end\",\n            marginInlineStart: \"auto\",\n            minWidth: \"30%\",\n          }}\n        >\n          {props.shortcuts.map((shortcut, index) => (\n            <React.Fragment key={index}>\n              <ShortcutKey>{shortcut}</ShortcutKey>\n              {props.isOr &&\n                index !== props.shortcuts.length - 1 &&\n                t(\"helpDialog.or\")}\n            </React.Fragment>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nShortcut.defaultProps = {\n  isOr: true,\n};\n\nconst ShortcutKey = (props: { children: React.ReactNode }) => (\n  <kbd className=\"HelpDialog--key\" {...props} />\n);\n\nexport const HelpDialog = ({ onClose }: { onClose?: () => void }) => {\n  const handleClose = React.useCallback(() => {\n    if (onClose) {\n      onClose();\n    }\n  }, [onClose]);\n\n  return (\n    <>\n      <Dialog\n        onCloseRequest={handleClose}\n        title={t(\"helpDialog.title\")}\n        className={\"HelpDialog\"}\n      >\n        <Header />\n        <Section title={t(\"helpDialog.shortcuts\")}>\n          <Columns>\n            <Column>\n              <ShortcutIsland caption={t(\"helpDialog.shapes\")}>\n                <Shortcut\n                  label={t(\"toolBar.selection\")}\n                  shortcuts={[\"V\", \"1\"]}\n                />\n                <Shortcut\n                  label={t(\"toolBar.rectangle\")}\n                  shortcuts={[\"R\", \"2\"]}\n                />\n                <Shortcut label={t(\"toolBar.diamond\")} shortcuts={[\"D\", \"3\"]} />\n                <Shortcut label={t(\"toolBar.ellipse\")} shortcuts={[\"E\", \"4\"]} />\n                <Shortcut label={t(\"toolBar.arrow\")} shortcuts={[\"A\", \"5\"]} />\n                <Shortcut label={t(\"toolBar.line\")} shortcuts={[\"P\", \"6\"]} />\n                <Shortcut\n                  label={t(\"toolBar.freedraw\")}\n                  shortcuts={[\"Shift+P\", \"7\"]}\n                />\n                <Shortcut label={t(\"toolBar.text\")} shortcuts={[\"T\", \"8\"]} />\n                <Shortcut\n                  label={t(\"helpDialog.editSelectedShape\")}\n                  shortcuts={[\n                    getShortcutKey(\"Enter\"),\n                    t(\"helpDialog.doubleClick\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.textNewLine\")}\n                  shortcuts={[\n                    getShortcutKey(\"Enter\"),\n                    getShortcutKey(\"Shift+Enter\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.textFinish\")}\n                  shortcuts={[\n                    getShortcutKey(\"Esc\"),\n                    getShortcutKey(\"CtrlOrCmd+Enter\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.curvedArrow\")}\n                  shortcuts={[\n                    \"A\",\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                  ]}\n                  isOr={false}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.curvedLine\")}\n                  shortcuts={[\n                    \"L\",\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                    t(\"helpDialog.click\"),\n                  ]}\n                  isOr={false}\n                />\n                <Shortcut label={t(\"toolBar.lock\")} shortcuts={[\"Q\"]} />\n                <Shortcut\n                  label={t(\"helpDialog.preventBinding\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd\")]}\n                />\n              </ShortcutIsland>\n              <ShortcutIsland caption={t(\"helpDialog.view\")}>\n                <Shortcut\n                  label={t(\"buttons.zoomIn\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd++\")]}\n                />\n                <Shortcut\n                  label={t(\"buttons.zoomOut\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+-\")]}\n                />\n                <Shortcut\n                  label={t(\"buttons.resetZoom\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+0\")]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.zoomToFit\")}\n                  shortcuts={[\"Shift+1\"]}\n                />\n                <Shortcut\n                  label={t(\"helpDialog.zoomToSelection\")}\n                  shortcuts={[\"Shift+2\"]}\n                />\n                <Shortcut label={t(\"buttons.fullScreen\")} shortcuts={[\"F\"]} />\n                <Shortcut\n                  label={t(\"buttons.zenMode\")}\n                  shortcuts={[getShortcutKey(\"Alt+Z\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.showGrid\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+'\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.viewMode\")}\n                  shortcuts={[getShortcutKey(\"Alt+R\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.toggleTheme\")}\n                  shortcuts={[getShortcutKey(\"Alt+Shift+D\")]}\n                />\n                <Shortcut\n                  label={t(\"stats.title\")}\n                  shortcuts={[getShortcutKey(\"Alt+/\")]}\n                />\n              </ShortcutIsland>\n            </Column>\n            <Column>\n              <ShortcutIsland caption={t(\"helpDialog.editor\")}>\n                <Shortcut\n                  label={t(\"labels.selectAll\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+A\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.multiSelect\")}\n                  shortcuts={[getShortcutKey(`Shift+${t(\"helpDialog.click\")}`)]}\n                />\n                <Shortcut\n                  label={t(\"labels.moveCanvas\")}\n                  shortcuts={[\n                    getShortcutKey(`Space+${t(\"helpDialog.drag\")}`),\n                    getShortcutKey(`Wheel+${t(\"helpDialog.drag\")}`),\n                  ]}\n                  isOr={true}\n                />\n                <Shortcut\n                  label={t(\"labels.cut\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+X\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.copy\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+C\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.paste\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+V\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.copyAsPng\")}\n                  shortcuts={[getShortcutKey(\"Shift+Alt+C\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.copyStyles\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Alt+C\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.pasteStyles\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Alt+V\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.delete\")}\n                  shortcuts={[getShortcutKey(\"Del\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.sendToBack\")}\n                  shortcuts={[\n                    isDarwin\n                      ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n                      : getShortcutKey(\"CtrlOrCmd+Shift+[\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"labels.bringToFront\")}\n                  shortcuts={[\n                    isDarwin\n                      ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n                      : getShortcutKey(\"CtrlOrCmd+Shift+]\"),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"labels.sendBackward\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+[\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.bringForward\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+]\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignTop\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Up\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignBottom\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Down\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignLeft\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Left\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.alignRight\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Right\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.duplicateSelection\")}\n                  shortcuts={[\n                    getShortcutKey(\"CtrlOrCmd+D\"),\n                    getShortcutKey(`Alt+${t(\"helpDialog.drag\")}`),\n                  ]}\n                />\n                <Shortcut\n                  label={t(\"buttons.undo\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Z\")]}\n                />\n                <Shortcut\n                  label={t(\"buttons.redo\")}\n                  shortcuts={\n                    isWindows\n                      ? [\n                          getShortcutKey(\"CtrlOrCmd+Y\"),\n                          getShortcutKey(\"CtrlOrCmd+Shift+Z\"),\n                        ]\n                      : [getShortcutKey(\"CtrlOrCmd+Shift+Z\")]\n                  }\n                />\n                <Shortcut\n                  label={t(\"labels.group\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+G\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.ungroup\")}\n                  shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+G\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.flipHorizontal\")}\n                  shortcuts={[getShortcutKey(\"Shift+H\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.flipVertical\")}\n                  shortcuts={[getShortcutKey(\"Shift+V\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.showStroke\")}\n                  shortcuts={[getShortcutKey(\"S\")]}\n                />\n                <Shortcut\n                  label={t(\"labels.showBackground\")}\n                  shortcuts={[getShortcutKey(\"G\")]}\n                />\n              </ShortcutIsland>\n            </Column>\n          </Columns>\n        </Section>\n      </Dialog>\n    </>\n  );\n};\n","import OpenColor from \"open-color\";\n\nimport \"./Card.scss\";\n\nexport const Card: React.FC<{\n  color: keyof OpenColor;\n}> = ({ children, color }) => {\n  return (\n    <div\n      className=\"Card\"\n      style={{\n        [\"--card-color\" as any]: OpenColor[color][7],\n        [\"--card-color-darker\" as any]: OpenColor[color][8],\n        [\"--card-color-darkest\" as any]: OpenColor[color][9],\n      }}\n    >\n      {children}\n    </div>\n  );\n};\n","import React, { useState } from \"react\";\nimport { ActionsManagerInterface } from \"../actions/types\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"./App\";\nimport { AppState, ExportOpts } from \"../types\";\nimport { Dialog } from \"./Dialog\";\nimport { exportFile, exportToFileIcon, link } from \"./icons\";\nimport { ToolButton } from \"./ToolButton\";\nimport { actionSaveFileToDisk } from \"../actions/actionExport\";\nimport { Card } from \"./Card\";\n\nimport \"./ExportDialog.scss\";\nimport { supported as fsSupported } from \"browser-fs-access\";\n\nexport type ExportCB = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  scale?: number,\n) => void;\n\nconst JSONExportModal = ({\n  elements,\n  appState,\n  actionManager,\n  exportOpts,\n  canvas,\n}: {\n  appState: AppState;\n  elements: readonly NonDeletedExcalidrawElement[];\n  actionManager: ActionsManagerInterface;\n  onCloseRequest: () => void;\n  exportOpts: ExportOpts;\n  canvas: HTMLCanvasElement | null;\n}) => {\n  const { onExportToBackend } = exportOpts;\n  return (\n    <div className=\"ExportDialog ExportDialog--json\">\n      <div className=\"ExportDialog-cards\">\n        {exportOpts.saveFileToDisk && (\n          <Card color=\"lime\">\n            <div className=\"Card-icon\">{exportToFileIcon}</div>\n            <h2>{t(\"exportDialog.disk_title\")}</h2>\n            <div className=\"Card-details\">\n              {t(\"exportDialog.disk_details\")}\n              {!fsSupported && actionManager.renderAction(\"changeProjectName\")}\n            </div>\n            <ToolButton\n              className=\"Card-button\"\n              type=\"button\"\n              title={t(\"exportDialog.disk_button\")}\n              aria-label={t(\"exportDialog.disk_button\")}\n              showAriaLabel={true}\n              onClick={() => {\n                actionManager.executeAction(actionSaveFileToDisk);\n              }}\n            />\n          </Card>\n        )}\n        {onExportToBackend && (\n          <Card color=\"pink\">\n            <div className=\"Card-icon\">{link}</div>\n            <h2>{t(\"exportDialog.link_title\")}</h2>\n            <div className=\"Card-details\">{t(\"exportDialog.link_details\")}</div>\n            <ToolButton\n              className=\"Card-button\"\n              type=\"button\"\n              title={t(\"exportDialog.link_button\")}\n              aria-label={t(\"exportDialog.link_button\")}\n              showAriaLabel={true}\n              onClick={() => onExportToBackend(elements, appState, canvas)}\n            />\n          </Card>\n        )}\n        {exportOpts.renderCustomUI &&\n          exportOpts.renderCustomUI(elements, appState, canvas)}\n      </div>\n    </div>\n  );\n};\n\nexport const JSONExportDialog = ({\n  elements,\n  appState,\n  actionManager,\n  exportOpts,\n  canvas,\n}: {\n  appState: AppState;\n  elements: readonly NonDeletedExcalidrawElement[];\n  actionManager: ActionsManagerInterface;\n  exportOpts: ExportOpts;\n  canvas: HTMLCanvasElement | null;\n}) => {\n  const [modalIsShown, setModalIsShown] = useState(false);\n\n  const handleClose = React.useCallback(() => {\n    setModalIsShown(false);\n  }, []);\n\n  return (\n    <>\n      <ToolButton\n        onClick={() => {\n          setModalIsShown(true);\n        }}\n        data-testid=\"json-export-button\"\n        icon={exportFile}\n        type=\"button\"\n        aria-label={t(\"buttons.export\")}\n        showAriaLabel={useIsMobile()}\n        title={t(\"buttons.export\")}\n      />\n      {modalIsShown && (\n        <Dialog onCloseRequest={handleClose} title={t(\"buttons.export\")}>\n          <JSONExportModal\n            elements={elements}\n            appState={appState}\n            actionManager={actionManager}\n            onCloseRequest={handleClose}\n            exportOpts={exportOpts}\n            canvas={canvas}\n          />\n        </Dialog>\n      )}\n    </>\n  );\n};\n","import clsx from \"clsx\";\nimport React, {\n  RefObject,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { ActionManager } from \"../actions/manager\";\nimport { CLASSES } from \"../constants\";\nimport { exportCanvas } from \"../data\";\nimport { importLibraryFromJSON, saveLibraryAsJSON } from \"../data/json\";\nimport { isTextElement, showSelectedShapeActions } from \"../element\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { Language, t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport { calculateScrollCenter, getSelectedElements } from \"../scene\";\nimport { ExportType } from \"../scene/types\";\nimport {\n  AppProps,\n  AppState,\n  ExcalidrawProps,\n  LibraryItem,\n  LibraryItems,\n} from \"../types\";\nimport { muteFSAbortError } from \"../utils\";\nimport { SelectedShapeActions, ShapesSwitcher, ZoomActions } from \"./Actions\";\nimport { BackgroundPickerAndDarkModeToggle } from \"./BackgroundPickerAndDarkModeToggle\";\nimport CollabButton from \"./CollabButton\";\nimport { ErrorDialog } from \"./ErrorDialog\";\nimport { ExportCB, ImageExportDialog } from \"./ImageExportDialog\";\nimport { FixedSideContainer } from \"./FixedSideContainer\";\nimport { HintViewer } from \"./HintViewer\";\nimport { exportFile, load, trash } from \"./icons\";\nimport { Island } from \"./Island\";\nimport \"./LayerUI.scss\";\nimport { LibraryUnit } from \"./LibraryUnit\";\nimport { LoadingMessage } from \"./LoadingMessage\";\nimport { LockButton } from \"./LockButton\";\nimport { MobileMenu } from \"./MobileMenu\";\nimport { PasteChartDialog } from \"./PasteChartDialog\";\nimport { Section } from \"./Section\";\nimport { HelpDialog } from \"./HelpDialog\";\nimport Stack from \"./Stack\";\nimport { ToolButton } from \"./ToolButton\";\nimport { Tooltip } from \"./Tooltip\";\nimport { UserList } from \"./UserList\";\nimport Library from \"../data/library\";\nimport { JSONExportDialog } from \"./JSONExportDialog\";\nimport { LibraryButton } from \"./LibraryButton\";\n\ninterface LayerUIProps {\n  actionManager: ActionManager;\n  appState: AppState;\n  canvas: HTMLCanvasElement | null;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  elements: readonly NonDeletedExcalidrawElement[];\n  onCollabButtonClick?: () => void;\n  onLockToggle: () => void;\n  onInsertElements: (elements: readonly NonDeletedExcalidrawElement[]) => void;\n  zenModeEnabled: boolean;\n  showExitZenModeBtn: boolean;\n  showThemeBtn: boolean;\n  toggleZenMode: () => void;\n  langCode: Language[\"code\"];\n  isCollaborating: boolean;\n  renderTopRightUI?: (isMobile: boolean, appState: AppState) => JSX.Element;\n  renderCustomFooter?: (isMobile: boolean, appState: AppState) => JSX.Element;\n  viewModeEnabled: boolean;\n  libraryReturnUrl: ExcalidrawProps[\"libraryReturnUrl\"];\n  UIOptions: AppProps[\"UIOptions\"];\n  focusContainer: () => void;\n  library: Library;\n  id: string;\n}\n\nconst useOnClickOutside = (\n  ref: RefObject<HTMLElement>,\n  cb: (event: MouseEvent) => void,\n) => {\n  useEffect(() => {\n    const listener = (event: MouseEvent) => {\n      if (!ref.current) {\n        return;\n      }\n\n      if (\n        event.target instanceof Element &&\n        (ref.current.contains(event.target) ||\n          !document.body.contains(event.target))\n      ) {\n        return;\n      }\n\n      cb(event);\n    };\n    document.addEventListener(\"pointerdown\", listener, false);\n\n    return () => {\n      document.removeEventListener(\"pointerdown\", listener);\n    };\n  }, [ref, cb]);\n};\n\nconst LibraryMenuItems = ({\n  libraryItems,\n  onRemoveFromLibrary,\n  onAddToLibrary,\n  onInsertShape,\n  pendingElements,\n  theme,\n  setAppState,\n  setLibraryItems,\n  libraryReturnUrl,\n  focusContainer,\n  library,\n  id,\n}: {\n  libraryItems: LibraryItems;\n  pendingElements: LibraryItem;\n  onRemoveFromLibrary: (index: number) => void;\n  onInsertShape: (elements: LibraryItem) => void;\n  onAddToLibrary: (elements: LibraryItem) => void;\n  theme: AppState[\"theme\"];\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  setLibraryItems: (library: LibraryItems) => void;\n  libraryReturnUrl: ExcalidrawProps[\"libraryReturnUrl\"];\n  focusContainer: () => void;\n  library: Library;\n  id: string;\n}) => {\n  const isMobile = useIsMobile();\n  const numCells = libraryItems.length + (pendingElements.length > 0 ? 1 : 0);\n  const CELLS_PER_ROW = isMobile ? 4 : 6;\n  const numRows = Math.max(1, Math.ceil(numCells / CELLS_PER_ROW));\n  const rows = [];\n  let addedPendingElements = false;\n\n  const referrer =\n    libraryReturnUrl || window.location.origin + window.location.pathname;\n\n  rows.push(\n    <div className=\"layer-ui__library-header\" key=\"library-header\">\n      <ToolButton\n        key=\"import\"\n        type=\"button\"\n        title={t(\"buttons.load\")}\n        aria-label={t(\"buttons.load\")}\n        icon={load}\n        onClick={() => {\n          importLibraryFromJSON(library)\n            .then(() => {\n              // Close and then open to get the libraries updated\n              setAppState({ isLibraryOpen: false });\n              setAppState({ isLibraryOpen: true });\n            })\n            .catch(muteFSAbortError)\n            .catch((error) => {\n              setAppState({ errorMessage: error.message });\n            });\n        }}\n      />\n      {!!libraryItems.length && (\n        <>\n          <ToolButton\n            key=\"export\"\n            type=\"button\"\n            title={t(\"buttons.export\")}\n            aria-label={t(\"buttons.export\")}\n            icon={exportFile}\n            onClick={() => {\n              saveLibraryAsJSON(library)\n                .catch(muteFSAbortError)\n                .catch((error) => {\n                  setAppState({ errorMessage: error.message });\n                });\n            }}\n          />\n          <ToolButton\n            key=\"reset\"\n            type=\"button\"\n            title={t(\"buttons.resetLibrary\")}\n            aria-label={t(\"buttons.resetLibrary\")}\n            icon={trash}\n            onClick={() => {\n              if (window.confirm(t(\"alerts.resetLibrary\"))) {\n                library.resetLibrary();\n                setLibraryItems([]);\n                focusContainer();\n              }\n            }}\n          />\n        </>\n      )}\n      <a\n        href={`https://libraries.excalidraw.com?target=${\n          window.name || \"_blank\"\n        }&referrer=${referrer}&useHash=true&token=${id}&theme=${theme}`}\n        target=\"_excalidraw_libraries\"\n      >\n        {t(\"labels.libraries\")}\n      </a>\n    </div>,\n  );\n\n  for (let row = 0; row < numRows; row++) {\n    const y = CELLS_PER_ROW * row;\n    const children = [];\n    for (let x = 0; x < CELLS_PER_ROW; x++) {\n      const shouldAddPendingElements: boolean =\n        pendingElements.length > 0 &&\n        !addedPendingElements &&\n        y + x >= libraryItems.length;\n      addedPendingElements = addedPendingElements || shouldAddPendingElements;\n\n      children.push(\n        <Stack.Col key={x}>\n          <LibraryUnit\n            elements={libraryItems[y + x]}\n            pendingElements={\n              shouldAddPendingElements ? pendingElements : undefined\n            }\n            onRemoveFromLibrary={onRemoveFromLibrary.bind(null, y + x)}\n            onClick={\n              shouldAddPendingElements\n                ? onAddToLibrary.bind(null, pendingElements)\n                : onInsertShape.bind(null, libraryItems[y + x])\n            }\n          />\n        </Stack.Col>,\n      );\n    }\n    rows.push(\n      <Stack.Row align=\"center\" gap={1} key={row}>\n        {children}\n      </Stack.Row>,\n    );\n  }\n\n  return (\n    <Stack.Col align=\"start\" gap={1} className=\"layer-ui__library-items\">\n      {rows}\n    </Stack.Col>\n  );\n};\n\nconst LibraryMenu = ({\n  onClickOutside,\n  onInsertShape,\n  pendingElements,\n  onAddToLibrary,\n  theme,\n  setAppState,\n  libraryReturnUrl,\n  focusContainer,\n  library,\n  id,\n}: {\n  pendingElements: LibraryItem;\n  onClickOutside: (event: MouseEvent) => void;\n  onInsertShape: (elements: LibraryItem) => void;\n  onAddToLibrary: () => void;\n  theme: AppState[\"theme\"];\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  libraryReturnUrl: ExcalidrawProps[\"libraryReturnUrl\"];\n  focusContainer: () => void;\n  library: Library;\n  id: string;\n}) => {\n  const ref = useRef<HTMLDivElement | null>(null);\n  useOnClickOutside(ref, (event) => {\n    // If click on the library icon, do nothing.\n    if ((event.target as Element).closest(\".ToolIcon_type_button__library\")) {\n      return;\n    }\n    onClickOutside(event);\n  });\n\n  const [libraryItems, setLibraryItems] = useState<LibraryItems>([]);\n\n  const [loadingState, setIsLoading] = useState<\n    \"preloading\" | \"loading\" | \"ready\"\n  >(\"preloading\");\n\n  const loadingTimerRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    Promise.race([\n      new Promise((resolve) => {\n        loadingTimerRef.current = setTimeout(() => {\n          resolve(\"loading\");\n        }, 100);\n      }),\n      library.loadLibrary().then((items) => {\n        setLibraryItems(items);\n        setIsLoading(\"ready\");\n      }),\n    ]).then((data) => {\n      if (data === \"loading\") {\n        setIsLoading(\"loading\");\n      }\n    });\n    return () => {\n      clearTimeout(loadingTimerRef.current!);\n    };\n  }, [library]);\n\n  const removeFromLibrary = useCallback(\n    async (indexToRemove) => {\n      const items = await library.loadLibrary();\n      const nextItems = items.filter((_, index) => index !== indexToRemove);\n      library.saveLibrary(nextItems).catch((error) => {\n        setLibraryItems(items);\n        setAppState({ errorMessage: t(\"alerts.errorRemovingFromLibrary\") });\n      });\n      setLibraryItems(nextItems);\n    },\n    [library, setAppState],\n  );\n\n  const addToLibrary = useCallback(\n    async (elements: LibraryItem) => {\n      const items = await library.loadLibrary();\n      const nextItems = [...items, elements];\n      onAddToLibrary();\n      library.saveLibrary(nextItems).catch((error) => {\n        setLibraryItems(items);\n        setAppState({ errorMessage: t(\"alerts.errorAddingToLibrary\") });\n      });\n      setLibraryItems(nextItems);\n    },\n    [onAddToLibrary, library, setAppState],\n  );\n\n  return loadingState === \"preloading\" ? null : (\n    <Island padding={1} ref={ref} className=\"layer-ui__library\">\n      {loadingState === \"loading\" ? (\n        <div className=\"layer-ui__library-message\">\n          {t(\"labels.libraryLoadingMessage\")}\n        </div>\n      ) : (\n        <LibraryMenuItems\n          libraryItems={libraryItems}\n          onRemoveFromLibrary={removeFromLibrary}\n          onAddToLibrary={addToLibrary}\n          onInsertShape={onInsertShape}\n          pendingElements={pendingElements}\n          setAppState={setAppState}\n          setLibraryItems={setLibraryItems}\n          libraryReturnUrl={libraryReturnUrl}\n          focusContainer={focusContainer}\n          library={library}\n          theme={theme}\n          id={id}\n        />\n      )}\n    </Island>\n  );\n};\n\nconst LayerUI = ({\n  actionManager,\n  appState,\n  setAppState,\n  canvas,\n  elements,\n  onCollabButtonClick,\n  onLockToggle,\n  onInsertElements,\n  zenModeEnabled,\n  showExitZenModeBtn,\n  showThemeBtn,\n  toggleZenMode,\n  isCollaborating,\n  renderTopRightUI,\n  renderCustomFooter,\n  viewModeEnabled,\n  libraryReturnUrl,\n  UIOptions,\n  focusContainer,\n  library,\n  id,\n}: LayerUIProps) => {\n  const isMobile = useIsMobile();\n\n  const renderJSONExportDialog = () => {\n    if (!UIOptions.canvasActions.export) {\n      return null;\n    }\n\n    return (\n      <JSONExportDialog\n        elements={elements}\n        appState={appState}\n        actionManager={actionManager}\n        exportOpts={UIOptions.canvasActions.export}\n        canvas={canvas}\n      />\n    );\n  };\n\n  const renderImageExportDialog = () => {\n    if (!UIOptions.canvasActions.saveAsImage) {\n      return null;\n    }\n\n    const createExporter = (type: ExportType): ExportCB => async (\n      exportedElements,\n    ) => {\n      await exportCanvas(type, exportedElements, appState, {\n        exportBackground: appState.exportBackground,\n        name: appState.name,\n        viewBackgroundColor: appState.viewBackgroundColor,\n      })\n        .catch(muteFSAbortError)\n        .catch((error) => {\n          console.error(error);\n          setAppState({ errorMessage: error.message });\n        });\n    };\n\n    return (\n      <ImageExportDialog\n        elements={elements}\n        appState={appState}\n        actionManager={actionManager}\n        onExportToPng={createExporter(\"png\")}\n        onExportToSvg={createExporter(\"svg\")}\n        onExportToClipboard={createExporter(\"clipboard\")}\n      />\n    );\n  };\n\n  const Separator = () => {\n    return <div style={{ width: \".625em\" }} />;\n  };\n\n  const renderViewModeCanvasActions = () => {\n    return (\n      <Section\n        heading=\"canvasActions\"\n        className={clsx(\"zen-mode-transition\", {\n          \"transition-left\": zenModeEnabled,\n        })}\n      >\n        {/* the zIndex ensures this menu has higher stacking order,\n         see https://github.com/excalidraw/excalidraw/pull/1445 */}\n        <Island padding={2} style={{ zIndex: 1 }}>\n          <Stack.Col gap={4}>\n            <Stack.Row gap={1} justifyContent=\"space-between\">\n              {renderJSONExportDialog()}\n              {renderImageExportDialog()}\n            </Stack.Row>\n          </Stack.Col>\n        </Island>\n      </Section>\n    );\n  };\n  const renderCanvasActions = () => (\n    <Section\n      heading=\"canvasActions\"\n      className={clsx(\"zen-mode-transition\", {\n        \"transition-left\": zenModeEnabled,\n      })}\n    >\n      {/* the zIndex ensures this menu has higher stacking order,\n         see https://github.com/excalidraw/excalidraw/pull/1445 */}\n      <Island padding={2} style={{ zIndex: 1 }}>\n        <Stack.Col gap={4}>\n          <Stack.Row gap={1} justifyContent=\"space-between\">\n            {actionManager.renderAction(\"clearCanvas\")}\n            <Separator />\n            {actionManager.renderAction(\"loadScene\")}\n            {renderJSONExportDialog()}\n            {renderImageExportDialog()}\n            <Separator />\n            {onCollabButtonClick && (\n              <CollabButton\n                isCollaborating={isCollaborating}\n                collaboratorCount={appState.collaborators.size}\n                onClick={onCollabButtonClick}\n              />\n            )}\n          </Stack.Row>\n          <BackgroundPickerAndDarkModeToggle\n            actionManager={actionManager}\n            appState={appState}\n            setAppState={setAppState}\n            showThemeBtn={showThemeBtn}\n          />\n          {appState.fileHandle && (\n            <>{actionManager.renderAction(\"saveToActiveFile\")}</>\n          )}\n        </Stack.Col>\n      </Island>\n    </Section>\n  );\n\n  const renderSelectedShapeActions = () => (\n    <Section\n      heading=\"selectedShapeActions\"\n      className={clsx(\"zen-mode-transition\", {\n        \"transition-left\": zenModeEnabled,\n      })}\n    >\n      <Island\n        className={CLASSES.SHAPE_ACTIONS_MENU}\n        padding={2}\n        style={{\n          // we want to make sure this doesn't overflow so substracting 200\n          // which is approximately height of zoom footer and top left menu items with some buffer\n          // if active file name is displayed, subtracting 248 to account for its height\n          maxHeight: `${appState.height - (appState.fileHandle ? 248 : 200)}px`,\n        }}\n      >\n        <SelectedShapeActions\n          appState={appState}\n          elements={elements}\n          renderAction={actionManager.renderAction}\n          elementType={appState.elementType}\n        />\n      </Island>\n    </Section>\n  );\n\n  const closeLibrary = useCallback(\n    (event) => {\n      setAppState({ isLibraryOpen: false });\n    },\n    [setAppState],\n  );\n\n  const deselectItems = useCallback(() => {\n    setAppState({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n    });\n  }, [setAppState]);\n\n  const libraryMenu = appState.isLibraryOpen ? (\n    <LibraryMenu\n      pendingElements={getSelectedElements(elements, appState)}\n      onClickOutside={closeLibrary}\n      onInsertShape={onInsertElements}\n      onAddToLibrary={deselectItems}\n      setAppState={setAppState}\n      libraryReturnUrl={libraryReturnUrl}\n      focusContainer={focusContainer}\n      library={library}\n      theme={appState.theme}\n      id={id}\n    />\n  ) : null;\n\n  const renderFixedSideContainer = () => {\n    const shouldRenderSelectedShapeActions = showSelectedShapeActions(\n      appState,\n      elements,\n    );\n\n    return (\n      <FixedSideContainer side=\"top\">\n        <div className=\"App-menu App-menu_top\">\n          <Stack.Col\n            gap={4}\n            className={clsx({ \"disable-pointerEvents\": zenModeEnabled })}\n          >\n            {viewModeEnabled\n              ? renderViewModeCanvasActions()\n              : renderCanvasActions()}\n            {shouldRenderSelectedShapeActions && renderSelectedShapeActions()}\n          </Stack.Col>\n          {!viewModeEnabled && (\n            <Section heading=\"shapes\">\n              {(heading) => (\n                <Stack.Col gap={4} align=\"start\">\n                  <Stack.Row gap={1}>\n                    <LockButton\n                      zenModeEnabled={zenModeEnabled}\n                      checked={appState.elementLocked}\n                      onChange={onLockToggle}\n                      title={t(\"toolBar.lock\")}\n                    />\n                    <Island\n                      padding={1}\n                      className={clsx({ \"zen-mode\": zenModeEnabled })}\n                    >\n                      <HintViewer appState={appState} elements={elements} />\n                      {heading}\n                      <Stack.Row gap={1}>\n                        <ShapesSwitcher\n                          canvas={canvas}\n                          elementType={appState.elementType}\n                          setAppState={setAppState}\n                        />\n                      </Stack.Row>\n                    </Island>\n                    <LibraryButton\n                      appState={appState}\n                      setAppState={setAppState}\n                    />\n                  </Stack.Row>\n                  {libraryMenu}\n                </Stack.Col>\n              )}\n            </Section>\n          )}\n          <div\n            className={clsx(\n              \"layer-ui__wrapper__top-right zen-mode-transition\",\n              {\n                \"transition-right\": zenModeEnabled,\n              },\n            )}\n          >\n            <UserList>\n              {appState.collaborators.size > 0 &&\n                Array.from(appState.collaborators)\n                  // Collaborator is either not initialized or is actually the current user.\n                  .filter(([_, client]) => Object.keys(client).length !== 0)\n                  .map(([clientId, client]) => (\n                    <Tooltip\n                      label={client.username || \"Unknown user\"}\n                      key={clientId}\n                    >\n                      {actionManager.renderAction(\"goToCollaborator\", clientId)}\n                    </Tooltip>\n                  ))}\n            </UserList>\n            {renderTopRightUI?.(isMobile, appState)}\n          </div>\n        </div>\n      </FixedSideContainer>\n    );\n  };\n\n  const renderBottomAppMenu = () => {\n    return (\n      <footer\n        role=\"contentinfo\"\n        className=\"layer-ui__wrapper__footer App-menu App-menu_bottom\"\n      >\n        <div\n          className={clsx(\n            \"layer-ui__wrapper__footer-left zen-mode-transition\",\n            {\n              \"layer-ui__wrapper__footer-left--transition-left\": zenModeEnabled,\n            },\n          )}\n        >\n          <Stack.Col gap={2}>\n            <Section heading=\"canvasActions\">\n              <Island padding={1}>\n                <ZoomActions\n                  renderAction={actionManager.renderAction}\n                  zoom={appState.zoom}\n                />\n              </Island>\n            </Section>\n          </Stack.Col>\n        </div>\n        <div\n          className={clsx(\n            \"layer-ui__wrapper__footer-center zen-mode-transition\",\n            {\n              \"layer-ui__wrapper__footer-left--transition-bottom\": zenModeEnabled,\n            },\n          )}\n        >\n          {renderCustomFooter?.(false, appState)}\n        </div>\n        <div\n          className={clsx(\n            \"layer-ui__wrapper__footer-right zen-mode-transition\",\n            {\n              \"transition-right disable-pointerEvents\": zenModeEnabled,\n            },\n          )}\n        >\n          {actionManager.renderAction(\"toggleShortcuts\")}\n        </div>\n        <button\n          className={clsx(\"disable-zen-mode\", {\n            \"disable-zen-mode--visible\": showExitZenModeBtn,\n          })}\n          onClick={toggleZenMode}\n        >\n          {t(\"buttons.exitZenMode\")}\n        </button>\n      </footer>\n    );\n  };\n\n  const dialogs = (\n    <>\n      {appState.isLoading && <LoadingMessage />}\n      {appState.errorMessage && (\n        <ErrorDialog\n          message={appState.errorMessage}\n          onClose={() => setAppState({ errorMessage: null })}\n        />\n      )}\n      {appState.showHelpDialog && (\n        <HelpDialog\n          onClose={() => {\n            setAppState({ showHelpDialog: false });\n          }}\n        />\n      )}\n      {appState.pasteDialog.shown && (\n        <PasteChartDialog\n          setAppState={setAppState}\n          appState={appState}\n          onInsertChart={onInsertElements}\n          onClose={() =>\n            setAppState({\n              pasteDialog: { shown: false, data: null },\n            })\n          }\n        />\n      )}\n    </>\n  );\n\n  return isMobile ? (\n    <>\n      {dialogs}\n      <MobileMenu\n        appState={appState}\n        elements={elements}\n        actionManager={actionManager}\n        libraryMenu={libraryMenu}\n        renderJSONExportDialog={renderJSONExportDialog}\n        renderImageExportDialog={renderImageExportDialog}\n        setAppState={setAppState}\n        onCollabButtonClick={onCollabButtonClick}\n        onLockToggle={onLockToggle}\n        canvas={canvas}\n        isCollaborating={isCollaborating}\n        renderCustomFooter={renderCustomFooter}\n        viewModeEnabled={viewModeEnabled}\n        showThemeBtn={showThemeBtn}\n      />\n    </>\n  ) : (\n    <div\n      className={clsx(\"layer-ui__wrapper\", {\n        \"disable-pointerEvents\":\n          appState.draggingElement ||\n          appState.resizingElement ||\n          (appState.editingElement && !isTextElement(appState.editingElement)),\n      })}\n    >\n      {dialogs}\n      {renderFixedSideContainer()}\n      {renderBottomAppMenu()}\n      {appState.scrolledOutside && (\n        <button\n          className=\"scroll-back-to-content\"\n          onClick={() => {\n            setAppState({\n              ...calculateScrollCenter(elements, appState, canvas),\n            });\n          }}\n        >\n          {t(\"buttons.scrollBackToContent\")}\n        </button>\n      )}\n    </div>\n  );\n};\n\nconst areEqual = (prev: LayerUIProps, next: LayerUIProps) => {\n  const getNecessaryObj = (appState: AppState): Partial<AppState> => {\n    const {\n      suggestedBindings,\n      startBoundElement: boundElement,\n      ...ret\n    } = appState;\n    return ret;\n  };\n  const prevAppState = getNecessaryObj(prev.appState);\n  const nextAppState = getNecessaryObj(next.appState);\n\n  const keys = Object.keys(prevAppState) as (keyof Partial<AppState>)[];\n  return (\n    prev.renderCustomFooter === next.renderCustomFooter &&\n    prev.langCode === next.langCode &&\n    prev.elements === next.elements &&\n    keys.every((key) => prevAppState[key] === nextAppState[key])\n  );\n};\n\nexport default React.memo(LayerUI, areEqual);\n","import React from \"react\";\nimport { getCommonBounds } from \"../element/bounds\";\nimport { NonDeletedExcalidrawElement } from \"../element/types\";\nimport { t } from \"../i18n\";\nimport { useIsMobile } from \"../components/App\";\nimport { getTargetElements } from \"../scene\";\nimport { AppState, ExcalidrawProps } from \"../types\";\nimport { close } from \"./icons\";\nimport { Island } from \"./Island\";\nimport \"./Stats.scss\";\n\nexport const Stats = (props: {\n  appState: AppState;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  elements: readonly NonDeletedExcalidrawElement[];\n  onClose: () => void;\n  renderCustomStats: ExcalidrawProps[\"renderCustomStats\"];\n}) => {\n  const isMobile = useIsMobile();\n\n  const boundingBox = getCommonBounds(props.elements);\n  const selectedElements = getTargetElements(props.elements, props.appState);\n  const selectedBoundingBox = getCommonBounds(selectedElements);\n\n  if (isMobile && props.appState.openMenu) {\n    return null;\n  }\n\n  return (\n    <div className=\"Stats\">\n      <Island padding={2}>\n        <div className=\"close\" onClick={props.onClose}>\n          {close}\n        </div>\n        <h3>{t(\"stats.title\")}</h3>\n        <table>\n          <tbody>\n            <tr>\n              <th colSpan={2}>{t(\"stats.scene\")}</th>\n            </tr>\n            <tr>\n              <td>{t(\"stats.elements\")}</td>\n              <td>{props.elements.length}</td>\n            </tr>\n            <tr>\n              <td>{t(\"stats.width\")}</td>\n              <td>{Math.round(boundingBox[2]) - Math.round(boundingBox[0])}</td>\n            </tr>\n            <tr>\n              <td>{t(\"stats.height\")}</td>\n              <td>{Math.round(boundingBox[3]) - Math.round(boundingBox[1])}</td>\n            </tr>\n\n            {selectedElements.length === 1 && (\n              <tr>\n                <th colSpan={2}>{t(\"stats.element\")}</th>\n              </tr>\n            )}\n\n            {selectedElements.length > 1 && (\n              <>\n                <tr>\n                  <th colSpan={2}>{t(\"stats.selected\")}</th>\n                </tr>\n                <tr>\n                  <td>{t(\"stats.elements\")}</td>\n                  <td>{selectedElements.length}</td>\n                </tr>\n              </>\n            )}\n            {selectedElements.length > 0 && (\n              <>\n                <tr>\n                  <td>{\"x\"}</td>\n                  <td>{Math.round(selectedBoundingBox[0])}</td>\n                </tr>\n                <tr>\n                  <td>{\"y\"}</td>\n                  <td>{Math.round(selectedBoundingBox[1])}</td>\n                </tr>\n                <tr>\n                  <td>{t(\"stats.width\")}</td>\n                  <td>\n                    {Math.round(\n                      selectedBoundingBox[2] - selectedBoundingBox[0],\n                    )}\n                  </td>\n                </tr>\n                <tr>\n                  <td>{t(\"stats.height\")}</td>\n                  <td>\n                    {Math.round(\n                      selectedBoundingBox[3] - selectedBoundingBox[1],\n                    )}\n                  </td>\n                </tr>\n              </>\n            )}\n            {selectedElements.length === 1 && (\n              <tr>\n                <td>{t(\"stats.angle\")}</td>\n                <td>\n                  {`${Math.round(\n                    (selectedElements[0].angle * 180) / Math.PI,\n                  )}°`}\n                </td>\n              </tr>\n            )}\n            {props.renderCustomStats?.(props.elements, props.appState)}\n          </tbody>\n        </table>\n      </Island>\n    </div>\n  );\n};\n","import React, { useCallback, useEffect, useRef } from \"react\";\nimport { TOAST_TIMEOUT } from \"../constants\";\nimport \"./Toast.scss\";\n\nexport const Toast = ({\n  message,\n  clearToast,\n}: {\n  message: string;\n  clearToast: () => void;\n}) => {\n  const timerRef = useRef<number>(0);\n\n  const scheduleTimeout = useCallback(\n    () =>\n      (timerRef.current = window.setTimeout(() => clearToast(), TOAST_TIMEOUT)),\n    [clearToast],\n  );\n\n  useEffect(() => {\n    scheduleTimeout();\n    return () => clearTimeout(timerRef.current);\n  }, [scheduleTimeout, message]);\n\n  return (\n    <div\n      className=\"Toast\"\n      onMouseEnter={() => clearTimeout(timerRef?.current)}\n      onMouseLeave={scheduleTimeout}\n    >\n      <p className=\"Toast__message\">{message}</p>\n    </div>\n  );\n};\n","import { CODES, KEYS } from \"../keys\";\nimport { register } from \"./register\";\nimport { trackEvent } from \"../analytics\";\n\nexport const actionToggleViewMode = register({\n  name: \"viewMode\",\n  perform(elements, appState) {\n    trackEvent(\"view\", \"mode\", \"view\");\n    return {\n      appState: {\n        ...appState,\n        viewModeEnabled: !this.checked!(appState),\n      },\n      commitToHistory: false,\n    };\n  },\n  checked: (appState) => appState.viewModeEnabled,\n  contextItemLabel: \"labels.viewMode\",\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.R,\n});\n","import React, { useContext } from \"react\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport rough from \"roughjs/bin/rough\";\nimport clsx from \"clsx\";\nimport { supported as fsSupported } from \"browser-fs-access\";\nimport { nanoid } from \"nanoid\";\n\nimport {\n  actionAddToLibrary,\n  actionBringForward,\n  actionBringToFront,\n  actionCopy,\n  actionCopyAsPng,\n  actionCopyAsSvg,\n  actionCopyStyles,\n  actionCut,\n  actionDeleteSelected,\n  actionDuplicateSelection,\n  actionFinalize,\n  actionFlipHorizontal,\n  actionFlipVertical,\n  actionGroup,\n  actionPasteStyles,\n  actionSelectAll,\n  actionSendBackward,\n  actionSendToBack,\n  actionToggleGridMode,\n  actionToggleStats,\n  actionToggleZenMode,\n  actionUngroup,\n} from \"../actions\";\nimport { createRedoAction, createUndoAction } from \"../actions/actionHistory\";\nimport { ActionManager } from \"../actions/manager\";\nimport { actions } from \"../actions/register\";\nimport { ActionResult } from \"../actions/types\";\nimport { trackEvent } from \"../analytics\";\nimport { getDefaultAppState } from \"../appState\";\nimport {\n  copyToClipboard,\n  parseClipboard,\n  probablySupportsClipboardBlob,\n  probablySupportsClipboardWriteText,\n} from \"../clipboard\";\nimport {\n  APP_NAME,\n  CURSOR_TYPE,\n  DEFAULT_UI_OPTIONS,\n  DEFAULT_VERTICAL_ALIGN,\n  DRAGGING_THRESHOLD,\n  ELEMENT_SHIFT_TRANSLATE_AMOUNT,\n  ELEMENT_TRANSLATE_AMOUNT,\n  ENV,\n  EVENT,\n  GRID_SIZE,\n  LINE_CONFIRM_THRESHOLD,\n  MIME_TYPES,\n  MQ_MAX_HEIGHT_LANDSCAPE,\n  MQ_MAX_WIDTH_LANDSCAPE,\n  MQ_MAX_WIDTH_PORTRAIT,\n  POINTER_BUTTON,\n  SCROLL_TIMEOUT,\n  TAP_TWICE_TIMEOUT,\n  TEXT_TO_CENTER_SNAP_THRESHOLD,\n  TOUCH_CTX_MENU_TIMEOUT,\n  URL_HASH_KEYS,\n  URL_QUERY_KEYS,\n  ZOOM_STEP,\n} from \"../constants\";\nimport { loadFromBlob } from \"../data\";\nimport { isValidLibrary } from \"../data/json\";\nimport Library from \"../data/library\";\nimport { restore, restoreElements } from \"../data/restore\";\nimport {\n  dragNewElement,\n  dragSelectedElements,\n  duplicateElement,\n  getCommonBounds,\n  getCursorForResizingElement,\n  getDragOffsetXY,\n  getElementWithTransformHandleType,\n  getNormalizedDimensions,\n  getPerfectElementSize,\n  getResizeArrowDirection,\n  getResizeOffsetXY,\n  getTransformHandleTypeFromCoords,\n  hitTest,\n  isHittingElementBoundingBoxWithoutHittingElement,\n  isInvisiblySmallElement,\n  isNonDeletedElement,\n  isTextElement,\n  newElement,\n  newLinearElement,\n  newTextElement,\n  textWysiwyg,\n  transformElements,\n  updateTextElement,\n} from \"../element\";\nimport {\n  bindOrUnbindSelectedElements,\n  fixBindingsAfterDeletion,\n  fixBindingsAfterDuplication,\n  getEligibleElementsForBinding,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n  isLinearElementSimpleAndAlreadyBound,\n  maybeBindLinearElement,\n  shouldEnableBindingForPointerEvent,\n  unbindLinearElements,\n  updateBoundElements,\n} from \"../element/binding\";\nimport { LinearElementEditor } from \"../element/linearElementEditor\";\nimport { mutateElement } from \"../element/mutateElement\";\nimport { deepCopyElement, newFreeDrawElement } from \"../element/newElement\";\nimport {\n  isBindingElement,\n  isBindingElementType,\n  isLinearElement,\n  isLinearElementType,\n} from \"../element/typeChecks\";\nimport {\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawGenericElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeleted,\n} from \"../element/types\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport {\n  editGroupForSelectedElement,\n  getElementsInGroup,\n  getSelectedGroupIdForElement,\n  getSelectedGroupIds,\n  isElementInGroup,\n  isSelectedViaGroup,\n  selectGroupsForSelectedElements,\n} from \"../groups\";\nimport History from \"../history\";\nimport { defaultLang, getLanguage, languages, setLanguage, t } from \"../i18n\";\nimport {\n  CODES,\n  getResizeCenterPointKey,\n  getResizeWithSidesSameLengthKey,\n  getRotateWithDiscreteAngleKey,\n  isArrowKey,\n  KEYS,\n} from \"../keys\";\nimport { distance2d, getGridPoint, isPathALoop } from \"../math\";\nimport { renderScene } from \"../renderer\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport {\n  calculateScrollCenter,\n  getElementContainingPosition,\n  getElementsAtPosition,\n  getElementsWithinSelection,\n  getNormalizedZoom,\n  getSelectedElements,\n  hasBackground,\n  isOverScrollBars,\n  isSomeElementSelected,\n} from \"../scene\";\nimport Scene from \"../scene/Scene\";\nimport { SceneState, ScrollBars } from \"../scene/types\";\nimport { getNewZoom } from \"../scene/zoom\";\nimport { findShapeByKey } from \"../shapes\";\nimport {\n  AppProps,\n  AppState,\n  ExcalidrawImperativeAPI,\n  Gesture,\n  GestureEvent,\n  LibraryItems,\n  PointerDownState,\n  SceneData,\n} from \"../types\";\nimport {\n  debounce,\n  distance,\n  getNearestScrollableContainer,\n  isInputLike,\n  isToolIcon,\n  isWritableElement,\n  resetCursor,\n  resolvablePromise,\n  sceneCoordsToViewportCoords,\n  setCursor,\n  setCursorForShape,\n  tupleToCoors,\n  viewportCoordsToSceneCoords,\n  withBatchedUpdates,\n} from \"../utils\";\nimport ContextMenu, { ContextMenuOption } from \"./ContextMenu\";\nimport LayerUI from \"./LayerUI\";\nimport { Stats } from \"./Stats\";\nimport { Toast } from \"./Toast\";\nimport { actionToggleViewMode } from \"../actions/actionToggleViewMode\";\n\nconst IsMobileContext = React.createContext(false);\nexport const useIsMobile = () => useContext(IsMobileContext);\nconst ExcalidrawContainerContext = React.createContext<{\n  container: HTMLDivElement | null;\n  id: string | null;\n}>({ container: null, id: null });\nexport const useExcalidrawContainer = () =>\n  useContext(ExcalidrawContainerContext);\n\nlet didTapTwice: boolean = false;\nlet tappedTwiceTimer = 0;\nlet cursorX = 0;\nlet cursorY = 0;\nlet isHoldingSpace: boolean = false;\nlet isPanning: boolean = false;\nlet isDraggingScrollBar: boolean = false;\nlet currentScrollBars: ScrollBars = { horizontal: null, vertical: null };\nlet touchTimeout = 0;\nlet invalidateContextMenu = false;\n\nlet lastPointerUp: ((event: any) => void) | null = null;\nconst gesture: Gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null,\n};\n\nclass App extends React.Component<AppProps, AppState> {\n  canvas: HTMLCanvasElement | null = null;\n  rc: RoughCanvas | null = null;\n  unmounted: boolean = false;\n  actionManager: ActionManager;\n  isMobile = false;\n  detachIsMobileMqHandler?: () => void;\n\n  private excalidrawContainerRef = React.createRef<HTMLDivElement>();\n\n  public static defaultProps: Partial<AppProps> = {\n    // needed for tests to pass since we directly render App in many tests\n    UIOptions: DEFAULT_UI_OPTIONS,\n  };\n\n  private scene: Scene;\n  private resizeObserver: ResizeObserver | undefined;\n  private nearestScrollableContainer: HTMLElement | Document | undefined;\n  public library: Library;\n  public libraryItemsFromStorage: LibraryItems | undefined;\n  private id: string;\n  private history: History;\n  private excalidrawContainerValue: {\n    container: HTMLDivElement | null;\n    id: string;\n  };\n\n  constructor(props: AppProps) {\n    super(props);\n    const defaultAppState = getDefaultAppState();\n    const {\n      excalidrawRef,\n      viewModeEnabled = false,\n      zenModeEnabled = false,\n      gridModeEnabled = false,\n      theme = defaultAppState.theme,\n      name = defaultAppState.name,\n    } = props;\n    this.state = {\n      ...defaultAppState,\n      theme,\n      isLoading: true,\n      ...this.getCanvasOffsets(),\n      viewModeEnabled,\n      zenModeEnabled,\n      gridSize: gridModeEnabled ? GRID_SIZE : null,\n      name,\n      width: window.innerWidth,\n      height: window.innerHeight,\n    };\n\n    this.id = nanoid();\n\n    if (excalidrawRef) {\n      const readyPromise =\n        (\"current\" in excalidrawRef && excalidrawRef.current?.readyPromise) ||\n        resolvablePromise<ExcalidrawImperativeAPI>();\n\n      const api: ExcalidrawImperativeAPI = {\n        ready: true,\n        readyPromise,\n        updateScene: this.updateScene,\n        resetScene: this.resetScene,\n        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,\n        history: {\n          clear: this.resetHistory,\n        },\n        scrollToContent: this.scrollToContent,\n        getSceneElements: this.getSceneElements,\n        getAppState: () => this.state,\n        refresh: this.refresh,\n        importLibrary: this.importLibraryFromUrl,\n        setToastMessage: this.setToastMessage,\n        id: this.id,\n      } as const;\n      if (typeof excalidrawRef === \"function\") {\n        excalidrawRef(api);\n      } else {\n        excalidrawRef.current = api;\n      }\n      readyPromise.resolve(api);\n    }\n\n    this.excalidrawContainerValue = {\n      container: this.excalidrawContainerRef.current,\n      id: this.id,\n    };\n\n    this.scene = new Scene();\n    this.library = new Library(this);\n    this.history = new History();\n    this.actionManager = new ActionManager(\n      this.syncActionResult,\n      () => this.state,\n      () => this.scene.getElementsIncludingDeleted(),\n      this,\n    );\n    this.actionManager.registerAll(actions);\n\n    this.actionManager.registerAction(createUndoAction(this.history));\n    this.actionManager.registerAction(createRedoAction(this.history));\n  }\n\n  private renderCanvas() {\n    const canvasScale = window.devicePixelRatio;\n    const {\n      width: canvasDOMWidth,\n      height: canvasDOMHeight,\n      viewModeEnabled,\n    } = this.state;\n    const canvasWidth = canvasDOMWidth * canvasScale;\n    const canvasHeight = canvasDOMHeight * canvasScale;\n    if (viewModeEnabled) {\n      return (\n        <canvas\n          className=\"excalidraw__canvas\"\n          style={{\n            width: canvasDOMWidth,\n            height: canvasDOMHeight,\n            cursor: \"grabbing\",\n          }}\n          width={canvasWidth}\n          height={canvasHeight}\n          ref={this.handleCanvasRef}\n          onContextMenu={this.handleCanvasContextMenu}\n          onPointerMove={this.handleCanvasPointerMove}\n          onPointerUp={this.removePointer}\n          onPointerCancel={this.removePointer}\n          onTouchMove={this.handleTouchMove}\n          onPointerDown={this.handleCanvasPointerDown}\n        >\n          {t(\"labels.drawingCanvas\")}\n        </canvas>\n      );\n    }\n    return (\n      <canvas\n        className=\"excalidraw__canvas\"\n        style={{\n          width: canvasDOMWidth,\n          height: canvasDOMHeight,\n        }}\n        width={canvasWidth}\n        height={canvasHeight}\n        ref={this.handleCanvasRef}\n        onContextMenu={this.handleCanvasContextMenu}\n        onPointerDown={this.handleCanvasPointerDown}\n        onDoubleClick={this.handleCanvasDoubleClick}\n        onPointerMove={this.handleCanvasPointerMove}\n        onPointerUp={this.removePointer}\n        onPointerCancel={this.removePointer}\n        onTouchMove={this.handleTouchMove}\n      >\n        {t(\"labels.drawingCanvas\")}\n      </canvas>\n    );\n  }\n\n  public render() {\n    const { zenModeEnabled, viewModeEnabled } = this.state;\n\n    const {\n      onCollabButtonClick,\n      renderTopRightUI,\n      renderFooter,\n      renderCustomStats,\n    } = this.props;\n\n    return (\n      <div\n        className={clsx(\"excalidraw excalidraw-container\", {\n          \"excalidraw--view-mode\": viewModeEnabled,\n          \"excalidraw--mobile\": this.isMobile,\n        })}\n        ref={this.excalidrawContainerRef}\n        onDrop={this.handleAppOnDrop}\n        tabIndex={0}\n        onKeyDown={\n          this.props.handleKeyboardGlobally ? undefined : this.onKeyDown\n        }\n      >\n        <ExcalidrawContainerContext.Provider\n          value={this.excalidrawContainerValue}\n        >\n          <IsMobileContext.Provider value={this.isMobile}>\n            <LayerUI\n              canvas={this.canvas}\n              appState={this.state}\n              setAppState={this.setAppState}\n              actionManager={this.actionManager}\n              elements={this.scene.getElements()}\n              onCollabButtonClick={onCollabButtonClick}\n              onLockToggle={this.toggleLock}\n              onInsertElements={(elements) =>\n                this.addElementsFromPasteOrLibrary({\n                  elements,\n                  position: \"center\",\n                })\n              }\n              zenModeEnabled={zenModeEnabled}\n              toggleZenMode={this.toggleZenMode}\n              langCode={getLanguage().code}\n              isCollaborating={this.props.isCollaborating || false}\n              renderTopRightUI={renderTopRightUI}\n              renderCustomFooter={renderFooter}\n              viewModeEnabled={viewModeEnabled}\n              showExitZenModeBtn={\n                typeof this.props?.zenModeEnabled === \"undefined\" &&\n                zenModeEnabled\n              }\n              showThemeBtn={\n                typeof this.props?.theme === \"undefined\" &&\n                this.props.UIOptions.canvasActions.theme\n              }\n              libraryReturnUrl={this.props.libraryReturnUrl}\n              UIOptions={this.props.UIOptions}\n              focusContainer={this.focusContainer}\n              library={this.library}\n              id={this.id}\n            />\n            <div className=\"excalidraw-textEditorContainer\" />\n            <div className=\"excalidraw-contextMenuContainer\" />\n            {this.state.showStats && (\n              <Stats\n                appState={this.state}\n                setAppState={this.setAppState}\n                elements={this.scene.getElements()}\n                onClose={this.toggleStats}\n                renderCustomStats={renderCustomStats}\n              />\n            )}\n            {this.state.toastMessage !== null && (\n              <Toast\n                message={this.state.toastMessage}\n                clearToast={this.clearToast}\n              />\n            )}\n            <main>{this.renderCanvas()}</main>\n          </IsMobileContext.Provider>\n        </ExcalidrawContainerContext.Provider>\n      </div>\n    );\n  }\n\n  public focusContainer = () => {\n    if (this.props.autoFocus) {\n      this.excalidrawContainerRef.current?.focus();\n    }\n  };\n\n  public getSceneElementsIncludingDeleted = () => {\n    return this.scene.getElementsIncludingDeleted();\n  };\n\n  public getSceneElements = () => {\n    return this.scene.getElements();\n  };\n\n  private syncActionResult = withBatchedUpdates(\n    (actionResult: ActionResult) => {\n      if (this.unmounted || actionResult === false) {\n        return;\n      }\n\n      let editingElement: AppState[\"editingElement\"] | null = null;\n      if (actionResult.elements) {\n        actionResult.elements.forEach((element) => {\n          if (\n            this.state.editingElement?.id === element.id &&\n            this.state.editingElement !== element &&\n            isNonDeletedElement(element)\n          ) {\n            editingElement = element;\n          }\n        });\n        this.scene.replaceAllElements(actionResult.elements);\n        if (actionResult.commitToHistory) {\n          this.history.resumeRecording();\n        }\n      }\n\n      if (actionResult.appState || editingElement) {\n        if (actionResult.commitToHistory) {\n          this.history.resumeRecording();\n        }\n\n        let viewModeEnabled = actionResult?.appState?.viewModeEnabled || false;\n        let zenModeEnabled = actionResult?.appState?.zenModeEnabled || false;\n        let gridSize = actionResult?.appState?.gridSize || null;\n        let theme = actionResult?.appState?.theme || \"light\";\n        let name = actionResult?.appState?.name ?? this.state.name;\n        if (typeof this.props.viewModeEnabled !== \"undefined\") {\n          viewModeEnabled = this.props.viewModeEnabled;\n        }\n\n        if (typeof this.props.zenModeEnabled !== \"undefined\") {\n          zenModeEnabled = this.props.zenModeEnabled;\n        }\n\n        if (typeof this.props.gridModeEnabled !== \"undefined\") {\n          gridSize = this.props.gridModeEnabled ? GRID_SIZE : null;\n        }\n\n        if (typeof this.props.theme !== \"undefined\") {\n          theme = this.props.theme;\n        }\n\n        if (typeof this.props.name !== \"undefined\") {\n          name = this.props.name;\n        }\n        this.setState(\n          (state) => {\n            // using Object.assign instead of spread to fool TS 4.2.2+ into\n            // regarding the resulting type as not containing undefined\n            // (which the following expression will never contain)\n            return Object.assign(actionResult.appState || {}, {\n              editingElement:\n                editingElement || actionResult.appState?.editingElement || null,\n              viewModeEnabled,\n              zenModeEnabled,\n              gridSize,\n              theme,\n              name,\n            });\n          },\n          () => {\n            if (actionResult.syncHistory) {\n              this.history.setCurrentState(\n                this.state,\n                this.scene.getElementsIncludingDeleted(),\n              );\n            }\n          },\n        );\n      }\n    },\n  );\n\n  // Lifecycle\n\n  private onBlur = withBatchedUpdates(() => {\n    isHoldingSpace = false;\n    this.setState({ isBindingEnabled: true });\n  });\n\n  private onUnload = () => {\n    this.onBlur();\n  };\n\n  private disableEvent: EventHandlerNonNull = (event) => {\n    event.preventDefault();\n  };\n\n  private onFontLoaded = () => {\n    this.scene.getElementsIncludingDeleted().forEach((element) => {\n      if (isTextElement(element)) {\n        invalidateShapeForElement(element);\n      }\n    });\n    this.onSceneUpdated();\n  };\n\n  private importLibraryFromUrl = async (url: string, token?: string | null) => {\n    if (window.location.hash.includes(URL_HASH_KEYS.addLibrary)) {\n      const hash = new URLSearchParams(window.location.hash.slice(1));\n      hash.delete(URL_HASH_KEYS.addLibrary);\n      window.history.replaceState({}, APP_NAME, `#${hash.toString()}`);\n    } else if (window.location.search.includes(URL_QUERY_KEYS.addLibrary)) {\n      const query = new URLSearchParams(window.location.search);\n      query.delete(URL_QUERY_KEYS.addLibrary);\n      window.history.replaceState({}, APP_NAME, `?${query.toString()}`);\n    }\n\n    try {\n      const request = await fetch(decodeURIComponent(url));\n      const blob = await request.blob();\n      const json = JSON.parse(await blob.text());\n      if (!isValidLibrary(json)) {\n        throw new Error();\n      }\n      if (\n        token === this.id ||\n        window.confirm(\n          t(\"alerts.confirmAddLibrary\", { numShapes: json.library.length }),\n        )\n      ) {\n        await this.library.importLibrary(blob);\n        // hack to rerender the library items after import\n        if (this.state.isLibraryOpen) {\n          this.setState({ isLibraryOpen: false });\n        }\n        this.setState({ isLibraryOpen: true });\n      }\n    } catch (error) {\n      window.alert(t(\"alerts.errorLoadingLibrary\"));\n      console.error(error);\n    } finally {\n      this.focusContainer();\n    }\n  };\n\n  private resetHistory = () => {\n    this.history.clear();\n  };\n\n  /**\n   * Resets scene & history.\n   * ! Do not use to clear scene user action !\n   */\n  private resetScene = withBatchedUpdates(\n    (opts?: { resetLoadingState: boolean }) => {\n      this.scene.replaceAllElements([]);\n      this.setState((state) => ({\n        ...getDefaultAppState(),\n        isLoading: opts?.resetLoadingState ? false : state.isLoading,\n        theme: this.state.theme,\n      }));\n      this.resetHistory();\n    },\n  );\n\n  private initializeScene = async () => {\n    if (\"launchQueue\" in window && \"LaunchParams\" in window) {\n      (window as any).launchQueue.setConsumer(\n        async (launchParams: { files: any[] }) => {\n          if (!launchParams.files.length) {\n            return;\n          }\n          const fileHandle = launchParams.files[0];\n          const blob: Blob = await fileHandle.getFile();\n          blob.handle = fileHandle;\n          loadFromBlob(\n            blob,\n            this.state,\n            this.scene.getElementsIncludingDeleted(),\n          )\n            .then(({ elements, appState }) =>\n              this.syncActionResult({\n                elements,\n                appState: {\n                  ...(appState || this.state),\n                  isLoading: false,\n                },\n                commitToHistory: true,\n              }),\n            )\n            .catch((error) => {\n              this.setState({ isLoading: false, errorMessage: error.message });\n            });\n        },\n      );\n    }\n\n    if (!this.state.isLoading) {\n      this.setState({ isLoading: true });\n    }\n    let initialData = null;\n    try {\n      initialData = (await this.props.initialData) || null;\n      if (initialData?.libraryItems) {\n        this.libraryItemsFromStorage = initialData.libraryItems;\n      }\n    } catch (error) {\n      console.error(error);\n      initialData = {\n        appState: {\n          errorMessage:\n            error.message ||\n            \"Encountered an error during importing or restoring scene data\",\n        },\n      };\n    }\n\n    const scene = restore(initialData, null, null);\n    scene.appState = {\n      ...scene.appState,\n      isLoading: false,\n    };\n    if (initialData?.scrollToContent) {\n      scene.appState = {\n        ...scene.appState,\n        ...calculateScrollCenter(\n          scene.elements,\n          {\n            ...scene.appState,\n            width: this.state.width,\n            height: this.state.height,\n            offsetTop: this.state.offsetTop,\n            offsetLeft: this.state.offsetLeft,\n          },\n          null,\n        ),\n      };\n    }\n\n    this.resetHistory();\n    this.syncActionResult({\n      ...scene,\n      commitToHistory: true,\n    });\n\n    const libraryUrl =\n      // current\n      new URLSearchParams(window.location.hash.slice(1)).get(\n        URL_HASH_KEYS.addLibrary,\n      ) ||\n      // legacy, kept for compat reasons\n      new URLSearchParams(window.location.search).get(\n        URL_QUERY_KEYS.addLibrary,\n      );\n\n    if (libraryUrl) {\n      await this.importLibraryFromUrl(libraryUrl);\n    }\n  };\n\n  public async componentDidMount() {\n    this.excalidrawContainerValue.container = this.excalidrawContainerRef.current;\n\n    if (\n      process.env.NODE_ENV === ENV.TEST ||\n      process.env.NODE_ENV === ENV.DEVELOPMENT\n    ) {\n      const setState = this.setState.bind(this);\n      Object.defineProperties(window.h, {\n        state: {\n          configurable: true,\n          get: () => {\n            return this.state;\n          },\n        },\n        setState: {\n          configurable: true,\n          value: (...args: Parameters<typeof setState>) => {\n            return this.setState(...args);\n          },\n        },\n        app: {\n          configurable: true,\n          value: this,\n        },\n        history: {\n          configurable: true,\n          value: this.history,\n        },\n      });\n    }\n\n    this.scene.addCallback(this.onSceneUpdated);\n    this.addEventListeners();\n\n    if (this.excalidrawContainerRef.current) {\n      this.focusContainer();\n    }\n\n    if (\"ResizeObserver\" in window && this.excalidrawContainerRef?.current) {\n      this.resizeObserver = new ResizeObserver(() => {\n        // compute isMobile state\n        // ---------------------------------------------------------------------\n        const {\n          width,\n          height,\n        } = this.excalidrawContainerRef.current!.getBoundingClientRect();\n        this.isMobile =\n          width < MQ_MAX_WIDTH_PORTRAIT ||\n          (height < MQ_MAX_HEIGHT_LANDSCAPE && width < MQ_MAX_WIDTH_LANDSCAPE);\n        // refresh offsets\n        // ---------------------------------------------------------------------\n        this.updateDOMRect();\n      });\n      this.resizeObserver?.observe(this.excalidrawContainerRef.current);\n    } else if (window.matchMedia) {\n      const mediaQuery = window.matchMedia(\n        `(max-width: ${MQ_MAX_WIDTH_PORTRAIT}px), (max-height: ${MQ_MAX_HEIGHT_LANDSCAPE}px) and (max-width: ${MQ_MAX_WIDTH_LANDSCAPE}px)`,\n      );\n      const handler = () => (this.isMobile = mediaQuery.matches);\n      mediaQuery.addListener(handler);\n      this.detachIsMobileMqHandler = () => mediaQuery.removeListener(handler);\n    }\n\n    const searchParams = new URLSearchParams(window.location.search.slice(1));\n\n    if (searchParams.has(\"web-share-target\")) {\n      // Obtain a file that was shared via the Web Share Target API.\n      this.restoreFileFromShare();\n    } else {\n      this.updateDOMRect(this.initializeScene);\n    }\n  }\n\n  public componentWillUnmount() {\n    this.resizeObserver?.disconnect();\n    this.unmounted = true;\n    this.removeEventListeners();\n    this.scene.destroy();\n    clearTimeout(touchTimeout);\n    touchTimeout = 0;\n  }\n\n  private onResize = withBatchedUpdates(() => {\n    this.scene\n      .getElementsIncludingDeleted()\n      .forEach((element) => invalidateShapeForElement(element));\n    this.setState({});\n  });\n\n  private removeEventListeners() {\n    document.removeEventListener(EVENT.COPY, this.onCopy);\n    document.removeEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.removeEventListener(EVENT.CUT, this.onCut);\n    this.nearestScrollableContainer?.removeEventListener(\n      EVENT.SCROLL,\n      this.onScroll,\n    );\n    document.removeEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    document.removeEventListener(\n      EVENT.MOUSE_MOVE,\n      this.updateCurrentCursorPosition,\n      false,\n    );\n    document.removeEventListener(EVENT.KEYUP, this.onKeyUp);\n    window.removeEventListener(EVENT.RESIZE, this.onResize, false);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.removeEventListener(EVENT.BLUR, this.onBlur, false);\n    window.removeEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    window.removeEventListener(EVENT.DROP, this.disableEvent, false);\n\n    document.removeEventListener(\n      EVENT.GESTURE_START,\n      this.onGestureStart as any,\n      false,\n    );\n    document.removeEventListener(\n      EVENT.GESTURE_CHANGE,\n      this.onGestureChange as any,\n      false,\n    );\n    document.removeEventListener(\n      EVENT.GESTURE_END,\n      this.onGestureEnd as any,\n      false,\n    );\n\n    this.detachIsMobileMqHandler?.();\n  }\n\n  private addEventListeners() {\n    this.removeEventListeners();\n    document.addEventListener(EVENT.COPY, this.onCopy);\n    if (this.props.handleKeyboardGlobally) {\n      document.addEventListener(EVENT.KEYDOWN, this.onKeyDown, false);\n    }\n    document.addEventListener(EVENT.KEYUP, this.onKeyUp, { passive: true });\n    document.addEventListener(\n      EVENT.MOUSE_MOVE,\n      this.updateCurrentCursorPosition,\n    );\n    // rerender text elements on font load to fix #637 && #1553\n    document.fonts?.addEventListener?.(\"loadingdone\", this.onFontLoaded);\n    // Safari-only desktop pinch zoom\n    document.addEventListener(\n      EVENT.GESTURE_START,\n      this.onGestureStart as any,\n      false,\n    );\n    document.addEventListener(\n      EVENT.GESTURE_CHANGE,\n      this.onGestureChange as any,\n      false,\n    );\n    document.addEventListener(\n      EVENT.GESTURE_END,\n      this.onGestureEnd as any,\n      false,\n    );\n    if (this.state.viewModeEnabled) {\n      return;\n    }\n\n    document.addEventListener(EVENT.PASTE, this.pasteFromClipboard);\n    document.addEventListener(EVENT.CUT, this.onCut);\n    if (this.props.detectScroll) {\n      this.nearestScrollableContainer = getNearestScrollableContainer(\n        this.excalidrawContainerRef.current!,\n      );\n      this.nearestScrollableContainer.addEventListener(\n        EVENT.SCROLL,\n        this.onScroll,\n      );\n    }\n    window.addEventListener(EVENT.RESIZE, this.onResize, false);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload, false);\n    window.addEventListener(EVENT.BLUR, this.onBlur, false);\n    window.addEventListener(EVENT.DRAG_OVER, this.disableEvent, false);\n    window.addEventListener(EVENT.DROP, this.disableEvent, false);\n  }\n\n  componentDidUpdate(prevProps: AppProps, prevState: AppState) {\n    if (prevProps.langCode !== this.props.langCode) {\n      this.updateLanguage();\n    }\n\n    if (prevProps.viewModeEnabled !== this.props.viewModeEnabled) {\n      this.setState({ viewModeEnabled: !!this.props.viewModeEnabled });\n    }\n\n    if (prevState.viewModeEnabled !== this.state.viewModeEnabled) {\n      this.addEventListeners();\n      this.deselectElements();\n    }\n\n    if (prevProps.zenModeEnabled !== this.props.zenModeEnabled) {\n      this.setState({ zenModeEnabled: !!this.props.zenModeEnabled });\n    }\n\n    if (prevProps.theme !== this.props.theme && this.props.theme) {\n      this.setState({ theme: this.props.theme });\n    }\n\n    if (prevProps.gridModeEnabled !== this.props.gridModeEnabled) {\n      this.setState({\n        gridSize: this.props.gridModeEnabled ? GRID_SIZE : null,\n      });\n    }\n\n    if (this.props.name && prevProps.name !== this.props.name) {\n      this.setState({\n        name: this.props.name,\n      });\n    }\n\n    this.excalidrawContainerRef.current?.classList.toggle(\n      \"theme--dark\",\n      this.state.theme === \"dark\",\n    );\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.selectedElementIds[this.state.editingLinearElement.elementId]\n    ) {\n      // defer so that the commitToHistory flag isn't reset via current update\n      setTimeout(() => {\n        this.actionManager.executeAction(actionFinalize);\n      });\n    }\n    const { multiElement } = prevState;\n    if (\n      prevState.elementType !== this.state.elementType &&\n      multiElement != null &&\n      isBindingEnabled(this.state) &&\n      isBindingElement(multiElement)\n    ) {\n      maybeBindLinearElement(\n        multiElement,\n        this.state,\n        this.scene,\n        tupleToCoors(\n          LinearElementEditor.getPointAtIndexGlobalCoordinates(\n            multiElement,\n            -1,\n          ),\n        ),\n      );\n    }\n\n    const cursorButton: {\n      [id: string]: string | undefined;\n    } = {};\n    const pointerViewportCoords: SceneState[\"remotePointerViewportCoords\"] = {};\n    const remoteSelectedElementIds: SceneState[\"remoteSelectedElementIds\"] = {};\n    const pointerUsernames: { [id: string]: string } = {};\n    const pointerUserStates: { [id: string]: string } = {};\n    this.state.collaborators.forEach((user, socketId) => {\n      if (user.selectedElementIds) {\n        for (const id of Object.keys(user.selectedElementIds)) {\n          if (!(id in remoteSelectedElementIds)) {\n            remoteSelectedElementIds[id] = [];\n          }\n          remoteSelectedElementIds[id].push(socketId);\n        }\n      }\n      if (!user.pointer) {\n        return;\n      }\n      if (user.username) {\n        pointerUsernames[socketId] = user.username;\n      }\n      if (user.userState) {\n        pointerUserStates[socketId] = user.userState;\n      }\n      pointerViewportCoords[socketId] = sceneCoordsToViewportCoords(\n        {\n          sceneX: user.pointer.x,\n          sceneY: user.pointer.y,\n        },\n        this.state,\n      );\n      cursorButton[socketId] = user.button;\n    });\n    const elements = this.scene.getElements();\n    const { atLeastOneVisibleElement, scrollBars } = renderScene(\n      elements.filter((element) => {\n        // don't render text element that's being currently edited (it's\n        // rendered on remote only)\n        return (\n          !this.state.editingElement ||\n          this.state.editingElement.type !== \"text\" ||\n          element.id !== this.state.editingElement.id\n        );\n      }),\n      this.state,\n      this.state.selectionElement,\n      window.devicePixelRatio,\n      this.rc!,\n      this.canvas!,\n      {\n        scrollX: this.state.scrollX,\n        scrollY: this.state.scrollY,\n        viewBackgroundColor: this.state.viewBackgroundColor,\n        zoom: this.state.zoom,\n        remotePointerViewportCoords: pointerViewportCoords,\n        remotePointerButton: cursorButton,\n        remoteSelectedElementIds,\n        remotePointerUsernames: pointerUsernames,\n        remotePointerUserStates: pointerUserStates,\n        shouldCacheIgnoreZoom: this.state.shouldCacheIgnoreZoom,\n      },\n      {\n        renderOptimizations: true,\n        renderScrollbars: !this.isMobile,\n      },\n    );\n    if (scrollBars) {\n      currentScrollBars = scrollBars;\n    }\n    const scrolledOutside =\n      // hide when editing text\n      this.state.editingElement?.type === \"text\"\n        ? false\n        : !atLeastOneVisibleElement && elements.length > 0;\n    if (this.state.scrolledOutside !== scrolledOutside) {\n      this.setState({ scrolledOutside });\n    }\n\n    this.history.record(this.state, this.scene.getElementsIncludingDeleted());\n\n    // Do not notify consumers if we're still loading the scene. Among other\n    // potential issues, this fixes a case where the tab isn't focused during\n    // init, which would trigger onChange with empty elements, which would then\n    // override whatever is in localStorage currently.\n    if (!this.state.isLoading) {\n      this.props.onChange?.(\n        this.scene.getElementsIncludingDeleted(),\n        this.state,\n      );\n    }\n  }\n\n  private onScroll = debounce(() => {\n    const { offsetTop, offsetLeft } = this.getCanvasOffsets();\n    this.setState((state) => {\n      if (state.offsetLeft === offsetLeft && state.offsetTop === offsetTop) {\n        return null;\n      }\n      return { offsetTop, offsetLeft };\n    });\n  }, SCROLL_TIMEOUT);\n\n  // Copy/paste\n\n  private onCut = withBatchedUpdates((event: ClipboardEvent) => {\n    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(\n      document.activeElement,\n    );\n    if (!isExcalidrawActive || isWritableElement(event.target)) {\n      return;\n    }\n    this.cutAll();\n    event.preventDefault();\n  });\n\n  private onCopy = withBatchedUpdates((event: ClipboardEvent) => {\n    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(\n      document.activeElement,\n    );\n    if (!isExcalidrawActive || isWritableElement(event.target)) {\n      return;\n    }\n    this.copyAll();\n    event.preventDefault();\n  });\n\n  private cutAll = () => {\n    this.copyAll();\n    this.actionManager.executeAction(actionDeleteSelected);\n  };\n\n  private copyAll = () => {\n    copyToClipboard(this.scene.getElements(), this.state);\n  };\n\n  private static resetTapTwice() {\n    didTapTwice = false;\n  }\n\n  private onTapStart = (event: TouchEvent) => {\n    if (!didTapTwice) {\n      didTapTwice = true;\n      clearTimeout(tappedTwiceTimer);\n      tappedTwiceTimer = window.setTimeout(\n        App.resetTapTwice,\n        TAP_TWICE_TIMEOUT,\n      );\n      return;\n    }\n    // insert text only if we tapped twice with a single finger\n    // event.touches.length === 1 will also prevent inserting text when user's zooming\n    if (didTapTwice && event.touches.length === 1) {\n      const [touch] = event.touches;\n      // @ts-ignore\n      this.handleCanvasDoubleClick({\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n      });\n      didTapTwice = false;\n      clearTimeout(tappedTwiceTimer);\n    }\n    event.preventDefault();\n    if (event.touches.length === 2) {\n      this.setState({\n        selectedElementIds: {},\n      });\n    }\n  };\n\n  private onTapEnd = (event: TouchEvent) => {\n    if (event.touches.length > 0) {\n      this.setState({\n        previousSelectedElementIds: {},\n        selectedElementIds: this.state.previousSelectedElementIds,\n      });\n    }\n  };\n\n  private pasteFromClipboard = withBatchedUpdates(\n    async (event: ClipboardEvent | null) => {\n      // #686\n      const target = document.activeElement;\n      const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(\n        target,\n      );\n      if (!isExcalidrawActive) {\n        return;\n      }\n\n      const elementUnderCursor = document.elementFromPoint(cursorX, cursorY);\n      if (\n        // if no ClipboardEvent supplied, assume we're pasting via contextMenu\n        // thus these checks don't make sense\n        event &&\n        (!(elementUnderCursor instanceof HTMLCanvasElement) ||\n          isWritableElement(target))\n      ) {\n        return;\n      }\n      const data = await parseClipboard(event);\n      if (this.props.onPaste) {\n        if (await this.props.onPaste(data, event)) {\n          return;\n        }\n      }\n      if (data.errorMessage) {\n        this.setState({ errorMessage: data.errorMessage });\n      } else if (data.spreadsheet) {\n        this.setState({\n          pasteDialog: {\n            data: data.spreadsheet,\n            shown: true,\n          },\n        });\n      } else if (data.elements) {\n        this.addElementsFromPasteOrLibrary({\n          elements: data.elements,\n          position: \"cursor\",\n        });\n      } else if (data.text) {\n        this.addTextFromPaste(data.text);\n      }\n      this.selectShapeTool(\"selection\");\n      event?.preventDefault();\n    },\n  );\n\n  private addElementsFromPasteOrLibrary = (opts: {\n    elements: readonly ExcalidrawElement[];\n    position: { clientX: number; clientY: number } | \"cursor\" | \"center\";\n  }) => {\n    const elements = restoreElements(opts.elements, null);\n    const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n\n    const elementsCenterX = distance(minX, maxX) / 2;\n    const elementsCenterY = distance(minY, maxY) / 2;\n\n    const clientX =\n      typeof opts.position === \"object\"\n        ? opts.position.clientX\n        : opts.position === \"cursor\"\n        ? cursorX\n        : this.state.width / 2 + this.state.offsetLeft;\n    const clientY =\n      typeof opts.position === \"object\"\n        ? opts.position.clientY\n        : opts.position === \"cursor\"\n        ? cursorY\n        : this.state.height / 2 + this.state.offsetTop;\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX, clientY },\n      this.state,\n    );\n\n    const dx = x - elementsCenterX;\n    const dy = y - elementsCenterY;\n    const groupIdMap = new Map();\n\n    const [gridX, gridY] = getGridPoint(dx, dy, this.state.gridSize);\n\n    const oldIdToDuplicatedId = new Map();\n    const newElements = elements.map((element) => {\n      const newElement = duplicateElement(\n        this.state.editingGroupId,\n        groupIdMap,\n        element,\n        {\n          x: element.x + gridX - minX,\n          y: element.y + gridY - minY,\n        },\n      );\n      oldIdToDuplicatedId.set(element.id, newElement.id);\n      return newElement;\n    });\n    const nextElements = [\n      ...this.scene.getElementsIncludingDeleted(),\n      ...newElements,\n    ];\n    fixBindingsAfterDuplication(nextElements, elements, oldIdToDuplicatedId);\n\n    this.scene.replaceAllElements(nextElements);\n    this.history.resumeRecording();\n    this.setState(\n      selectGroupsForSelectedElements(\n        {\n          ...this.state,\n          isLibraryOpen: false,\n          selectedElementIds: newElements.reduce((map, element) => {\n            map[element.id] = true;\n            return map;\n          }, {} as any),\n          selectedGroupIds: {},\n        },\n        this.scene.getElements(),\n      ),\n    );\n    this.selectShapeTool(\"selection\");\n  };\n\n  private addTextFromPaste(text: any) {\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX: cursorX, clientY: cursorY },\n      this.state,\n    );\n\n    const element = newTextElement({\n      x,\n      y,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemStrokeSharpness,\n      text,\n      fontSize: this.state.currentItemFontSize,\n      fontFamily: this.state.currentItemFontFamily,\n      textAlign: this.state.currentItemTextAlign,\n      verticalAlign: DEFAULT_VERTICAL_ALIGN,\n    });\n\n    this.scene.replaceAllElements([\n      ...this.scene.getElementsIncludingDeleted(),\n      element,\n    ]);\n    this.setState({ selectedElementIds: { [element.id]: true } });\n    this.history.resumeRecording();\n  }\n\n  // Collaboration\n\n  setAppState = (obj: any) => {\n    this.setState(obj);\n  };\n\n  removePointer = (event: React.PointerEvent<HTMLElement>) => {\n    // remove touch handler for context menu on touch devices\n    if (event.pointerType === \"touch\" && touchTimeout) {\n      clearTimeout(touchTimeout);\n      touchTimeout = 0;\n      invalidateContextMenu = false;\n    }\n\n    gesture.pointers.delete(event.pointerId);\n  };\n\n  toggleLock = () => {\n    this.setState((prevState) => {\n      return {\n        elementLocked: !prevState.elementLocked,\n        elementType: prevState.elementLocked\n          ? \"selection\"\n          : prevState.elementType,\n      };\n    });\n  };\n\n  toggleZenMode = () => {\n    this.actionManager.executeAction(actionToggleZenMode);\n  };\n\n  toggleStats = () => {\n    if (!this.state.showStats) {\n      trackEvent(\"dialog\", \"stats\");\n    }\n    this.actionManager.executeAction(actionToggleStats);\n  };\n\n  scrollToContent = (\n    target:\n      | ExcalidrawElement\n      | readonly ExcalidrawElement[] = this.scene.getElements(),\n  ) => {\n    this.setState({\n      ...calculateScrollCenter(\n        Array.isArray(target) ? target : [target],\n        this.state,\n        this.canvas,\n      ),\n    });\n  };\n\n  clearToast = () => {\n    this.setState({ toastMessage: null });\n  };\n\n  setToastMessage = (toastMessage: string) => {\n    this.setState({ toastMessage });\n  };\n\n  restoreFileFromShare = async () => {\n    try {\n      const webShareTargetCache = await caches.open(\"web-share-target\");\n\n      const file = await webShareTargetCache.match(\"shared-file\");\n      if (file) {\n        const blob = await file.blob();\n        this.loadFileToCanvas(blob);\n        await webShareTargetCache.delete(\"shared-file\");\n        window.history.replaceState(null, APP_NAME, window.location.pathname);\n      }\n    } catch (error) {\n      this.setState({ errorMessage: error.message });\n    }\n  };\n\n  public updateScene = withBatchedUpdates(\n    <K extends keyof AppState>(sceneData: {\n      elements?: SceneData[\"elements\"];\n      appState?: Pick<AppState, K> | null;\n      collaborators?: SceneData[\"collaborators\"];\n      commitToHistory?: SceneData[\"commitToHistory\"];\n    }) => {\n      if (sceneData.commitToHistory) {\n        this.history.resumeRecording();\n      }\n\n      if (sceneData.appState) {\n        this.setState(sceneData.appState);\n      }\n\n      if (sceneData.elements) {\n        this.scene.replaceAllElements(sceneData.elements);\n      }\n\n      if (sceneData.collaborators) {\n        this.setState({ collaborators: sceneData.collaborators });\n      }\n    },\n  );\n\n  private onSceneUpdated = () => {\n    this.setState({});\n  };\n\n  private updateCurrentCursorPosition = withBatchedUpdates(\n    (event: MouseEvent) => {\n      cursorX = event.clientX;\n      cursorY = event.clientY;\n    },\n  );\n\n  // Input handling\n\n  private onKeyDown = withBatchedUpdates(\n    (event: React.KeyboardEvent | KeyboardEvent) => {\n      // normalize `event.key` when CapsLock is pressed #2372\n      if (\n        \"Proxy\" in window &&\n        ((!event.shiftKey && /^[A-Z]$/.test(event.key)) ||\n          (event.shiftKey && /^[a-z]$/.test(event.key)))\n      ) {\n        event = new Proxy(event, {\n          get(ev: any, prop) {\n            const value = ev[prop];\n            if (typeof value === \"function\") {\n              // fix for Proxies hijacking `this`\n              return value.bind(ev);\n            }\n            return prop === \"key\"\n              ? // CapsLock inverts capitalization based on ShiftKey, so invert\n                // it back\n                event.shiftKey\n                ? ev.key.toUpperCase()\n                : ev.key.toLowerCase()\n              : value;\n          },\n        });\n      }\n\n      if (\n        (isWritableElement(event.target) && event.key !== KEYS.ESCAPE) ||\n        // case: using arrows to move between buttons\n        (isArrowKey(event.key) && isInputLike(event.target))\n      ) {\n        return;\n      }\n\n      if (event.key === KEYS.QUESTION_MARK) {\n        this.setState({\n          showHelpDialog: true,\n        });\n      }\n\n      if (this.actionManager.handleKeyDown(event)) {\n        return;\n      }\n\n      if (this.state.viewModeEnabled) {\n        return;\n      }\n\n      if (event[KEYS.CTRL_OR_CMD] && this.state.isBindingEnabled) {\n        this.setState({ isBindingEnabled: false });\n      }\n\n      if (event.code === CODES.NINE) {\n        this.setState({ isLibraryOpen: !this.state.isLibraryOpen });\n      }\n\n      if (isArrowKey(event.key)) {\n        const step =\n          (this.state.gridSize &&\n            (event.shiftKey\n              ? ELEMENT_TRANSLATE_AMOUNT\n              : this.state.gridSize)) ||\n          (event.shiftKey\n            ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n            : ELEMENT_TRANSLATE_AMOUNT);\n\n        const selectedElements = this.scene\n          .getElements()\n          .filter((element) => this.state.selectedElementIds[element.id]);\n\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (event.key === KEYS.ARROW_LEFT) {\n          offsetX = -step;\n        } else if (event.key === KEYS.ARROW_RIGHT) {\n          offsetX = step;\n        } else if (event.key === KEYS.ARROW_UP) {\n          offsetY = -step;\n        } else if (event.key === KEYS.ARROW_DOWN) {\n          offsetY = step;\n        }\n\n        selectedElements.forEach((element) => {\n          mutateElement(element, {\n            x: element.x + offsetX,\n            y: element.y + offsetY,\n          });\n\n          updateBoundElements(element, {\n            simultaneouslyUpdated: selectedElements,\n          });\n        });\n\n        this.maybeSuggestBindingForAll(selectedElements);\n\n        event.preventDefault();\n      } else if (event.key === KEYS.ENTER) {\n        const selectedElements = getSelectedElements(\n          this.scene.getElements(),\n          this.state,\n        );\n\n        if (\n          selectedElements.length === 1 &&\n          isLinearElement(selectedElements[0])\n        ) {\n          if (\n            !this.state.editingLinearElement ||\n            this.state.editingLinearElement.elementId !== selectedElements[0].id\n          ) {\n            this.history.resumeRecording();\n            this.setState({\n              editingLinearElement: new LinearElementEditor(\n                selectedElements[0],\n                this.scene,\n              ),\n            });\n          }\n        } else if (\n          selectedElements.length === 1 &&\n          !isLinearElement(selectedElements[0])\n        ) {\n          const selectedElement = selectedElements[0];\n          this.startTextEditing({\n            sceneX: selectedElement.x + selectedElement.width / 2,\n            sceneY: selectedElement.y + selectedElement.height / 2,\n          });\n          event.preventDefault();\n          return;\n        }\n      } else if (\n        !event.ctrlKey &&\n        !event.altKey &&\n        !event.metaKey &&\n        this.state.draggingElement === null\n      ) {\n        const shape = findShapeByKey(event.key);\n        if (shape) {\n          this.selectShapeTool(shape);\n        } else if (event.key === KEYS.Q) {\n          this.toggleLock();\n        }\n      }\n      if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n        isHoldingSpace = true;\n        setCursor(this.canvas, CURSOR_TYPE.GRABBING);\n      }\n\n      if (event.key === KEYS.G || event.key === KEYS.S) {\n        if (this.state.elementType === \"selection\") {\n          return;\n        }\n\n        if (\n          event.key === KEYS.G &&\n          (hasBackground(this.state.elementType) ||\n            getSelectedElements(\n              this.scene.getElements(),\n              this.state,\n            ).some((element) => hasBackground(element.type)))\n        ) {\n          this.setState({ openPopup: \"backgroundColorPicker\" });\n        }\n        if (event.key === KEYS.S) {\n          this.setState({ openPopup: \"strokeColorPicker\" });\n        }\n      }\n    },\n  );\n\n  private onKeyUp = withBatchedUpdates((event: KeyboardEvent) => {\n    if (event.key === KEYS.SPACE) {\n      if (this.state.elementType === \"selection\") {\n        resetCursor(this.canvas);\n      } else {\n        setCursorForShape(this.canvas, this.state.elementType);\n        this.setState({\n          selectedElementIds: {},\n          selectedGroupIds: {},\n          editingGroupId: null,\n        });\n      }\n      isHoldingSpace = false;\n    }\n    if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {\n      this.setState({ isBindingEnabled: true });\n    }\n    if (isArrowKey(event.key)) {\n      const selectedElements = getSelectedElements(\n        this.scene.getElements(),\n        this.state,\n      );\n      isBindingEnabled(this.state)\n        ? bindOrUnbindSelectedElements(selectedElements)\n        : unbindLinearElements(selectedElements);\n      this.setState({ suggestedBindings: [] });\n    }\n  });\n\n  private selectShapeTool(elementType: AppState[\"elementType\"]) {\n    if (!isHoldingSpace) {\n      setCursorForShape(this.canvas, elementType);\n    }\n    if (isToolIcon(document.activeElement)) {\n      this.focusContainer();\n    }\n    if (!isLinearElementType(elementType)) {\n      this.setState({ suggestedBindings: [] });\n    }\n    if (elementType !== \"selection\") {\n      this.setState({\n        elementType,\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        editingGroupId: null,\n      });\n    } else {\n      this.setState({ elementType });\n    }\n  }\n\n  private onGestureStart = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    this.setState({\n      selectedElementIds: {},\n    });\n    gesture.initialScale = this.state.zoom.value;\n  });\n\n  private onGestureChange = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n\n    // onGestureChange only has zoom factor but not the center.\n    // If we're on iPad or iPhone, then we recognize multi-touch and will\n    // zoom in at the right location on the touchMove handler already.\n    // On Macbook, we don't have those events so will zoom in at the\n    // current location instead.\n    if (gesture.pointers.size === 2) {\n      return;\n    }\n\n    const initialScale = gesture.initialScale;\n    if (initialScale) {\n      this.setState(({ zoom, offsetLeft, offsetTop }) => ({\n        zoom: getNewZoom(\n          getNormalizedZoom(initialScale * event.scale),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          { x: cursorX, y: cursorY },\n        ),\n      }));\n    }\n  });\n\n  private onGestureEnd = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    this.setState({\n      previousSelectedElementIds: {},\n      selectedElementIds: this.state.previousSelectedElementIds,\n    });\n    gesture.initialScale = null;\n  });\n\n  private handleTextWysiwyg(\n    element: ExcalidrawTextElement,\n    {\n      isExistingElement = false,\n    }: {\n      isExistingElement?: boolean;\n    },\n  ) {\n    const updateElement = (text: string, isDeleted = false) => {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted().map((_element) => {\n          if (_element.id === element.id && isTextElement(_element)) {\n            return updateTextElement(_element, {\n              text,\n              isDeleted,\n            });\n          }\n          return _element;\n        }),\n      ]);\n    };\n\n    textWysiwyg({\n      id: element.id,\n      appState: this.state,\n      canvas: this.canvas,\n      getViewportCoords: (x, y) => {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          {\n            sceneX: x,\n            sceneY: y,\n          },\n          this.state,\n        );\n        return [\n          viewportX - this.state.offsetLeft,\n          viewportY - this.state.offsetTop,\n        ];\n      },\n      onChange: withBatchedUpdates((text) => {\n        updateElement(text);\n        if (isNonDeletedElement(element)) {\n          updateBoundElements(element);\n        }\n      }),\n      onSubmit: withBatchedUpdates(({ text, viaKeyboard }) => {\n        const isDeleted = !text.trim();\n        updateElement(text, isDeleted);\n        // select the created text element only if submitting via keyboard\n        // (when submitting via click it should act as signal to deselect)\n        if (!isDeleted && viaKeyboard) {\n          this.setState((prevState) => ({\n            selectedElementIds: {\n              ...prevState.selectedElementIds,\n              [element.id]: true,\n            },\n          }));\n        }\n        if (isDeleted) {\n          fixBindingsAfterDeletion(this.scene.getElements(), [element]);\n        }\n        if (!isDeleted || isExistingElement) {\n          this.history.resumeRecording();\n        }\n\n        this.setState({\n          draggingElement: null,\n          editingElement: null,\n        });\n        if (this.state.elementLocked) {\n          setCursorForShape(this.canvas, this.state.elementType);\n        }\n\n        this.focusContainer();\n      }),\n      element,\n      excalidrawContainer: this.excalidrawContainerRef.current,\n    });\n    // deselect all other elements when inserting text\n    this.deselectElements();\n\n    // do an initial update to re-initialize element position since we were\n    // modifying element's x/y for sake of editor (case: syncing to remote)\n    updateElement(element.text);\n  }\n\n  private deselectElements() {\n    this.setState({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      editingGroupId: null,\n    });\n  }\n\n  private getTextElementAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawTextElement> | null {\n    const element = this.getElementAtPosition(x, y);\n\n    if (element && isTextElement(element) && !element.isDeleted) {\n      return element;\n    }\n    return null;\n  }\n\n  private getElementAtPosition(\n    x: number,\n    y: number,\n    opts?: {\n      /** if true, returns the first selected element (with highest z-index)\n        of all hit elements */\n      preferSelected?: boolean;\n    },\n  ): NonDeleted<ExcalidrawElement> | null {\n    const allHitElements = this.getElementsAtPosition(x, y);\n    if (allHitElements.length > 1) {\n      if (opts?.preferSelected) {\n        for (let index = allHitElements.length - 1; index > -1; index--) {\n          if (this.state.selectedElementIds[allHitElements[index].id]) {\n            return allHitElements[index];\n          }\n        }\n      }\n      const elementWithHighestZIndex =\n        allHitElements[allHitElements.length - 1];\n      // If we're hitting element with highest z-index only on its bounding box\n      // while also hitting other element figure, the latter should be considered.\n      return isHittingElementBoundingBoxWithoutHittingElement(\n        elementWithHighestZIndex,\n        this.state,\n        x,\n        y,\n      )\n        ? allHitElements[allHitElements.length - 2]\n        : elementWithHighestZIndex;\n    }\n    if (allHitElements.length === 1) {\n      return allHitElements[0];\n    }\n    return null;\n  }\n\n  private getElementsAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawElement>[] {\n    return getElementsAtPosition(this.scene.getElements(), (element) =>\n      hitTest(element, this.state, x, y),\n    );\n  }\n\n  private startTextEditing = ({\n    sceneX,\n    sceneY,\n    insertAtParentCenter = true,\n  }: {\n    /** X position to insert text at */\n    sceneX: number;\n    /** Y position to insert text at */\n    sceneY: number;\n    /** whether to attempt to insert at element center if applicable */\n    insertAtParentCenter?: boolean;\n  }) => {\n    const existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);\n\n    const parentCenterPosition =\n      insertAtParentCenter &&\n      this.getTextWysiwygSnappedToCenterPosition(\n        sceneX,\n        sceneY,\n        this.state,\n        this.canvas,\n        window.devicePixelRatio,\n      );\n\n    const element = existingTextElement\n      ? existingTextElement\n      : newTextElement({\n          x: parentCenterPosition\n            ? parentCenterPosition.elementCenterX\n            : sceneX,\n          y: parentCenterPosition\n            ? parentCenterPosition.elementCenterY\n            : sceneY,\n          strokeColor: this.state.currentItemStrokeColor,\n          backgroundColor: this.state.currentItemBackgroundColor,\n          fillStyle: this.state.currentItemFillStyle,\n          strokeWidth: this.state.currentItemStrokeWidth,\n          strokeStyle: this.state.currentItemStrokeStyle,\n          roughness: this.state.currentItemRoughness,\n          opacity: this.state.currentItemOpacity,\n          strokeSharpness: this.state.currentItemStrokeSharpness,\n          text: \"\",\n          fontSize: this.state.currentItemFontSize,\n          fontFamily: this.state.currentItemFontFamily,\n          textAlign: parentCenterPosition\n            ? \"center\"\n            : this.state.currentItemTextAlign,\n          verticalAlign: parentCenterPosition\n            ? \"middle\"\n            : DEFAULT_VERTICAL_ALIGN,\n        });\n\n    this.setState({ editingElement: element });\n\n    if (existingTextElement) {\n      // if text element is no longer centered to a container, reset\n      // verticalAlign to default because it's currently internal-only\n      if (!parentCenterPosition || element.textAlign !== \"center\") {\n        mutateElement(element, { verticalAlign: DEFAULT_VERTICAL_ALIGN });\n      }\n    } else {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n\n      // case: creating new text not centered to parent elemenent → offset Y\n      // so that the text is centered to cursor position\n      if (!parentCenterPosition) {\n        mutateElement(element, {\n          y: element.y - element.baseline / 2,\n        });\n      }\n    }\n\n    this.setState({\n      editingElement: element,\n    });\n\n    this.handleTextWysiwyg(element, {\n      isExistingElement: !!existingTextElement,\n    });\n  };\n\n  private handleCanvasDoubleClick = (\n    event: React.MouseEvent<HTMLCanvasElement>,\n  ) => {\n    // case: double-clicking with arrow/line tool selected would both create\n    // text and enter multiElement mode\n    if (this.state.multiElement) {\n      return;\n    }\n    // we should only be able to double click when mode is selection\n    if (this.state.elementType !== \"selection\") {\n      return;\n    }\n\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n\n    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n      if (\n        !this.state.editingLinearElement ||\n        this.state.editingLinearElement.elementId !== selectedElements[0].id\n      ) {\n        this.history.resumeRecording();\n        this.setState({\n          editingLinearElement: new LinearElementEditor(\n            selectedElements[0],\n            this.scene,\n          ),\n        });\n      }\n      return;\n    }\n\n    resetCursor(this.canvas);\n\n    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n    );\n\n    const selectedGroupIds = getSelectedGroupIds(this.state);\n\n    if (selectedGroupIds.length > 0) {\n      const hitElement = this.getElementAtPosition(sceneX, sceneY);\n\n      const selectedGroupId =\n        hitElement &&\n        getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);\n\n      if (selectedGroupId) {\n        this.setState((prevState) =>\n          selectGroupsForSelectedElements(\n            {\n              ...prevState,\n              editingGroupId: selectedGroupId,\n              selectedElementIds: { [hitElement!.id]: true },\n              selectedGroupIds: {},\n            },\n            this.scene.getElements(),\n          ),\n        );\n        return;\n      }\n    }\n\n    resetCursor(this.canvas);\n    if (!event[KEYS.CTRL_OR_CMD] && !this.state.viewModeEnabled) {\n      this.startTextEditing({\n        sceneX,\n        sceneY,\n        insertAtParentCenter: !event.altKey,\n      });\n    }\n  };\n\n  private handleCanvasPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    this.savePointer(event.clientX, event.clientY, this.state.cursorButton);\n\n    if (gesture.pointers.has(event.pointerId)) {\n      gesture.pointers.set(event.pointerId, {\n        x: event.clientX,\n        y: event.clientY,\n      });\n    }\n\n    const initialScale = gesture.initialScale;\n    if (\n      gesture.pointers.size === 2 &&\n      gesture.lastCenter &&\n      initialScale &&\n      gesture.initialDistance\n    ) {\n      const center = getCenter(gesture.pointers);\n      const deltaX = center.x - gesture.lastCenter.x;\n      const deltaY = center.y - gesture.lastCenter.y;\n      gesture.lastCenter = center;\n\n      const distance = getDistance(Array.from(gesture.pointers.values()));\n      const scaleFactor = distance / gesture.initialDistance;\n\n      this.setState(({ zoom, scrollX, scrollY, offsetLeft, offsetTop }) => ({\n        scrollX: scrollX + deltaX / zoom.value,\n        scrollY: scrollY + deltaY / zoom.value,\n        zoom: getNewZoom(\n          getNormalizedZoom(initialScale * scaleFactor),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          center,\n        ),\n        shouldCacheIgnoreZoom: true,\n      }));\n      this.resetShouldCacheIgnoreZoomDebounced();\n    } else {\n      gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;\n    }\n\n    if (isHoldingSpace || isPanning || isDraggingScrollBar) {\n      return;\n    }\n\n    const isPointerOverScrollBars = isOverScrollBars(\n      currentScrollBars,\n      event.clientX - this.state.offsetLeft,\n      event.clientY - this.state.offsetTop,\n    );\n    const isOverScrollBar = isPointerOverScrollBars.isOverEither;\n    if (!this.state.draggingElement && !this.state.multiElement) {\n      if (isOverScrollBar) {\n        resetCursor(this.canvas);\n      } else {\n        setCursorForShape(this.canvas, this.state.elementType);\n      }\n    }\n\n    const scenePointer = viewportCoordsToSceneCoords(event, this.state);\n    const { x: scenePointerX, y: scenePointerY } = scenePointer;\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.editingLinearElement.isDragging\n    ) {\n      const editingLinearElement = LinearElementEditor.handlePointerMove(\n        event,\n        scenePointerX,\n        scenePointerY,\n        this.state.editingLinearElement,\n        this.state.gridSize,\n      );\n      if (editingLinearElement !== this.state.editingLinearElement) {\n        this.setState({ editingLinearElement });\n      }\n      if (editingLinearElement.lastUncommittedPoint != null) {\n        this.maybeSuggestBindingAtCursor(scenePointer);\n      } else {\n        this.setState({ suggestedBindings: [] });\n      }\n    }\n\n    if (isBindingElementType(this.state.elementType)) {\n      // Hovering with a selected tool or creating new linear element via click\n      // and point\n      const { draggingElement } = this.state;\n      if (isBindingElement(draggingElement)) {\n        this.maybeSuggestBindingForLinearElementAtCursor(\n          draggingElement,\n          \"end\",\n          scenePointer,\n          this.state.startBoundElement,\n        );\n      } else {\n        this.maybeSuggestBindingAtCursor(scenePointer);\n      }\n    }\n\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n      const { x: rx, y: ry } = multiElement;\n\n      const { points, lastCommittedPoint } = multiElement;\n      const lastPoint = points[points.length - 1];\n\n      setCursorForShape(this.canvas, this.state.elementType);\n\n      if (lastPoint === lastCommittedPoint) {\n        // if we haven't yet created a temp point and we're beyond commit-zone\n        // threshold, add a point\n        if (\n          distance2d(\n            scenePointerX - rx,\n            scenePointerY - ry,\n            lastPoint[0],\n            lastPoint[1],\n          ) >= LINE_CONFIRM_THRESHOLD\n        ) {\n          mutateElement(multiElement, {\n            points: [...points, [scenePointerX - rx, scenePointerY - ry]],\n          });\n        } else {\n          setCursor(this.canvas, CURSOR_TYPE.POINTER);\n          // in this branch, we're inside the commit zone, and no uncommitted\n          // point exists. Thus do nothing (don't add/remove points).\n        }\n      } else if (\n        points.length > 2 &&\n        lastCommittedPoint &&\n        distance2d(\n          scenePointerX - rx,\n          scenePointerY - ry,\n          lastCommittedPoint[0],\n          lastCommittedPoint[1],\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        setCursor(this.canvas, CURSOR_TYPE.POINTER);\n        mutateElement(multiElement, {\n          points: points.slice(0, -1),\n        });\n      } else {\n        if (isPathALoop(points, this.state.zoom.value)) {\n          setCursor(this.canvas, CURSOR_TYPE.POINTER);\n        }\n        // update last uncommitted point\n        mutateElement(multiElement, {\n          points: [\n            ...points.slice(0, -1),\n            [scenePointerX - rx, scenePointerY - ry],\n          ],\n        });\n      }\n\n      return;\n    }\n\n    const hasDeselectedButton = Boolean(event.buttons);\n    if (\n      hasDeselectedButton ||\n      (this.state.elementType !== \"selection\" &&\n        this.state.elementType !== \"text\")\n    ) {\n      return;\n    }\n\n    const elements = this.scene.getElements();\n\n    const selectedElements = getSelectedElements(elements, this.state);\n    if (\n      selectedElements.length === 1 &&\n      !isOverScrollBar &&\n      !this.state.editingLinearElement\n    ) {\n      const elementWithTransformHandleType = getElementWithTransformHandleType(\n        elements,\n        this.state,\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (\n        elementWithTransformHandleType &&\n        elementWithTransformHandleType.transformHandleType\n      ) {\n        setCursor(\n          this.canvas,\n          getCursorForResizingElement(elementWithTransformHandleType),\n        );\n        return;\n      }\n    } else if (selectedElements.length > 1 && !isOverScrollBar) {\n      const transformHandleType = getTransformHandleTypeFromCoords(\n        getCommonBounds(selectedElements),\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (transformHandleType) {\n        setCursor(\n          this.canvas,\n          getCursorForResizingElement({\n            transformHandleType,\n          }),\n        );\n        return;\n      }\n    }\n\n    const hitElement = this.getElementAtPosition(\n      scenePointer.x,\n      scenePointer.y,\n    );\n    if (this.state.elementType === \"text\") {\n      setCursor(\n        this.canvas,\n        isTextElement(hitElement) ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR,\n      );\n    } else if (isOverScrollBar) {\n      setCursor(this.canvas, CURSOR_TYPE.AUTO);\n    } else if (\n      // if using cmd/ctrl, we're not dragging\n      !event[KEYS.CTRL_OR_CMD] &&\n      (hitElement ||\n        this.isHittingCommonBoundingBoxOfSelectedElements(\n          scenePointer,\n          selectedElements,\n        ))\n    ) {\n      setCursor(this.canvas, CURSOR_TYPE.MOVE);\n    } else {\n      setCursor(this.canvas, CURSOR_TYPE.AUTO);\n    }\n  };\n\n  // set touch moving for mobile context menu\n  private handleTouchMove = (event: React.TouchEvent<HTMLCanvasElement>) => {\n    invalidateContextMenu = true;\n  };\n\n  private handleCanvasPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    // remove any active selection when we start to interact with canvas\n    // (mainly, we care about removing selection outside the component which\n    //  would prevent our copy handling otherwise)\n    const selection = document.getSelection();\n    if (selection?.anchorNode) {\n      selection.removeAllRanges();\n    }\n\n    this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);\n    this.maybeCleanupAfterMissingPointerUp(event);\n\n    if (isPanning) {\n      return;\n    }\n\n    this.setState({\n      lastPointerDownWith: event.pointerType,\n      cursorButton: \"down\",\n    });\n    this.savePointer(event.clientX, event.clientY, \"down\");\n\n    if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {\n      return;\n    }\n\n    // only handle left mouse button or touch\n    if (\n      event.button !== POINTER_BUTTON.MAIN &&\n      event.button !== POINTER_BUTTON.TOUCH\n    ) {\n      return;\n    }\n\n    this.updateGestureOnPointerDown(event);\n\n    // don't select while panning\n    if (gesture.pointers.size > 1) {\n      return;\n    }\n\n    // State for the duration of a pointer interaction, which starts with a\n    // pointerDown event, ends with a pointerUp event (or another pointerDown)\n    const pointerDownState = this.initialPointerDownState(event);\n\n    if (this.handleDraggingScrollBar(event, pointerDownState)) {\n      return;\n    }\n\n    this.clearSelectionIfNotUsingSelection();\n    this.updateBindingEnabledOnPointerMove(event);\n\n    if (this.handleSelectionOnPointerDown(event, pointerDownState)) {\n      return;\n    }\n\n    if (this.state.elementType === \"text\") {\n      this.handleTextOnPointerDown(event, pointerDownState);\n      return;\n    } else if (\n      this.state.elementType === \"arrow\" ||\n      this.state.elementType === \"line\"\n    ) {\n      this.handleLinearElementOnPointerDown(\n        event,\n        this.state.elementType,\n        pointerDownState,\n      );\n    } else if (this.state.elementType === \"freedraw\") {\n      this.handleFreeDrawElementOnPointerDown(\n        event,\n        this.state.elementType,\n        pointerDownState,\n      );\n    } else {\n      this.createGenericElementOnPointerDown(\n        this.state.elementType,\n        pointerDownState,\n      );\n    }\n\n    const onPointerMove = this.onPointerMoveFromPointerDownHandler(\n      pointerDownState,\n    );\n\n    const onPointerUp = this.onPointerUpFromPointerDownHandler(\n      pointerDownState,\n    );\n\n    const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);\n    const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);\n\n    lastPointerUp = onPointerUp;\n\n    if (!this.state.viewModeEnabled) {\n      window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n      window.addEventListener(EVENT.KEYDOWN, onKeyDown);\n      window.addEventListener(EVENT.KEYUP, onKeyUp);\n      pointerDownState.eventListeners.onMove = onPointerMove;\n      pointerDownState.eventListeners.onUp = onPointerUp;\n      pointerDownState.eventListeners.onKeyUp = onKeyUp;\n      pointerDownState.eventListeners.onKeyDown = onKeyDown;\n    }\n  };\n\n  private maybeOpenContextMenuAfterPointerDownOnTouchDevices = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void => {\n    // deal with opening context menu on touch devices\n    if (event.pointerType === \"touch\") {\n      invalidateContextMenu = false;\n\n      if (touchTimeout) {\n        // If there's already a touchTimeout, this means that there's another\n        // touch down and we are doing another touch, so we shouldn't open the\n        // context menu.\n        invalidateContextMenu = true;\n      } else {\n        // open the context menu with the first touch's clientX and clientY\n        // if the touch is not moving\n        touchTimeout = window.setTimeout(() => {\n          touchTimeout = 0;\n          if (!invalidateContextMenu) {\n            this.handleCanvasContextMenu(event);\n          }\n        }, TOUCH_CTX_MENU_TIMEOUT);\n      }\n    }\n  };\n\n  private maybeCleanupAfterMissingPointerUp(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void {\n    if (lastPointerUp !== null) {\n      // Unfortunately, sometimes we don't get a pointerup after a pointerdown,\n      // this can happen when a contextual menu or alert is triggered. In order to avoid\n      // being in a weird state, we clean up on the next pointerdown\n      lastPointerUp(event);\n    }\n  }\n\n  // Returns whether the event is a panning\n  private handleCanvasPanUsingWheelOrSpaceDrag = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): boolean => {\n    if (\n      !(\n        gesture.pointers.size === 0 &&\n        (event.button === POINTER_BUTTON.WHEEL ||\n          (event.button === POINTER_BUTTON.MAIN && isHoldingSpace) ||\n          this.state.viewModeEnabled)\n      )\n    ) {\n      return false;\n    }\n    isPanning = true;\n\n    let nextPastePrevented = false;\n    const isLinux = /Linux/.test(window.navigator.platform);\n\n    setCursor(this.canvas, CURSOR_TYPE.GRABBING);\n    let { clientX: lastX, clientY: lastY } = event;\n    const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n      const deltaX = lastX - event.clientX;\n      const deltaY = lastY - event.clientY;\n      lastX = event.clientX;\n      lastY = event.clientY;\n\n      /*\n       * Prevent paste event if we move while middle clicking on Linux.\n       * See issue #1383.\n       */\n      if (\n        isLinux &&\n        !nextPastePrevented &&\n        (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)\n      ) {\n        nextPastePrevented = true;\n\n        /* Prevent the next paste event */\n        const preventNextPaste = (event: ClipboardEvent) => {\n          document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n          event.stopPropagation();\n        };\n\n        /*\n         * Reenable next paste in case of disabled middle click paste for\n         * any reason:\n         * - rigth click paste\n         * - empty clipboard\n         */\n        const enableNextPaste = () => {\n          setTimeout(() => {\n            document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n            window.removeEventListener(EVENT.POINTER_UP, enableNextPaste);\n          }, 100);\n        };\n\n        document.body.addEventListener(EVENT.PASTE, preventNextPaste);\n        window.addEventListener(EVENT.POINTER_UP, enableNextPaste);\n      }\n\n      this.setState({\n        scrollX: this.state.scrollX - deltaX / this.state.zoom.value,\n        scrollY: this.state.scrollY - deltaY / this.state.zoom.value,\n      });\n    });\n    const teardown = withBatchedUpdates(\n      (lastPointerUp = () => {\n        lastPointerUp = null;\n        isPanning = false;\n        if (!isHoldingSpace) {\n          setCursorForShape(this.canvas, this.state.elementType);\n        }\n        this.setState({\n          cursorButton: \"up\",\n        });\n        this.savePointer(event.clientX, event.clientY, \"up\");\n        window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n        window.removeEventListener(EVENT.POINTER_UP, teardown);\n        window.removeEventListener(EVENT.BLUR, teardown);\n      }),\n    );\n    window.addEventListener(EVENT.BLUR, teardown);\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove, {\n      passive: true,\n    });\n    window.addEventListener(EVENT.POINTER_UP, teardown);\n    return true;\n  };\n\n  private updateGestureOnPointerDown(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): void {\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY,\n    });\n\n    if (gesture.pointers.size === 2) {\n      gesture.lastCenter = getCenter(gesture.pointers);\n      gesture.initialScale = this.state.zoom.value;\n      gesture.initialDistance = getDistance(\n        Array.from(gesture.pointers.values()),\n      );\n    }\n  }\n\n  private initialPointerDownState(\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ): PointerDownState {\n    const origin = viewportCoordsToSceneCoords(event, this.state);\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n    const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);\n\n    return {\n      origin,\n      withCmdOrCtrl: event[KEYS.CTRL_OR_CMD],\n      originInGrid: tupleToCoors(\n        getGridPoint(origin.x, origin.y, this.state.gridSize),\n      ),\n      scrollbars: isOverScrollBars(\n        currentScrollBars,\n        event.clientX - this.state.offsetLeft,\n        event.clientY - this.state.offsetTop,\n      ),\n      // we need to duplicate because we'll be updating this state\n      lastCoords: { ...origin },\n      originalElements: this.scene.getElements().reduce((acc, element) => {\n        acc.set(element.id, deepCopyElement(element));\n        return acc;\n      }, new Map() as PointerDownState[\"originalElements\"]),\n      resize: {\n        handleType: false,\n        isResizing: false,\n        offset: { x: 0, y: 0 },\n        arrowDirection: \"origin\",\n        center: { x: (maxX + minX) / 2, y: (maxY + minY) / 2 },\n      },\n      hit: {\n        element: null,\n        allHitElements: [],\n        wasAddedToSelection: false,\n        hasBeenDuplicated: false,\n        hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(\n          origin,\n          selectedElements,\n        ),\n      },\n      drag: {\n        hasOccurred: false,\n        offset: null,\n      },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n        onKeyUp: null,\n        onKeyDown: null,\n      },\n    };\n  }\n\n  // Returns whether the event is a dragging a scrollbar\n  private handleDraggingScrollBar(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (\n      !(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)\n    ) {\n      return false;\n    }\n    isDraggingScrollBar = true;\n    pointerDownState.lastCoords.x = event.clientX;\n    pointerDownState.lastCoords.y = event.clientY;\n    const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      this.handlePointerMoveOverScrollbars(event, pointerDownState);\n    });\n\n    const onPointerUp = withBatchedUpdates(() => {\n      isDraggingScrollBar = false;\n      setCursorForShape(this.canvas, this.state.elementType);\n      lastPointerUp = null;\n      this.setState({\n        cursorButton: \"up\",\n      });\n      this.savePointer(event.clientX, event.clientY, \"up\");\n      window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.removeEventListener(EVENT.POINTER_UP, onPointerUp);\n    });\n\n    lastPointerUp = onPointerUp;\n\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n    window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n    return true;\n  }\n\n  private clearSelectionIfNotUsingSelection = (): void => {\n    if (this.state.elementType !== \"selection\") {\n      this.setState({\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        editingGroupId: null,\n      });\n    }\n  };\n\n  /**\n   * @returns whether the pointer event has been completely handled\n   */\n  private handleSelectionOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): boolean => {\n    if (this.state.elementType === \"selection\") {\n      const elements = this.scene.getElements();\n      const selectedElements = getSelectedElements(elements, this.state);\n      if (selectedElements.length === 1 && !this.state.editingLinearElement) {\n        const elementWithTransformHandleType = getElementWithTransformHandleType(\n          elements,\n          this.state,\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          this.state.zoom,\n          event.pointerType,\n        );\n        if (elementWithTransformHandleType != null) {\n          this.setState({\n            resizingElement: elementWithTransformHandleType.element,\n          });\n          pointerDownState.resize.handleType =\n            elementWithTransformHandleType.transformHandleType;\n        }\n      } else if (selectedElements.length > 1) {\n        pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(\n          getCommonBounds(selectedElements),\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          this.state.zoom,\n          event.pointerType,\n        );\n      }\n      if (pointerDownState.resize.handleType) {\n        setCursor(\n          this.canvas,\n          getCursorForResizingElement({\n            transformHandleType: pointerDownState.resize.handleType,\n          }),\n        );\n        pointerDownState.resize.isResizing = true;\n        pointerDownState.resize.offset = tupleToCoors(\n          getResizeOffsetXY(\n            pointerDownState.resize.handleType,\n            selectedElements,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n        if (\n          selectedElements.length === 1 &&\n          isLinearElement(selectedElements[0]) &&\n          selectedElements[0].points.length === 2\n        ) {\n          pointerDownState.resize.arrowDirection = getResizeArrowDirection(\n            pointerDownState.resize.handleType,\n            selectedElements[0],\n          );\n        }\n      } else {\n        if (this.state.editingLinearElement) {\n          const ret = LinearElementEditor.handlePointerDown(\n            event,\n            this.state,\n            (appState) => this.setState(appState),\n            this.history,\n            pointerDownState.origin,\n          );\n          if (ret.hitElement) {\n            pointerDownState.hit.element = ret.hitElement;\n          }\n          if (ret.didAddPoint) {\n            return true;\n          }\n        }\n\n        // hitElement may already be set above, so check first\n        pointerDownState.hit.element =\n          pointerDownState.hit.element ??\n          this.getElementAtPosition(\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          );\n\n        // For overlapped elements one position may hit\n        // multiple elements\n        pointerDownState.hit.allHitElements = this.getElementsAtPosition(\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n        );\n\n        const hitElement = pointerDownState.hit.element;\n        const someHitElementIsSelected = pointerDownState.hit.allHitElements.some(\n          (element) => this.isASelectedElement(element),\n        );\n        if (\n          (hitElement === null || !someHitElementIsSelected) &&\n          !event.shiftKey &&\n          !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n        ) {\n          this.clearSelection(hitElement);\n        }\n\n        // If we click on something\n        if (hitElement != null) {\n          // on CMD/CTRL, drill down to hit element regardless of groups etc.\n          if (event[KEYS.CTRL_OR_CMD]) {\n            if (!this.state.selectedElementIds[hitElement.id]) {\n              pointerDownState.hit.wasAddedToSelection = true;\n            }\n            this.setState((prevState) => ({\n              ...editGroupForSelectedElement(prevState, hitElement),\n              previousSelectedElementIds: this.state.selectedElementIds,\n            }));\n            // mark as not completely handled so as to allow dragging etc.\n            return false;\n          }\n\n          // deselect if item is selected\n          // if shift is not clicked, this will always return true\n          // otherwise, it will trigger selection based on current\n          // state of the box\n          if (!this.state.selectedElementIds[hitElement.id]) {\n            // if we are currently editing a group, exiting editing mode and deselect the group.\n            if (\n              this.state.editingGroupId &&\n              !isElementInGroup(hitElement, this.state.editingGroupId)\n            ) {\n              this.setState({\n                selectedElementIds: {},\n                selectedGroupIds: {},\n                editingGroupId: null,\n              });\n            }\n\n            // Add hit element to selection. At this point if we're not holding\n            // SHIFT the previously selected element(s) were deselected above\n            // (make sure you use setState updater to use latest state)\n            if (\n              !someHitElementIsSelected &&\n              !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n            ) {\n              this.setState((prevState) => {\n                return selectGroupsForSelectedElements(\n                  {\n                    ...prevState,\n                    selectedElementIds: {\n                      ...prevState.selectedElementIds,\n                      [hitElement.id]: true,\n                    },\n                  },\n                  this.scene.getElements(),\n                );\n              });\n              pointerDownState.hit.wasAddedToSelection = true;\n            }\n          }\n        }\n\n        this.setState({\n          previousSelectedElementIds: this.state.selectedElementIds,\n        });\n      }\n    }\n    return false;\n  };\n\n  private isASelectedElement(hitElement: ExcalidrawElement | null): boolean {\n    return hitElement != null && this.state.selectedElementIds[hitElement.id];\n  }\n\n  private isHittingCommonBoundingBoxOfSelectedElements(\n    point: Readonly<{ x: number; y: number }>,\n    selectedElements: readonly ExcalidrawElement[],\n  ): boolean {\n    if (selectedElements.length < 2) {\n      return false;\n    }\n\n    // How many pixels off the shape boundary we still consider a hit\n    const threshold = 10 / this.state.zoom.value;\n    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);\n    return (\n      point.x > x1 - threshold &&\n      point.x < x2 + threshold &&\n      point.y > y1 - threshold &&\n      point.y < y2 + threshold\n    );\n  }\n\n  private handleTextOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    pointerDownState: PointerDownState,\n  ): void => {\n    // if we're currently still editing text, clicking outside\n    // should only finalize it, not create another (irrespective\n    // of state.elementLocked)\n    if (this.state.editingElement?.type === \"text\") {\n      return;\n    }\n\n    this.startTextEditing({\n      sceneX: pointerDownState.origin.x,\n      sceneY: pointerDownState.origin.y,\n      insertAtParentCenter: !event.altKey,\n    });\n\n    resetCursor(this.canvas);\n    if (!this.state.elementLocked) {\n      this.setState({\n        elementType: \"selection\",\n      });\n    }\n  };\n\n  private handleFreeDrawElementOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    elementType: ExcalidrawFreeDrawElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ) => {\n    // Begin a mark capture. This does not have to update state yet.\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      null,\n    );\n\n    const element = newFreeDrawElement({\n      type: elementType,\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemLinearStrokeSharpness,\n      simulatePressure: event.pressure === 0.5,\n    });\n\n    this.setState((prevState) => ({\n      selectedElementIds: {\n        ...prevState.selectedElementIds,\n        [element.id]: false,\n      },\n    }));\n\n    const pressures = element.simulatePressure\n      ? element.pressures\n      : [...element.pressures, event.pressure];\n\n    mutateElement(element, {\n      points: [[0, 0]],\n      pressures,\n    });\n\n    const boundElement = getHoveredElementForBinding(\n      pointerDownState.origin,\n      this.scene,\n    );\n    this.scene.replaceAllElements([\n      ...this.scene.getElementsIncludingDeleted(),\n      element,\n    ]);\n    this.setState({\n      draggingElement: element,\n      editingElement: element,\n      startBoundElement: boundElement,\n      suggestedBindings: [],\n    });\n  };\n\n  private handleLinearElementOnPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    elementType: ExcalidrawLinearElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n\n      // finalize if completing a loop\n      if (\n        multiElement.type === \"line\" &&\n        isPathALoop(multiElement.points, this.state.zoom.value)\n      ) {\n        mutateElement(multiElement, {\n          lastCommittedPoint:\n            multiElement.points[multiElement.points.length - 1],\n        });\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      const { x: rx, y: ry, lastCommittedPoint } = multiElement;\n\n      // clicking inside commit zone → finalize arrow\n      if (\n        multiElement.points.length > 1 &&\n        lastCommittedPoint &&\n        distance2d(\n          pointerDownState.origin.x - rx,\n          pointerDownState.origin.y - ry,\n          lastCommittedPoint[0],\n          lastCommittedPoint[1],\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      this.setState((prevState) => ({\n        selectedElementIds: {\n          ...prevState.selectedElementIds,\n          [multiElement.id]: true,\n        },\n      }));\n      // clicking outside commit zone → update reference for last committed\n      // point\n      mutateElement(multiElement, {\n        lastCommittedPoint: multiElement.points[multiElement.points.length - 1],\n      });\n      setCursor(this.canvas, CURSOR_TYPE.POINTER);\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        this.state.gridSize,\n      );\n\n      /* If arrow is pre-arrowheads, it will have undefined for both start and end arrowheads.\n      If so, we want it to be null for start and \"arrow\" for end. If the linear item is not\n      an arrow, we want it to be null for both. Otherwise, we want it to use the\n      values from appState. */\n\n      const { currentItemStartArrowhead, currentItemEndArrowhead } = this.state;\n      const [startArrowhead, endArrowhead] =\n        elementType === \"arrow\"\n          ? [currentItemStartArrowhead, currentItemEndArrowhead]\n          : [null, null];\n\n      const element = newLinearElement({\n        type: elementType,\n        x: gridX,\n        y: gridY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        strokeSharpness: this.state.currentItemLinearStrokeSharpness,\n        startArrowhead,\n        endArrowhead,\n      });\n      this.setState((prevState) => ({\n        selectedElementIds: {\n          ...prevState.selectedElementIds,\n          [element.id]: false,\n        },\n      }));\n      mutateElement(element, {\n        points: [...element.points, [0, 0]],\n      });\n      const boundElement = getHoveredElementForBinding(\n        pointerDownState.origin,\n        this.scene,\n      );\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n      this.setState({\n        draggingElement: element,\n        editingElement: element,\n        startBoundElement: boundElement,\n        suggestedBindings: [],\n      });\n    }\n  };\n\n  private createGenericElementOnPointerDown = (\n    elementType: ExcalidrawGenericElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      this.state.gridSize,\n    );\n    const element = newElement({\n      type: elementType,\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      strokeSharpness: this.state.currentItemStrokeSharpness,\n    });\n\n    if (element.type === \"selection\") {\n      this.setState({\n        selectionElement: element,\n        draggingElement: element,\n      });\n    } else {\n      this.scene.replaceAllElements([\n        ...this.scene.getElementsIncludingDeleted(),\n        element,\n      ]);\n      this.setState({\n        multiElement: null,\n        draggingElement: element,\n        editingElement: element,\n      });\n    }\n  };\n\n  private onKeyDownFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onKeyUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      // Prevents focus from escaping excalidraw tab\n      event.key === KEYS.ALT && event.preventDefault();\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onPointerMoveFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: PointerEvent) => void {\n    return withBatchedUpdates((event: PointerEvent) => {\n      // We need to initialize dragOffsetXY only after we've updated\n      // `state.selectedElementIds` on pointerDown. Doing it here in pointerMove\n      // event handler should hopefully ensure we're already working with\n      // the updated state.\n      if (pointerDownState.drag.offset === null) {\n        pointerDownState.drag.offset = tupleToCoors(\n          getDragOffsetXY(\n            getSelectedElements(this.scene.getElements(), this.state),\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n      }\n\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {\n        return;\n      }\n\n      const pointerCoords = viewportCoordsToSceneCoords(event, this.state);\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        this.state.gridSize,\n      );\n\n      // for arrows/lines, don't start dragging until a given threshold\n      // to ensure we don't create a 2-point arrow by mistake when\n      // user clicks mouse in a way that it moves a tiny bit (thus\n      // triggering pointermove)\n      if (\n        !pointerDownState.drag.hasOccurred &&\n        (this.state.elementType === \"arrow\" ||\n          this.state.elementType === \"line\")\n      ) {\n        if (\n          distance2d(\n            pointerCoords.x,\n            pointerCoords.y,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ) < DRAGGING_THRESHOLD\n        ) {\n          return;\n        }\n      }\n\n      if (pointerDownState.resize.isResizing) {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        if (this.maybeHandleResize(pointerDownState, event)) {\n          return true;\n        }\n      }\n\n      if (this.state.editingLinearElement) {\n        const didDrag = LinearElementEditor.handlePointDragging(\n          this.state,\n          (appState) => this.setState(appState),\n          pointerCoords.x,\n          pointerCoords.y,\n          (element, startOrEnd) => {\n            this.maybeSuggestBindingForLinearElementAtCursor(\n              element,\n              startOrEnd,\n              pointerCoords,\n            );\n          },\n        );\n\n        if (didDrag) {\n          pointerDownState.lastCoords.x = pointerCoords.x;\n          pointerDownState.lastCoords.y = pointerCoords.y;\n          return;\n        }\n      }\n\n      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(\n        (element) => this.isASelectedElement(element),\n      );\n\n      if (\n        hasHitASelectedElement ||\n        pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n      ) {\n        // Marking that click was used for dragging to check\n        // if elements should be deselected on pointerup\n        pointerDownState.drag.hasOccurred = true;\n        const selectedElements = getSelectedElements(\n          this.scene.getElements(),\n          this.state,\n        );\n        // prevent dragging even if we're no longer holding cmd/ctrl otherwise\n        // it would have weird results (stuff jumping all over the screen)\n        if (selectedElements.length > 0 && !pointerDownState.withCmdOrCtrl) {\n          const [dragX, dragY] = getGridPoint(\n            pointerCoords.x - pointerDownState.drag.offset.x,\n            pointerCoords.y - pointerDownState.drag.offset.y,\n            this.state.gridSize,\n          );\n\n          const [dragDistanceX, dragDistanceY] = [\n            Math.abs(pointerCoords.x - pointerDownState.origin.x),\n            Math.abs(pointerCoords.y - pointerDownState.origin.y),\n          ];\n\n          // We only drag in one direction if shift is pressed\n          const lockDirection = event.shiftKey;\n\n          dragSelectedElements(\n            pointerDownState,\n            selectedElements,\n            dragX,\n            dragY,\n            this.scene,\n            lockDirection,\n            dragDistanceX,\n            dragDistanceY,\n          );\n          this.maybeSuggestBindingForAll(selectedElements);\n\n          // We duplicate the selected element if alt is pressed on pointer move\n          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {\n            // Move the currently selected elements to the top of the z index stack, and\n            // put the duplicates where the selected elements used to be.\n            // (the origin point where the dragging started)\n\n            pointerDownState.hit.hasBeenDuplicated = true;\n\n            const nextElements = [];\n            const elementsToAppend = [];\n            const groupIdMap = new Map();\n            const oldIdToDuplicatedId = new Map();\n            const hitElement = pointerDownState.hit.element;\n            for (const element of this.scene.getElementsIncludingDeleted()) {\n              if (\n                this.state.selectedElementIds[element.id] ||\n                // case: the state.selectedElementIds might not have been\n                // updated yet by the time this mousemove event is fired\n                (element.id === hitElement?.id &&\n                  pointerDownState.hit.wasAddedToSelection)\n              ) {\n                const duplicatedElement = duplicateElement(\n                  this.state.editingGroupId,\n                  groupIdMap,\n                  element,\n                );\n                const [originDragX, originDragY] = getGridPoint(\n                  pointerDownState.origin.x - pointerDownState.drag.offset.x,\n                  pointerDownState.origin.y - pointerDownState.drag.offset.y,\n                  this.state.gridSize,\n                );\n                mutateElement(duplicatedElement, {\n                  x: duplicatedElement.x + (originDragX - dragX),\n                  y: duplicatedElement.y + (originDragY - dragY),\n                });\n                nextElements.push(duplicatedElement);\n                elementsToAppend.push(element);\n                oldIdToDuplicatedId.set(element.id, duplicatedElement.id);\n              } else {\n                nextElements.push(element);\n              }\n            }\n            const nextSceneElements = [...nextElements, ...elementsToAppend];\n            fixBindingsAfterDuplication(\n              nextSceneElements,\n              elementsToAppend,\n              oldIdToDuplicatedId,\n              \"duplicatesServeAsOld\",\n            );\n            this.scene.replaceAllElements(nextSceneElements);\n          }\n          return;\n        }\n      }\n\n      // It is very important to read this.state within each move event,\n      // otherwise we would read a stale one!\n      const draggingElement = this.state.draggingElement;\n      if (!draggingElement) {\n        return;\n      }\n\n      if (draggingElement.type === \"freedraw\") {\n        const points = draggingElement.points;\n        const dx = pointerCoords.x - draggingElement.x;\n        const dy = pointerCoords.y - draggingElement.y;\n\n        const pressures = draggingElement.simulatePressure\n          ? draggingElement.pressures\n          : [...draggingElement.pressures, event.pressure];\n\n        mutateElement(draggingElement, {\n          points: [...points, [dx, dy]],\n          pressures,\n        });\n      } else if (isLinearElement(draggingElement)) {\n        pointerDownState.drag.hasOccurred = true;\n        const points = draggingElement.points;\n        let dx = gridX - draggingElement.x;\n        let dy = gridY - draggingElement.y;\n\n        if (getRotateWithDiscreteAngleKey(event) && points.length === 2) {\n          ({ width: dx, height: dy } = getPerfectElementSize(\n            this.state.elementType,\n            dx,\n            dy,\n          ));\n        }\n\n        if (points.length === 1) {\n          mutateElement(draggingElement, { points: [...points, [dx, dy]] });\n        } else if (points.length > 1) {\n          mutateElement(draggingElement, {\n            points: [...points.slice(0, -1), [dx, dy]],\n          });\n        }\n\n        if (isBindingElement(draggingElement)) {\n          // When creating a linear element by dragging\n          this.maybeSuggestBindingForLinearElementAtCursor(\n            draggingElement,\n            \"end\",\n            pointerCoords,\n            this.state.startBoundElement,\n          );\n        }\n      } else {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        this.maybeDragNewGenericElement(pointerDownState, event);\n      }\n\n      if (this.state.elementType === \"selection\") {\n        const elements = this.scene.getElements();\n        if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {\n          if (pointerDownState.withCmdOrCtrl && pointerDownState.hit.element) {\n            this.setState((prevState) =>\n              selectGroupsForSelectedElements(\n                {\n                  ...prevState,\n                  selectedElementIds: {\n                    [pointerDownState.hit.element!.id]: true,\n                  },\n                },\n                this.scene.getElements(),\n              ),\n            );\n          } else {\n            this.setState({\n              selectedElementIds: {},\n              selectedGroupIds: {},\n              editingGroupId: null,\n            });\n          }\n        }\n        const elementsWithinSelection = getElementsWithinSelection(\n          elements,\n          draggingElement,\n        );\n        this.setState((prevState) =>\n          selectGroupsForSelectedElements(\n            {\n              ...prevState,\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                ...elementsWithinSelection.reduce((map, element) => {\n                  map[element.id] = true;\n                  return map;\n                }, {} as any),\n                ...(pointerDownState.hit.element\n                  ? {\n                      // if using ctrl/cmd, select the hitElement only if we\n                      // haven't box-selected anything else\n                      [pointerDownState.hit.element\n                        .id]: !elementsWithinSelection.length,\n                    }\n                  : null),\n              },\n            },\n            this.scene.getElements(),\n          ),\n        );\n      }\n    });\n  }\n\n  // Returns whether the pointer move happened over either scrollbar\n  private handlePointerMoveOverScrollbars(\n    event: PointerEvent,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (pointerDownState.scrollbars.isOverHorizontal) {\n      const x = event.clientX;\n      const dx = x - pointerDownState.lastCoords.x;\n      this.setState({\n        scrollX: this.state.scrollX - dx / this.state.zoom.value,\n      });\n      pointerDownState.lastCoords.x = x;\n      return true;\n    }\n\n    if (pointerDownState.scrollbars.isOverVertical) {\n      const y = event.clientY;\n      const dy = y - pointerDownState.lastCoords.y;\n      this.setState({\n        scrollY: this.state.scrollY - dy / this.state.zoom.value,\n      });\n      pointerDownState.lastCoords.y = y;\n      return true;\n    }\n    return false;\n  }\n\n  private onPointerUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: PointerEvent) => void {\n    return withBatchedUpdates((childEvent: PointerEvent) => {\n      const {\n        draggingElement,\n        resizingElement,\n        multiElement,\n        elementType,\n        elementLocked,\n        isResizing,\n        isRotating,\n      } = this.state;\n\n      this.setState({\n        isResizing: false,\n        isRotating: false,\n        resizingElement: null,\n        selectionElement: null,\n        cursorButton: \"up\",\n        // text elements are reset on finalize, and resetting on pointerup\n        // may cause issues with double taps\n        editingElement:\n          multiElement || isTextElement(this.state.editingElement)\n            ? this.state.editingElement\n            : null,\n      });\n\n      this.savePointer(childEvent.clientX, childEvent.clientY, \"up\");\n\n      // Handle end of dragging a point of a linear element, might close a loop\n      // and sets binding element\n      if (this.state.editingLinearElement) {\n        const editingLinearElement = LinearElementEditor.handlePointerUp(\n          childEvent,\n          this.state.editingLinearElement,\n          this.state,\n        );\n        if (editingLinearElement !== this.state.editingLinearElement) {\n          this.setState({\n            editingLinearElement,\n            suggestedBindings: [],\n          });\n        }\n      }\n\n      lastPointerUp = null;\n\n      window.removeEventListener(\n        EVENT.POINTER_MOVE,\n        pointerDownState.eventListeners.onMove!,\n      );\n      window.removeEventListener(\n        EVENT.POINTER_UP,\n        pointerDownState.eventListeners.onUp!,\n      );\n      window.removeEventListener(\n        EVENT.KEYDOWN,\n        pointerDownState.eventListeners.onKeyDown!,\n      );\n      window.removeEventListener(\n        EVENT.KEYUP,\n        pointerDownState.eventListeners.onKeyUp!,\n      );\n\n      if (draggingElement?.type === \"freedraw\") {\n        const pointerCoords = viewportCoordsToSceneCoords(\n          childEvent,\n          this.state,\n        );\n\n        const points = draggingElement.points;\n        let dx = pointerCoords.x - draggingElement.x;\n        let dy = pointerCoords.y - draggingElement.y;\n\n        // Allows dots to avoid being flagged as infinitely small\n        if (dx === points[0][0] && dy === points[0][1]) {\n          dy += 0.0001;\n          dx += 0.0001;\n        }\n\n        const pressures = draggingElement.simulatePressure\n          ? []\n          : [...draggingElement.pressures, childEvent.pressure];\n\n        mutateElement(draggingElement, {\n          points: [...points, [dx, dy]],\n          pressures,\n        });\n\n        this.actionManager.executeAction(actionFinalize);\n\n        return;\n      }\n\n      if (isLinearElement(draggingElement)) {\n        if (draggingElement!.points.length > 1) {\n          this.history.resumeRecording();\n        }\n        const pointerCoords = viewportCoordsToSceneCoords(\n          childEvent,\n          this.state,\n        );\n\n        if (\n          !pointerDownState.drag.hasOccurred &&\n          draggingElement &&\n          !multiElement\n        ) {\n          mutateElement(draggingElement, {\n            points: [\n              ...draggingElement.points,\n              [\n                pointerCoords.x - draggingElement.x,\n                pointerCoords.y - draggingElement.y,\n              ],\n            ],\n          });\n          this.setState({\n            multiElement: draggingElement,\n            editingElement: this.state.draggingElement,\n          });\n        } else if (pointerDownState.drag.hasOccurred && !multiElement) {\n          if (\n            isBindingEnabled(this.state) &&\n            isBindingElement(draggingElement)\n          ) {\n            maybeBindLinearElement(\n              draggingElement,\n              this.state,\n              this.scene,\n              pointerCoords,\n            );\n          }\n          this.setState({ suggestedBindings: [], startBoundElement: null });\n          if (!elementLocked) {\n            resetCursor(this.canvas);\n            this.setState((prevState) => ({\n              draggingElement: null,\n              elementType: \"selection\",\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          } else {\n            this.setState((prevState) => ({\n              draggingElement: null,\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          }\n        }\n        return;\n      }\n\n      if (\n        elementType !== \"selection\" &&\n        draggingElement &&\n        isInvisiblySmallElement(draggingElement)\n      ) {\n        // remove invisible element which was added in onPointerDown\n        this.scene.replaceAllElements(\n          this.scene.getElementsIncludingDeleted().slice(0, -1),\n        );\n        this.setState({\n          draggingElement: null,\n        });\n        return;\n      }\n\n      if (draggingElement) {\n        mutateElement(\n          draggingElement,\n          getNormalizedDimensions(draggingElement),\n        );\n      }\n\n      if (resizingElement) {\n        this.history.resumeRecording();\n      }\n\n      if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n        this.scene.replaceAllElements(\n          this.scene\n            .getElementsIncludingDeleted()\n            .filter((el) => el.id !== resizingElement.id),\n        );\n      }\n\n      // Code below handles selection when element(s) weren't\n      // drag or added to selection on pointer down phase.\n      const hitElement = pointerDownState.hit.element;\n      if (\n        hitElement &&\n        !pointerDownState.drag.hasOccurred &&\n        !pointerDownState.hit.wasAddedToSelection\n      ) {\n        if (childEvent.shiftKey) {\n          if (this.state.selectedElementIds[hitElement.id]) {\n            if (isSelectedViaGroup(this.state, hitElement)) {\n              // We want to unselect all groups hitElement is part of\n              // as well as all elements that are part of the groups\n              // hitElement is part of\n              const idsOfSelectedElementsThatAreInGroups = hitElement.groupIds\n                .flatMap((groupId) =>\n                  getElementsInGroup(this.scene.getElements(), groupId),\n                )\n                .map((element) => ({ [element.id]: false }))\n                .reduce((prevId, acc) => ({ ...prevId, ...acc }), {});\n\n              this.setState((_prevState) => ({\n                selectedGroupIds: {\n                  ..._prevState.selectedElementIds,\n                  ...hitElement.groupIds\n                    .map((gId) => ({ [gId]: false }))\n                    .reduce((prev, acc) => ({ ...prev, ...acc }), {}),\n                },\n                selectedElementIds: {\n                  ..._prevState.selectedElementIds,\n                  ...idsOfSelectedElementsThatAreInGroups,\n                },\n              }));\n            } else {\n              // remove element from selection while\n              // keeping prev elements selected\n              this.setState((prevState) =>\n                selectGroupsForSelectedElements(\n                  {\n                    ...prevState,\n                    selectedElementIds: {\n                      ...prevState.selectedElementIds,\n                      [hitElement!.id]: false,\n                    },\n                  },\n                  this.scene.getElements(),\n                ),\n              );\n            }\n          } else {\n            // add element to selection while\n            // keeping prev elements selected\n            this.setState((_prevState) => ({\n              selectedElementIds: {\n                ..._prevState.selectedElementIds,\n                [hitElement!.id]: true,\n              },\n            }));\n          }\n        } else {\n          this.setState((prevState) => ({\n            ...selectGroupsForSelectedElements(\n              {\n                ...prevState,\n                selectedElementIds: { [hitElement.id]: true },\n              },\n              this.scene.getElements(),\n            ),\n          }));\n        }\n      }\n\n      if (\n        !this.state.editingLinearElement &&\n        !pointerDownState.drag.hasOccurred &&\n        !this.state.isResizing &&\n        ((hitElement &&\n          isHittingElementBoundingBoxWithoutHittingElement(\n            hitElement,\n            this.state,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          )) ||\n          (!hitElement &&\n            pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements))\n      ) {\n        // Deselect selected elements\n        this.setState({\n          selectedElementIds: {},\n          selectedGroupIds: {},\n          editingGroupId: null,\n        });\n\n        return;\n      }\n\n      if (!elementLocked && elementType !== \"freedraw\" && draggingElement) {\n        this.setState((prevState) => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [draggingElement.id]: true,\n          },\n        }));\n      }\n\n      if (\n        elementType !== \"selection\" ||\n        isSomeElementSelected(this.scene.getElements(), this.state)\n      ) {\n        this.history.resumeRecording();\n      }\n\n      if (pointerDownState.drag.hasOccurred || isResizing || isRotating) {\n        (isBindingEnabled(this.state)\n          ? bindOrUnbindSelectedElements\n          : unbindLinearElements)(\n          getSelectedElements(this.scene.getElements(), this.state),\n        );\n      }\n\n      if (!elementLocked && elementType !== \"freedraw\") {\n        resetCursor(this.canvas);\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n          elementType: \"selection\",\n        });\n      } else {\n        this.setState({\n          draggingElement: null,\n          suggestedBindings: [],\n        });\n      }\n    });\n  }\n\n  private updateBindingEnabledOnPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);\n    if (this.state.isBindingEnabled !== shouldEnableBinding) {\n      this.setState({ isBindingEnabled: shouldEnableBinding });\n    }\n  };\n\n  private maybeSuggestBindingAtCursor = (pointerCoords: {\n    x: number;\n    y: number;\n  }): void => {\n    const hoveredBindableElement = getHoveredElementForBinding(\n      pointerCoords,\n      this.scene,\n    );\n    this.setState({\n      suggestedBindings:\n        hoveredBindableElement != null ? [hoveredBindableElement] : [],\n    });\n  };\n\n  private maybeSuggestBindingForLinearElementAtCursor = (\n    linearElement: NonDeleted<ExcalidrawLinearElement>,\n    startOrEnd: \"start\" | \"end\",\n    pointerCoords: {\n      x: number;\n      y: number;\n    },\n    // During line creation the start binding hasn't been written yet\n    // into `linearElement`\n    oppositeBindingBoundElement?: ExcalidrawBindableElement | null,\n  ): void => {\n    const hoveredBindableElement = getHoveredElementForBinding(\n      pointerCoords,\n      this.scene,\n    );\n    this.setState({\n      suggestedBindings:\n        hoveredBindableElement != null &&\n        !isLinearElementSimpleAndAlreadyBound(\n          linearElement,\n          oppositeBindingBoundElement?.id,\n          hoveredBindableElement,\n        )\n          ? [hoveredBindableElement]\n          : [],\n    });\n  };\n\n  private maybeSuggestBindingForAll(\n    selectedElements: NonDeleted<ExcalidrawElement>[],\n  ): void {\n    const suggestedBindings = getEligibleElementsForBinding(selectedElements);\n    this.setState({ suggestedBindings });\n  }\n\n  private clearSelection(hitElement: ExcalidrawElement | null): void {\n    this.setState((prevState) => ({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      // Continue editing the same group if the user selected a different\n      // element from it\n      editingGroupId:\n        prevState.editingGroupId &&\n        hitElement != null &&\n        isElementInGroup(hitElement, prevState.editingGroupId)\n          ? prevState.editingGroupId\n          : null,\n    }));\n    this.setState({\n      selectedElementIds: {},\n      previousSelectedElementIds: this.state.selectedElementIds,\n    });\n  }\n\n  private handleCanvasRef = (canvas: HTMLCanvasElement) => {\n    // canvas is null when unmounting\n    if (canvas !== null) {\n      this.canvas = canvas;\n      this.rc = rough.canvas(this.canvas);\n\n      this.canvas.addEventListener(EVENT.WHEEL, this.handleWheel, {\n        passive: false,\n      });\n      this.canvas.addEventListener(EVENT.TOUCH_START, this.onTapStart);\n      this.canvas.addEventListener(EVENT.TOUCH_END, this.onTapEnd);\n    } else {\n      this.canvas?.removeEventListener(EVENT.WHEEL, this.handleWheel);\n      this.canvas?.removeEventListener(EVENT.TOUCH_START, this.onTapStart);\n      this.canvas?.removeEventListener(EVENT.TOUCH_END, this.onTapEnd);\n    }\n  };\n\n  private handleAppOnDrop = async (event: React.DragEvent<HTMLDivElement>) => {\n    try {\n      const file = event.dataTransfer.files[0];\n      if (file?.type === \"image/png\" || file?.type === \"image/svg+xml\") {\n        const { elements, appState } = await loadFromBlob(\n          file,\n          this.state,\n          this.scene.getElementsIncludingDeleted(),\n        );\n        this.syncActionResult({\n          elements,\n          appState: {\n            ...(appState || this.state),\n            isLoading: false,\n          },\n          commitToHistory: true,\n        });\n        return;\n      }\n    } catch (error) {\n      return this.setState({\n        isLoading: false,\n        errorMessage: error.message,\n      });\n    }\n\n    const libraryShapes = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);\n    if (libraryShapes !== \"\") {\n      this.addElementsFromPasteOrLibrary({\n        elements: JSON.parse(libraryShapes),\n        position: event,\n      });\n      return;\n    }\n\n    const file = event.dataTransfer?.files[0];\n    if (\n      file?.type === MIME_TYPES.excalidrawlib ||\n      file?.name?.endsWith(\".excalidrawlib\")\n    ) {\n      this.library\n        .importLibrary(file)\n        .then(() => {\n          // Close and then open to get the libraries updated\n          this.setState({ isLibraryOpen: false });\n          this.setState({ isLibraryOpen: true });\n        })\n        .catch((error) =>\n          this.setState({ isLoading: false, errorMessage: error.message }),\n        );\n      // default: assume an Excalidraw file regardless of extension/MimeType\n    } else {\n      this.setState({ isLoading: true });\n      if (fsSupported) {\n        try {\n          // This will only work as of Chrome 86,\n          // but can be safely ignored on older releases.\n          const item = event.dataTransfer.items[0];\n          (file as any).handle = await (item as any).getAsFileSystemHandle();\n        } catch (error) {\n          console.warn(error.name, error.message);\n        }\n      }\n      await this.loadFileToCanvas(file);\n    }\n  };\n\n  loadFileToCanvas = (file: Blob) => {\n    loadFromBlob(file, this.state, this.scene.getElementsIncludingDeleted())\n      .then(({ elements, appState }) =>\n        this.syncActionResult({\n          elements,\n          appState: {\n            ...(appState || this.state),\n            isLoading: false,\n          },\n          commitToHistory: true,\n        }),\n      )\n      .catch((error) => {\n        this.setState({ isLoading: false, errorMessage: error.message });\n      });\n  };\n\n  private handleCanvasContextMenu = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    event.preventDefault();\n\n    const { x, y } = viewportCoordsToSceneCoords(event, this.state);\n    const element = this.getElementAtPosition(x, y, { preferSelected: true });\n\n    const type = element ? \"element\" : \"canvas\";\n\n    const container = this.excalidrawContainerRef.current!;\n    const {\n      top: offsetTop,\n      left: offsetLeft,\n    } = container.getBoundingClientRect();\n    const left = event.clientX - offsetLeft;\n    const top = event.clientY - offsetTop;\n\n    if (element && !this.state.selectedElementIds[element.id]) {\n      this.setState({ selectedElementIds: { [element.id]: true } }, () => {\n        this._openContextMenu({ top, left }, type);\n      });\n    } else {\n      this._openContextMenu({ top, left }, type);\n    }\n  };\n\n  private maybeDragNewGenericElement = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): void => {\n    const draggingElement = this.state.draggingElement;\n    const pointerCoords = pointerDownState.lastCoords;\n    if (!draggingElement) {\n      return;\n    }\n    if (draggingElement.type === \"selection\") {\n      dragNewElement(\n        draggingElement,\n        this.state.elementType,\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        pointerCoords.x,\n        pointerCoords.y,\n        distance(pointerDownState.origin.x, pointerCoords.x),\n        distance(pointerDownState.origin.y, pointerCoords.y),\n        getResizeWithSidesSameLengthKey(event),\n        getResizeCenterPointKey(event),\n      );\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        this.state.gridSize,\n      );\n      dragNewElement(\n        draggingElement,\n        this.state.elementType,\n        pointerDownState.originInGrid.x,\n        pointerDownState.originInGrid.y,\n        gridX,\n        gridY,\n        distance(pointerDownState.originInGrid.x, gridX),\n        distance(pointerDownState.originInGrid.y, gridY),\n        getResizeWithSidesSameLengthKey(event),\n        getResizeCenterPointKey(event),\n      );\n      this.maybeSuggestBindingForAll([draggingElement]);\n    }\n  };\n\n  private maybeHandleResize = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): boolean => {\n    const selectedElements = getSelectedElements(\n      this.scene.getElements(),\n      this.state,\n    );\n    const transformHandleType = pointerDownState.resize.handleType;\n    this.setState({\n      // TODO: rename this state field to \"isScaling\" to distinguish\n      // it from the generic \"isResizing\" which includes scaling and\n      // rotating\n      isResizing: transformHandleType && transformHandleType !== \"rotation\",\n      isRotating: transformHandleType === \"rotation\",\n    });\n    const pointerCoords = pointerDownState.lastCoords;\n    const [resizeX, resizeY] = getGridPoint(\n      pointerCoords.x - pointerDownState.resize.offset.x,\n      pointerCoords.y - pointerDownState.resize.offset.y,\n      this.state.gridSize,\n    );\n    if (\n      transformElements(\n        pointerDownState,\n        transformHandleType,\n        selectedElements,\n        pointerDownState.resize.arrowDirection,\n        getRotateWithDiscreteAngleKey(event),\n        getResizeCenterPointKey(event),\n        getResizeWithSidesSameLengthKey(event),\n        resizeX,\n        resizeY,\n        pointerDownState.resize.center.x,\n        pointerDownState.resize.center.y,\n      )\n    ) {\n      this.maybeSuggestBindingForAll(selectedElements);\n      return true;\n    }\n    return false;\n  };\n\n  /** @private use this.handleCanvasContextMenu */\n  private _openContextMenu = (\n    {\n      left,\n      top,\n    }: {\n      left: number;\n      top: number;\n    },\n    type: \"canvas\" | \"element\",\n  ) => {\n    const maybeGroupAction = actionGroup.contextItemPredicate!(\n      this.actionManager.getElementsIncludingDeleted(),\n      this.actionManager.getAppState(),\n    );\n\n    const maybeUngroupAction = actionUngroup.contextItemPredicate!(\n      this.actionManager.getElementsIncludingDeleted(),\n      this.actionManager.getAppState(),\n    );\n\n    const maybeFlipHorizontal = actionFlipHorizontal.contextItemPredicate!(\n      this.actionManager.getElementsIncludingDeleted(),\n      this.actionManager.getAppState(),\n    );\n\n    const maybeFlipVertical = actionFlipVertical.contextItemPredicate!(\n      this.actionManager.getElementsIncludingDeleted(),\n      this.actionManager.getAppState(),\n    );\n\n    const separator = \"separator\";\n\n    const elements = this.scene.getElements();\n\n    const options: ContextMenuOption[] = [];\n    if (probablySupportsClipboardBlob && elements.length > 0) {\n      options.push(actionCopyAsPng);\n    }\n\n    if (probablySupportsClipboardWriteText && elements.length > 0) {\n      options.push(actionCopyAsSvg);\n    }\n    if (type === \"canvas\") {\n      const viewModeOptions = [\n        ...options,\n        typeof this.props.gridModeEnabled === \"undefined\" &&\n          actionToggleGridMode,\n        typeof this.props.zenModeEnabled === \"undefined\" && actionToggleZenMode,\n        typeof this.props.viewModeEnabled === \"undefined\" &&\n          actionToggleViewMode,\n        actionToggleStats,\n      ];\n\n      ContextMenu.push({\n        options: viewModeOptions,\n        top,\n        left,\n        actionManager: this.actionManager,\n        appState: this.state,\n        container: this.excalidrawContainerRef.current!,\n      });\n\n      if (this.state.viewModeEnabled) {\n        return;\n      }\n\n      ContextMenu.push({\n        options: [\n          this.isMobile &&\n            navigator.clipboard && {\n              name: \"paste\",\n              perform: (elements, appStates) => {\n                this.pasteFromClipboard(null);\n                return {\n                  commitToHistory: false,\n                };\n              },\n              contextItemLabel: \"labels.paste\",\n            },\n          this.isMobile && navigator.clipboard && separator,\n          probablySupportsClipboardBlob &&\n            elements.length > 0 &&\n            actionCopyAsPng,\n          probablySupportsClipboardWriteText &&\n            elements.length > 0 &&\n            actionCopyAsSvg,\n          ((probablySupportsClipboardBlob && elements.length > 0) ||\n            (probablySupportsClipboardWriteText && elements.length > 0)) &&\n            separator,\n          actionSelectAll,\n          separator,\n          typeof this.props.gridModeEnabled === \"undefined\" &&\n            actionToggleGridMode,\n          typeof this.props.zenModeEnabled === \"undefined\" &&\n            actionToggleZenMode,\n          typeof this.props.viewModeEnabled === \"undefined\" &&\n            actionToggleViewMode,\n          actionToggleStats,\n        ],\n        top,\n        left,\n        actionManager: this.actionManager,\n        appState: this.state,\n        container: this.excalidrawContainerRef.current!,\n      });\n      return;\n    }\n\n    if (this.state.viewModeEnabled) {\n      ContextMenu.push({\n        options: [navigator.clipboard && actionCopy, ...options],\n        top,\n        left,\n        actionManager: this.actionManager,\n        appState: this.state,\n        container: this.excalidrawContainerRef.current!,\n      });\n      return;\n    }\n\n    ContextMenu.push({\n      options: [\n        this.isMobile && actionCut,\n        this.isMobile && navigator.clipboard && actionCopy,\n        this.isMobile &&\n          navigator.clipboard && {\n            name: \"paste\",\n            perform: (elements, appStates) => {\n              this.pasteFromClipboard(null);\n              return {\n                commitToHistory: false,\n              };\n            },\n            contextItemLabel: \"labels.paste\",\n          },\n        this.isMobile && separator,\n        ...options,\n        separator,\n        actionCopyStyles,\n        actionPasteStyles,\n        separator,\n        maybeGroupAction && actionGroup,\n        maybeUngroupAction && actionUngroup,\n        (maybeGroupAction || maybeUngroupAction) && separator,\n        actionAddToLibrary,\n        separator,\n        actionSendBackward,\n        actionBringForward,\n        actionSendToBack,\n        actionBringToFront,\n        separator,\n        maybeFlipHorizontal && actionFlipHorizontal,\n        maybeFlipVertical && actionFlipVertical,\n        (maybeFlipHorizontal || maybeFlipVertical) && separator,\n        actionDuplicateSelection,\n        actionDeleteSelected,\n      ],\n      top,\n      left,\n      actionManager: this.actionManager,\n      appState: this.state,\n      container: this.excalidrawContainerRef.current!,\n    });\n  };\n\n  private handleWheel = withBatchedUpdates((event: WheelEvent) => {\n    event.preventDefault();\n\n    if (isPanning) {\n      return;\n    }\n\n    const { deltaX, deltaY } = event;\n    const { selectedElementIds, previousSelectedElementIds } = this.state;\n    // note that event.ctrlKey is necessary to handle pinch zooming\n    if (event.metaKey || event.ctrlKey) {\n      const sign = Math.sign(deltaY);\n      const MAX_STEP = 10;\n      let delta = Math.abs(deltaY);\n      if (delta > MAX_STEP) {\n        delta = MAX_STEP;\n      }\n      delta *= sign;\n      if (Object.keys(previousSelectedElementIds).length !== 0) {\n        setTimeout(() => {\n          this.setState({\n            selectedElementIds: previousSelectedElementIds,\n            previousSelectedElementIds: {},\n          });\n        }, 1000);\n      }\n\n      let newZoom = this.state.zoom.value - delta / 100;\n      // increase zoom steps the more zoomed-in we are (applies to >100% only)\n      newZoom += Math.log10(Math.max(1, this.state.zoom.value)) * -sign;\n      // round to nearest step\n      newZoom = Math.round(newZoom * ZOOM_STEP * 100) / (ZOOM_STEP * 100);\n\n      this.setState(({ zoom, offsetLeft, offsetTop }) => ({\n        zoom: getNewZoom(\n          getNormalizedZoom(newZoom),\n          zoom,\n          { left: offsetLeft, top: offsetTop },\n          {\n            x: cursorX,\n            y: cursorY,\n          },\n        ),\n        selectedElementIds: {},\n        previousSelectedElementIds:\n          Object.keys(selectedElementIds).length !== 0\n            ? selectedElementIds\n            : previousSelectedElementIds,\n        shouldCacheIgnoreZoom: true,\n      }));\n      this.resetShouldCacheIgnoreZoomDebounced();\n      return;\n    }\n\n    // scroll horizontally when shift pressed\n    if (event.shiftKey) {\n      this.setState(({ zoom, scrollX }) => ({\n        // on Mac, shift+wheel tends to result in deltaX\n        scrollX: scrollX - (deltaY || deltaX) / zoom.value,\n      }));\n      return;\n    }\n\n    this.setState(({ zoom, scrollX, scrollY }) => ({\n      scrollX: scrollX - deltaX / zoom.value,\n      scrollY: scrollY - deltaY / zoom.value,\n    }));\n  });\n\n  private getTextWysiwygSnappedToCenterPosition(\n    x: number,\n    y: number,\n    appState: AppState,\n    canvas: HTMLCanvasElement | null,\n    scale: number,\n  ) {\n    const elementClickedInside = getElementContainingPosition(\n      this.scene\n        .getElementsIncludingDeleted()\n        .filter((element) => !isTextElement(element)),\n      x,\n      y,\n    );\n    if (elementClickedInside) {\n      const elementCenterX =\n        elementClickedInside.x + elementClickedInside.width / 2;\n      const elementCenterY =\n        elementClickedInside.y + elementClickedInside.height / 2;\n      const distanceToCenter = Math.hypot(\n        x - elementCenterX,\n        y - elementCenterY,\n      );\n      const isSnappedToCenter =\n        distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n      if (isSnappedToCenter) {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          { sceneX: elementCenterX, sceneY: elementCenterY },\n          appState,\n        );\n        return { viewportX, viewportY, elementCenterX, elementCenterY };\n      }\n    }\n  }\n\n  private savePointer = (x: number, y: number, button: \"up\" | \"down\") => {\n    if (!x || !y) {\n      return;\n    }\n    const pointer = viewportCoordsToSceneCoords(\n      { clientX: x, clientY: y },\n      this.state,\n    );\n\n    if (isNaN(pointer.x) || isNaN(pointer.y)) {\n      // sometimes the pointer goes off screen\n    }\n\n    this.props.onPointerUpdate?.({\n      pointer,\n      button,\n      pointersMap: gesture.pointers,\n    });\n  };\n\n  private resetShouldCacheIgnoreZoomDebounced = debounce(() => {\n    if (!this.unmounted) {\n      this.setState({ shouldCacheIgnoreZoom: false });\n    }\n  }, 300);\n\n  private updateDOMRect = (cb?: () => void) => {\n    if (this.excalidrawContainerRef?.current) {\n      const excalidrawContainer = this.excalidrawContainerRef.current;\n      const {\n        width,\n        height,\n        left: offsetLeft,\n        top: offsetTop,\n      } = excalidrawContainer.getBoundingClientRect();\n      const {\n        width: currentWidth,\n        height: currentHeight,\n        offsetTop: currentOffsetTop,\n        offsetLeft: currentOffsetLeft,\n      } = this.state;\n\n      if (\n        width === currentWidth &&\n        height === currentHeight &&\n        offsetLeft === currentOffsetLeft &&\n        offsetTop === currentOffsetTop\n      ) {\n        if (cb) {\n          cb();\n        }\n        return;\n      }\n\n      this.setState(\n        {\n          width,\n          height,\n          offsetLeft,\n          offsetTop,\n        },\n        () => {\n          cb && cb();\n        },\n      );\n    }\n  };\n\n  public refresh = () => {\n    this.setState({ ...this.getCanvasOffsets() });\n  };\n\n  private getCanvasOffsets(): Pick<AppState, \"offsetTop\" | \"offsetLeft\"> {\n    if (this.excalidrawContainerRef?.current) {\n      const excalidrawContainer = this.excalidrawContainerRef.current;\n      const { left, top } = excalidrawContainer.getBoundingClientRect();\n      return {\n        offsetLeft: left,\n        offsetTop: top,\n      };\n    }\n    return {\n      offsetLeft: 0,\n      offsetTop: 0,\n    };\n  }\n\n  private async updateLanguage() {\n    const currentLang =\n      languages.find((lang) => lang.code === this.props.langCode) ||\n      defaultLang;\n    await setLanguage(currentLang);\n    this.setAppState({});\n  }\n}\n\n// -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\n\ndeclare global {\n  interface Window {\n    h: {\n      elements: readonly ExcalidrawElement[];\n      state: AppState;\n      setState: React.Component<any, AppState>[\"setState\"];\n      app: InstanceType<typeof App>;\n      history: History;\n    };\n  }\n}\n\nif (\n  process.env.NODE_ENV === ENV.TEST ||\n  process.env.NODE_ENV === ENV.DEVELOPMENT\n) {\n  window.h = window.h || ({} as Window[\"h\"]);\n\n  Object.defineProperties(window.h, {\n    elements: {\n      configurable: true,\n      get() {\n        return this.app.scene.getElementsIncludingDeleted();\n      },\n      set(elements: ExcalidrawElement[]) {\n        return this.app.scene.replaceAllElements(elements);\n      },\n    },\n  });\n}\nexport default App;\n","import \"./Modal.scss\";\n\nimport React, { useState, useLayoutEffect, useRef } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport clsx from \"clsx\";\nimport { KEYS } from \"../keys\";\nimport { useExcalidrawContainer, useIsMobile } from \"./App\";\nimport { AppState } from \"../types\";\n\nexport const Modal = (props: {\n  className?: string;\n  children: React.ReactNode;\n  maxWidth?: number;\n  onCloseRequest(): void;\n  labelledBy: string;\n  theme?: AppState[\"theme\"];\n}) => {\n  const { theme = \"light\" } = props;\n  const modalRoot = useBodyRoot(theme);\n\n  if (!modalRoot) {\n    return null;\n  }\n\n  const handleKeydown = (event: React.KeyboardEvent) => {\n    if (event.key === KEYS.ESCAPE) {\n      event.nativeEvent.stopImmediatePropagation();\n      event.stopPropagation();\n      props.onCloseRequest();\n    }\n  };\n\n  return createPortal(\n    <div\n      className={clsx(\"Modal\", props.className)}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      onKeyDown={handleKeydown}\n      aria-labelledby={props.labelledBy}\n    >\n      <div className=\"Modal__background\" onClick={props.onCloseRequest}></div>\n      <div\n        className=\"Modal__content\"\n        style={{ \"--max-width\": `${props.maxWidth}px` }}\n        tabIndex={0}\n      >\n        {props.children}\n      </div>\n    </div>,\n    modalRoot,\n  );\n};\n\nconst useBodyRoot = (theme: AppState[\"theme\"]) => {\n  const [div, setDiv] = useState<HTMLDivElement | null>(null);\n\n  const isMobile = useIsMobile();\n  const isMobileRef = useRef(isMobile);\n  isMobileRef.current = isMobile;\n\n  const { container: excalidrawContainer } = useExcalidrawContainer();\n\n  useLayoutEffect(() => {\n    if (div) {\n      div.classList.toggle(\"excalidraw--mobile\", isMobile);\n    }\n  }, [div, isMobile]);\n\n  useLayoutEffect(() => {\n    const isDarkTheme =\n      !!excalidrawContainer?.classList.contains(\"theme--dark\") ||\n      theme === \"dark\";\n    const div = document.createElement(\"div\");\n\n    div.classList.add(\"excalidraw\", \"excalidraw-modal-container\");\n    div.classList.toggle(\"excalidraw--mobile\", isMobileRef.current);\n\n    if (isDarkTheme) {\n      div.classList.add(\"theme--dark\");\n      div.classList.add(\"theme--dark-background-none\");\n    }\n    document.body.appendChild(div);\n\n    setDiv(div);\n\n    return () => {\n      document.body.removeChild(div);\n    };\n  }, [excalidrawContainer, theme]);\n\n  return div;\n};\n","import clsx from \"clsx\";\nimport React, { useEffect, useState } from \"react\";\nimport { useCallbackRefState } from \"../hooks/useCallbackRefState\";\nimport { t } from \"../i18n\";\nimport { useExcalidrawContainer, useIsMobile } from \"../components/App\";\nimport { KEYS } from \"../keys\";\nimport \"./Dialog.scss\";\nimport { back, close } from \"./icons\";\nimport { Island } from \"./Island\";\nimport { Modal } from \"./Modal\";\nimport { AppState } from \"../types\";\n\nexport const Dialog = (props: {\n  children: React.ReactNode;\n  className?: string;\n  small?: boolean;\n  onCloseRequest(): void;\n  title: React.ReactNode;\n  autofocus?: boolean;\n  theme?: AppState[\"theme\"];\n}) => {\n  const [islandNode, setIslandNode] = useCallbackRefState<HTMLDivElement>();\n  const [lastActiveElement] = useState(document.activeElement);\n  const { id } = useExcalidrawContainer();\n\n  useEffect(() => {\n    if (!islandNode) {\n      return;\n    }\n\n    const focusableElements = queryFocusableElements(islandNode);\n\n    if (focusableElements.length > 0 && props.autofocus !== false) {\n      // If there's an element other than close, focus it.\n      (focusableElements[1] || focusableElements[0]).focus();\n    }\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === KEYS.TAB) {\n        const focusableElements = queryFocusableElements(islandNode);\n        const { activeElement } = document;\n        const currentIndex = focusableElements.findIndex(\n          (element) => element === activeElement,\n        );\n\n        if (currentIndex === 0 && event.shiftKey) {\n          focusableElements[focusableElements.length - 1].focus();\n          event.preventDefault();\n        } else if (\n          currentIndex === focusableElements.length - 1 &&\n          !event.shiftKey\n        ) {\n          focusableElements[0].focus();\n          event.preventDefault();\n        }\n      }\n    };\n\n    islandNode.addEventListener(\"keydown\", handleKeyDown);\n\n    return () => islandNode.removeEventListener(\"keydown\", handleKeyDown);\n  }, [islandNode, props.autofocus]);\n\n  const queryFocusableElements = (node: HTMLElement) => {\n    const focusableElements = node.querySelectorAll<HTMLElement>(\n      \"button, a, input, select, textarea, div[tabindex]\",\n    );\n\n    return focusableElements ? Array.from(focusableElements) : [];\n  };\n\n  const onClose = () => {\n    (lastActiveElement as HTMLElement).focus();\n    props.onCloseRequest();\n  };\n\n  return (\n    <Modal\n      className={clsx(\"Dialog\", props.className)}\n      labelledBy=\"dialog-title\"\n      maxWidth={props.small ? 550 : 800}\n      onCloseRequest={onClose}\n      theme={props.theme}\n    >\n      <Island ref={setIslandNode}>\n        <h2 id={`${id}-dialog-title`} className=\"Dialog__title\">\n          <span className=\"Dialog__titleContent\">{props.title}</span>\n          <button\n            className=\"Modal__close\"\n            onClick={onClose}\n            aria-label={t(\"buttons.close\")}\n          >\n            {useIsMobile() ? back : close}\n          </button>\n        </h2>\n        <div className=\"Dialog__content\">{props.children}</div>\n      </Island>\n    </Modal>\n  );\n};\n","import React, { useState } from \"react\";\nimport { t } from \"../i18n\";\n\nimport { Dialog } from \"./Dialog\";\nimport { useExcalidrawContainer } from \"./App\";\n\nexport const ErrorDialog = ({\n  message,\n  onClose,\n}: {\n  message: string;\n  onClose?: () => void;\n}) => {\n  const [modalIsShown, setModalIsShown] = useState(!!message);\n  const { container: excalidrawContainer } = useExcalidrawContainer();\n\n  const handleClose = React.useCallback(() => {\n    setModalIsShown(false);\n\n    if (onClose) {\n      onClose();\n    }\n    // TODO: Fix the A11y issues so this is never needed since we should always focus on last active element\n    excalidrawContainer?.focus();\n  }, [onClose, excalidrawContainer]);\n\n  return (\n    <>\n      {modalIsShown && (\n        <Dialog\n          small\n          onCloseRequest={handleClose}\n          title={t(\"errorDialog.title\")}\n        >\n          <div style={{ whiteSpace: \"pre-wrap\" }}>{message}</div>\n        </Dialog>\n      )}\n    </>\n  );\n};\n","import React from \"react\";\nimport * as Sentry from \"@sentry/browser\";\nimport { t } from \"../i18n\";\n\ninterface TopErrorBoundaryState {\n  hasError: boolean;\n  sentryEventId: string;\n  localStorage: string;\n}\n\nexport class TopErrorBoundary extends React.Component<\n  any,\n  TopErrorBoundaryState\n> {\n  state: TopErrorBoundaryState = {\n    hasError: false,\n    sentryEventId: \"\",\n    localStorage: \"\",\n  };\n\n  render() {\n    return this.state.hasError ? this.errorSplash() : this.props.children;\n  }\n\n  componentDidCatch(error: Error, errorInfo: any) {\n    const _localStorage: any = {};\n    for (const [key, value] of Object.entries({ ...localStorage })) {\n      try {\n        _localStorage[key] = JSON.parse(value);\n      } catch (error) {\n        _localStorage[key] = value;\n      }\n    }\n\n    Sentry.withScope((scope) => {\n      scope.setExtras(errorInfo);\n      const eventId = Sentry.captureException(error);\n\n      this.setState((state) => ({\n        hasError: true,\n        sentryEventId: eventId,\n        localStorage: JSON.stringify(_localStorage),\n      }));\n    });\n  }\n\n  private selectTextArea(event: React.MouseEvent<HTMLTextAreaElement>) {\n    if (event.target !== document.activeElement) {\n      event.preventDefault();\n      (event.target as HTMLTextAreaElement).select();\n    }\n  }\n\n  private async createGithubIssue() {\n    let body = \"\";\n    try {\n      const templateStrFn = (\n        await import(\n          /* webpackChunkName: \"bug-issue-template\" */ \"../bug-issue-template\"\n        )\n      ).default;\n      body = encodeURIComponent(templateStrFn(this.state.sentryEventId));\n    } catch (error) {\n      console.error(error);\n    }\n\n    window.open(\n      `https://github.com/excalidraw/excalidraw/issues/new?body=${body}`,\n    );\n  }\n\n  private errorSplash() {\n    return (\n      <div className=\"ErrorSplash excalidraw\">\n        <div className=\"ErrorSplash-messageContainer\">\n          <div className=\"ErrorSplash-paragraph bigger align-center\">\n            {t(\"errorSplash.headingMain_pre\")}\n            <button onClick={() => window.location.reload()}>\n              {t(\"errorSplash.headingMain_button\")}\n            </button>\n          </div>\n          <div className=\"ErrorSplash-paragraph align-center\">\n            {t(\"errorSplash.clearCanvasMessage\")}\n            <button\n              onClick={() => {\n                try {\n                  localStorage.clear();\n                  window.location.reload();\n                } catch (error) {\n                  console.error(error);\n                }\n              }}\n            >\n              {t(\"errorSplash.clearCanvasMessage_button\")}\n            </button>\n            <br />\n            <div className=\"smaller\">\n              <span role=\"img\" aria-label=\"warning\">\n                ⚠️\n              </span>\n              {t(\"errorSplash.clearCanvasCaveat\")}\n              <span role=\"img\" aria-hidden=\"true\">\n                ⚠️\n              </span>\n            </div>\n          </div>\n          <div>\n            <div className=\"ErrorSplash-paragraph\">\n              {t(\"errorSplash.trackedToSentry_pre\")}\n              {this.state.sentryEventId}\n              {t(\"errorSplash.trackedToSentry_post\")}\n            </div>\n            <div className=\"ErrorSplash-paragraph\">\n              {t(\"errorSplash.openIssueMessage_pre\")}\n              <button onClick={() => this.createGithubIssue()}>\n                {t(\"errorSplash.openIssueMessage_button\")}\n              </button>\n              {t(\"errorSplash.openIssueMessage_post\")}\n            </div>\n            <div className=\"ErrorSplash-paragraph\">\n              <div className=\"ErrorSplash-details\">\n                <label>{t(\"errorSplash.sceneContent\")}</label>\n                <textarea\n                  rows={5}\n                  onPointerDown={this.selectTextArea}\n                  readOnly={true}\n                  value={this.state.localStorage}\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n","import { ENV } from \"../../constants\";\nimport pkg from \"./package.json\";\nif (process.env.NODE_ENV !== ENV.TEST) {\n  /* eslint-disable */\n  /* global __webpack_public_path__:writable */\n  __webpack_public_path__ =\n    window.EXCALIDRAW_ASSET_PATH ||\n    `https://unpkg.com/${pkg.name}@${pkg.version}/dist/`;\n}\n","import React from \"react\";\n\nimport { LoadingMessage } from \"./LoadingMessage\";\nimport { defaultLang, Language, languages, setLanguage } from \"../i18n\";\n\ninterface Props {\n  langCode: Language[\"code\"];\n}\ninterface State {\n  isLoading: boolean;\n}\nexport class InitializeApp extends React.Component<Props, State> {\n  public state: { isLoading: boolean } = {\n    isLoading: true,\n  };\n\n  async componentDidMount() {\n    const currentLang =\n      languages.find((lang) => lang.code === this.props.langCode) ||\n      defaultLang;\n    await setLanguage(currentLang);\n    this.setState({\n      isLoading: false,\n    });\n  }\n\n  public render() {\n    return this.state.isLoading ? <LoadingMessage /> : this.props.children;\n  }\n}\n","import {\n  exportToCanvas as _exportToCanvas,\n  exportToSvg as _exportToSvg,\n} from \"../scene/export\";\nimport { getDefaultAppState } from \"../appState\";\nimport { AppState } from \"../types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { getNonDeletedElements } from \"../element\";\nimport { restore } from \"../data/restore\";\n\ntype ExportOpts = {\n  elements: readonly ExcalidrawElement[];\n  appState?: Partial<Omit<AppState, \"offsetTop\" | \"offsetLeft\">>;\n  getDimensions?: (\n    width: number,\n    height: number,\n  ) => { width: number; height: number; scale: number };\n};\n\nexport const exportToCanvas = ({\n  elements,\n  appState,\n  getDimensions = (width, height) => ({ width, height, scale: 1 }),\n}: ExportOpts) => {\n  const { elements: restoredElements, appState: restoredAppState } = restore(\n    { elements, appState },\n    null,\n    null,\n  );\n  const { exportBackground, viewBackgroundColor } = restoredAppState;\n  return _exportToCanvas(\n    getNonDeletedElements(restoredElements),\n    { ...restoredAppState, offsetTop: 0, offsetLeft: 0, width: 0, height: 0 },\n    { exportBackground, viewBackgroundColor },\n    (width: number, height: number) => {\n      const canvas = document.createElement(\"canvas\");\n      const ret = getDimensions(width, height);\n\n      canvas.width = ret.width;\n      canvas.height = ret.height;\n\n      return { canvas, scale: ret.scale };\n    },\n  );\n};\n\nexport const exportToBlob = (\n  opts: ExportOpts & {\n    mimeType?: string;\n    quality?: number;\n  },\n): Promise<Blob | null> => {\n  const canvas = exportToCanvas(opts);\n\n  let { mimeType = \"image/png\", quality } = opts;\n\n  if (mimeType === \"image/png\" && typeof quality === \"number\") {\n    console.warn(`\"quality\" will be ignored for \"image/png\" mimeType`);\n  }\n\n  if (mimeType === \"image/jpg\") {\n    mimeType = \"image/jpeg\";\n  }\n\n  quality = quality ? quality : /image\\/jpe?g/.test(mimeType) ? 0.92 : 0.8;\n\n  return new Promise((resolve) => {\n    canvas.toBlob(\n      (blob: Blob | null) => {\n        resolve(blob);\n      },\n      mimeType,\n      quality,\n    );\n  });\n};\n\nexport const exportToSvg = async ({\n  elements,\n  appState = getDefaultAppState(),\n  exportPadding,\n}: Omit<ExportOpts, \"getDimensions\"> & {\n  exportPadding?: number;\n}): Promise<SVGSVGElement> => {\n  const { elements: restoredElements, appState: restoredAppState } = restore(\n    { elements, appState },\n    null,\n    null,\n  );\n  return _exportToSvg(getNonDeletedElements(restoredElements), {\n    ...restoredAppState,\n    exportPadding,\n  });\n};\n\nexport { serializeAsJSON } from \"../data/json\";\nexport { loadFromBlob, loadLibraryFromBlob } from \"../data/blob\";\nexport { getFreeDrawSvgPath } from \"../renderer/renderElement\";\n","import React, { useEffect, forwardRef } from \"react\";\nimport \"./publicPath\";\n\nimport { InitializeApp } from \"../../components/InitializeApp\";\nimport App from \"../../components/App\";\n\nimport \"../../css/app.scss\";\nimport \"../../css/styles.scss\";\n\nimport { AppProps, ExcalidrawAPIRefValue, ExcalidrawProps } from \"../../types\";\nimport { defaultLang } from \"../../i18n\";\nimport { DEFAULT_UI_OPTIONS } from \"../../constants\";\n\nconst Excalidraw = (props: ExcalidrawProps) => {\n  const {\n    onChange,\n    initialData,\n    excalidrawRef,\n    onCollabButtonClick,\n    isCollaborating,\n    onPointerUpdate,\n    renderTopRightUI,\n    renderFooter,\n    langCode = defaultLang.code,\n    viewModeEnabled,\n    zenModeEnabled,\n    gridModeEnabled,\n    libraryReturnUrl,\n    theme,\n    name,\n    renderCustomStats,\n    onPaste,\n    detectScroll = true,\n    handleKeyboardGlobally = false,\n    onLibraryChange,\n    autoFocus = false,\n  } = props;\n\n  const canvasActions = props.UIOptions?.canvasActions;\n\n  const UIOptions: AppProps[\"UIOptions\"] = {\n    canvasActions: {\n      ...DEFAULT_UI_OPTIONS.canvasActions,\n      ...canvasActions,\n    },\n  };\n\n  if (canvasActions?.export) {\n    UIOptions.canvasActions.export.saveFileToDisk =\n      canvasActions.export?.saveFileToDisk ||\n      DEFAULT_UI_OPTIONS.canvasActions.export.saveFileToDisk;\n  }\n\n  useEffect(() => {\n    // Block pinch-zooming on iOS outside of the content area\n    const handleTouchMove = (event: TouchEvent) => {\n      // @ts-ignore\n      if (typeof event.scale === \"number\" && event.scale !== 1) {\n        event.preventDefault();\n      }\n    };\n\n    document.addEventListener(\"touchmove\", handleTouchMove, {\n      passive: false,\n    });\n\n    return () => {\n      document.removeEventListener(\"touchmove\", handleTouchMove);\n    };\n  }, []);\n\n  return (\n    <InitializeApp langCode={langCode}>\n      <App\n        onChange={onChange}\n        initialData={initialData}\n        excalidrawRef={excalidrawRef}\n        onCollabButtonClick={onCollabButtonClick}\n        isCollaborating={isCollaborating}\n        onPointerUpdate={onPointerUpdate}\n        renderTopRightUI={renderTopRightUI}\n        renderFooter={renderFooter}\n        langCode={langCode}\n        viewModeEnabled={viewModeEnabled}\n        zenModeEnabled={zenModeEnabled}\n        gridModeEnabled={gridModeEnabled}\n        libraryReturnUrl={libraryReturnUrl}\n        theme={theme}\n        name={name}\n        renderCustomStats={renderCustomStats}\n        UIOptions={UIOptions}\n        onPaste={onPaste}\n        detectScroll={detectScroll}\n        handleKeyboardGlobally={handleKeyboardGlobally}\n        onLibraryChange={onLibraryChange}\n        autoFocus={autoFocus}\n      />\n    </InitializeApp>\n  );\n};\n\ntype PublicExcalidrawProps = Omit<ExcalidrawProps, \"forwardedRef\">;\n\nconst areEqual = (\n  prevProps: PublicExcalidrawProps,\n  nextProps: PublicExcalidrawProps,\n) => {\n  const {\n    initialData: prevInitialData,\n    UIOptions: prevUIOptions = {},\n    ...prev\n  } = prevProps;\n  const {\n    initialData: nextInitialData,\n    UIOptions: nextUIOptions = {},\n    ...next\n  } = nextProps;\n\n  // comparing UIOptions\n  const prevUIOptionsKeys = Object.keys(prevUIOptions) as (keyof Partial<\n    typeof DEFAULT_UI_OPTIONS\n  >)[];\n  const nextUIOptionsKeys = Object.keys(nextUIOptions) as (keyof Partial<\n    typeof DEFAULT_UI_OPTIONS\n  >)[];\n\n  if (prevUIOptionsKeys.length !== nextUIOptionsKeys.length) {\n    return false;\n  }\n\n  const isUIOptionsSame = prevUIOptionsKeys.every((key) => {\n    if (key === \"canvasActions\") {\n      const canvasOptionKeys = Object.keys(\n        prevUIOptions.canvasActions!,\n      ) as (keyof Partial<typeof DEFAULT_UI_OPTIONS.canvasActions>)[];\n      canvasOptionKeys.every((key) => {\n        if (\n          key === \"export\" &&\n          prevUIOptions?.canvasActions?.export &&\n          nextUIOptions?.canvasActions?.export\n        ) {\n          return (\n            prevUIOptions.canvasActions.export.saveFileToDisk ===\n            nextUIOptions.canvasActions.export.saveFileToDisk\n          );\n        }\n        return (\n          prevUIOptions?.canvasActions?.[key] ===\n          nextUIOptions?.canvasActions?.[key]\n        );\n      });\n    }\n    return true;\n  });\n\n  const prevKeys = Object.keys(prevProps) as (keyof typeof prev)[];\n  const nextKeys = Object.keys(nextProps) as (keyof typeof next)[];\n  return (\n    isUIOptionsSame &&\n    prevKeys.length === nextKeys.length &&\n    prevKeys.every((key) => prev[key] === next[key])\n  );\n};\n\nconst forwardedRefComp = forwardRef<\n  ExcalidrawAPIRefValue,\n  PublicExcalidrawProps\n>((props, ref) => <Excalidraw {...props} excalidrawRef={ref} />);\nexport default React.memo(forwardedRefComp, areEqual);\nexport {\n  getSceneVersion,\n  getElementMap,\n  isInvisiblySmallElement,\n} from \"../../element\";\nexport { defaultLang, languages } from \"../../i18n\";\nexport { restore, restoreAppState, restoreElements } from \"../../data/restore\";\nexport {\n  exportToCanvas,\n  exportToBlob,\n  exportToSvg,\n  serializeAsJSON,\n  loadLibraryFromBlob,\n  loadFromBlob,\n  getFreeDrawSvgPath,\n} from \"../../packages/utils\";\nexport { FONT_FAMILY } from \"../../constants\";\n","// time constants (ms)\nexport const SAVE_TO_LOCAL_STORAGE_TIMEOUT = 300;\nexport const INITIAL_SCENE_UPDATE_TIMEOUT = 5000;\nexport const SYNC_FULL_SCENE_INTERVAL_MS = 20000;\n\nexport const BROADCAST = {\n  SERVER_VOLATILE: \"server-volatile-broadcast\",\n  SERVER: \"server-broadcast\",\n};\n\nexport enum SCENE {\n  INIT = \"SCENE_INIT\",\n  UPDATE = \"SCENE_UPDATE\",\n}\n","import { serializeAsJSON } from \"../../data/json\";\nimport { restore } from \"../../data/restore\";\nimport { ImportedDataState } from \"../../data/types\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport { t } from \"../../i18n\";\nimport { AppState, UserIdleState } from \"../../types\";\n\nconst byteToHex = (byte: number): string => `0${byte.toString(16)}`.slice(-2);\n\nconst BACKEND_GET = process.env.REACT_APP_BACKEND_V1_GET_URL;\nconst BACKEND_V2_GET = process.env.REACT_APP_BACKEND_V2_GET_URL;\nconst BACKEND_V2_POST = process.env.REACT_APP_BACKEND_V2_POST_URL;\n\nconst generateRandomID = async () => {\n  const arr = new Uint8Array(10);\n  window.crypto.getRandomValues(arr);\n  return Array.from(arr, byteToHex).join(\"\");\n};\n\nexport const generateEncryptionKey = async () => {\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  return (await window.crypto.subtle.exportKey(\"jwk\", key)).k;\n};\n\nexport const SOCKET_SERVER = process.env.REACT_APP_SOCKET_SERVER_URL;\n\nexport type EncryptedData = {\n  data: ArrayBuffer;\n  iv: Uint8Array;\n};\n\nexport type SocketUpdateDataSource = {\n  SCENE_INIT: {\n    type: \"SCENE_INIT\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  SCENE_UPDATE: {\n    type: \"SCENE_UPDATE\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  MOUSE_LOCATION: {\n    type: \"MOUSE_LOCATION\";\n    payload: {\n      socketId: string;\n      pointer: { x: number; y: number };\n      button: \"down\" | \"up\";\n      selectedElementIds: AppState[\"selectedElementIds\"];\n      username: string;\n    };\n  };\n  IDLE_STATUS: {\n    type: \"IDLE_STATUS\";\n    payload: {\n      socketId: string;\n      userState: UserIdleState;\n      username: string;\n    };\n  };\n};\n\nexport type SocketUpdateDataIncoming =\n  | SocketUpdateDataSource[keyof SocketUpdateDataSource]\n  | {\n      type: \"INVALID_RESPONSE\";\n    };\n\nexport type SocketUpdateData = SocketUpdateDataSource[keyof SocketUpdateDataSource] & {\n  _brand: \"socketUpdateData\";\n};\n\nconst IV_LENGTH_BYTES = 12; // 96 bits\n\nexport const createIV = () => {\n  const arr = new Uint8Array(IV_LENGTH_BYTES);\n  return window.crypto.getRandomValues(arr);\n};\n\nexport const encryptAESGEM = async (\n  data: Uint8Array,\n  key: string,\n): Promise<EncryptedData> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  return {\n    data: await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    ),\n    iv,\n  };\n};\n\nexport const decryptAESGEM = async (\n  data: ArrayBuffer,\n  key: string,\n  iv: Uint8Array,\n): Promise<SocketUpdateDataIncoming> => {\n  try {\n    const importedKey = await getImportedKey(key, \"decrypt\");\n    const decrypted = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    );\n\n    const decodedData = new TextDecoder(\"utf-8\").decode(\n      new Uint8Array(decrypted) as any,\n    );\n    return JSON.parse(decodedData);\n  } catch (error) {\n    window.alert(t(\"alerts.decryptFailed\"));\n    console.error(error);\n  }\n  return {\n    type: \"INVALID_RESPONSE\",\n  };\n};\n\nexport const getCollaborationLinkData = (link: string) => {\n  const hash = new URL(link).hash;\n  const match = hash.match(/^#room=([a-zA-Z0-9_-]+),([a-zA-Z0-9_-]+)$/);\n  return match ? { roomId: match[1], roomKey: match[2] } : null;\n};\n\nexport const generateCollaborationLinkData = async () => {\n  const roomId = await generateRandomID();\n  const roomKey = await generateEncryptionKey();\n\n  if (!roomKey) {\n    throw new Error(\"Couldn't generate room key\");\n  }\n\n  return { roomId, roomKey };\n};\n\nexport const getCollaborationLink = (data: {\n  roomId: string;\n  roomKey: string;\n}) => {\n  return `${window.location.origin}${window.location.pathname}#room=${data.roomId},${data.roomKey}`;\n};\n\nexport const getImportedKey = (key: string, usage: KeyUsage) =>\n  window.crypto.subtle.importKey(\n    \"jwk\",\n    {\n      alg: \"A128GCM\",\n      ext: true,\n      k: key,\n      key_ops: [\"encrypt\", \"decrypt\"],\n      kty: \"oct\",\n    },\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    false, // extractable\n    [usage],\n  );\n\nexport const decryptImported = async (\n  iv: ArrayBuffer,\n  encrypted: ArrayBuffer,\n  privateKey: string,\n): Promise<ArrayBuffer> => {\n  const key = await getImportedKey(privateKey, \"decrypt\");\n  return window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    key,\n    encrypted,\n  );\n};\n\nconst importFromBackend = async (\n  id: string | null,\n  privateKey?: string | null,\n): Promise<ImportedDataState> => {\n  try {\n    const response = await fetch(\n      privateKey ? `${BACKEND_V2_GET}${id}` : `${BACKEND_GET}${id}.json`,\n    );\n\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return {};\n    }\n    let data: ImportedDataState;\n    if (privateKey) {\n      const buffer = await response.arrayBuffer();\n\n      let decrypted: ArrayBuffer;\n      try {\n        // Buffer should contain both the IV (fixed length) and encrypted data\n        const iv = buffer.slice(0, IV_LENGTH_BYTES);\n        const encrypted = buffer.slice(IV_LENGTH_BYTES, buffer.byteLength);\n        decrypted = await decryptImported(iv, encrypted, privateKey);\n      } catch (error) {\n        // Fixed IV (old format, backward compatibility)\n        const fixedIv = new Uint8Array(IV_LENGTH_BYTES);\n        decrypted = await decryptImported(fixedIv, buffer, privateKey);\n      }\n\n      // We need to convert the decrypted array buffer to a string\n      const string = new window.TextDecoder(\"utf-8\").decode(\n        new Uint8Array(decrypted) as any,\n      );\n      data = JSON.parse(string);\n    } else {\n      // Legacy format\n      data = await response.json();\n    }\n\n    return {\n      elements: data.elements || null,\n      appState: data.appState || null,\n    };\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n    return {};\n  }\n};\n\nexport const loadScene = async (\n  id: string | null,\n  privateKey: string | null,\n  // Supply local state even if importing from backend to ensure we restore\n  // localStorage user settings which we do not persist on server.\n  // Non-optional so we don't forget to pass it even if `undefined`.\n  localDataState: ImportedDataState | undefined | null,\n) => {\n  let data;\n  if (id != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = restore(\n      await importFromBackend(id, privateKey),\n      localDataState?.appState,\n      localDataState?.elements,\n    );\n  } else {\n    data = restore(localDataState || null, null, null);\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState,\n    commitToHistory: false,\n  };\n};\n\nexport const exportToBackend = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const json = serializeAsJSON(elements, appState);\n  const encoded = new TextEncoder().encode(json);\n\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n\n  const iv = createIV();\n  // We use symmetric encryption. AES-GCM is the recommended algorithm and\n  // includes checks that the ciphertext has not been modified by an attacker.\n  const encrypted = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    key,\n    encoded,\n  );\n\n  // Concatenate IV with encrypted data (IV does not have to be secret).\n  const payloadBlob = new Blob([iv.buffer, encrypted]);\n  const payload = await new Response(payloadBlob).arrayBuffer();\n\n  // We use jwk encoding to be able to extract just the base64 encoded key.\n  // We will hardcode the rest of the attributes when importing back the key.\n  const exportedKey = await window.crypto.subtle.exportKey(\"jwk\", key);\n\n  try {\n    const response = await fetch(BACKEND_V2_POST, {\n      method: \"POST\",\n      body: payload,\n    });\n    const json = await response.json();\n    if (json.id) {\n      const url = new URL(window.location.href);\n      // We need to store the key (and less importantly the id) as hash instead\n      // of queryParam in order to never send it to the server\n      url.hash = `json=${json.id},${exportedKey.k!}`;\n      const urlString = url.toString();\n      window.prompt(`🔒${t(\"alerts.uploadedSecurly\")}`, urlString);\n    } else if (json.error_class === \"RequestTooLargeError\") {\n      window.alert(t(\"alerts.couldNotCreateShareableLinkTooBig\"));\n    } else {\n      window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n    }\n  } catch (error) {\n    console.error(error);\n    window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n  }\n};\n","import { getImportedKey } from \"../data\";\nimport { createIV } from \"./index\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport { getSceneVersion } from \"../../element\";\nimport Portal from \"../collab/Portal\";\nimport { restoreElements } from \"../../data/restore\";\n\n// private\n// -----------------------------------------------------------------------------\n\nlet firebasePromise: Promise<\n  typeof import(\"firebase/app\").default\n> | null = null;\nlet firestorePromise: Promise<any> | null = null;\nlet firebseStoragePromise: Promise<any> | null = null;\n\nconst _loadFirebase = async () => {\n  const firebase = (\n    await import(/* webpackChunkName: \"firebase\" */ \"firebase/app\")\n  ).default;\n\n  const firebaseConfig = JSON.parse(process.env.REACT_APP_FIREBASE_CONFIG);\n  firebase.initializeApp(firebaseConfig);\n\n  return firebase;\n};\n\nconst _getFirebase = async (): Promise<\n  typeof import(\"firebase/app\").default\n> => {\n  if (!firebasePromise) {\n    firebasePromise = _loadFirebase();\n  }\n  return firebasePromise;\n};\n\n// -----------------------------------------------------------------------------\n\nconst loadFirestore = async () => {\n  const firebase = await _getFirebase();\n  if (!firestorePromise) {\n    firestorePromise = import(\n      /* webpackChunkName: \"firestore\" */ \"firebase/firestore\"\n    );\n    await firestorePromise;\n  }\n  return firebase;\n};\n\nexport const loadFirebaseStorage = async () => {\n  const firebase = await _getFirebase();\n  if (!firebseStoragePromise) {\n    firebseStoragePromise = import(\n      /* webpackChunkName: \"storage\" */ \"firebase/storage\"\n    );\n    await firebseStoragePromise;\n  }\n  return firebase;\n};\n\ninterface FirebaseStoredScene {\n  sceneVersion: number;\n  iv: firebase.default.firestore.Blob;\n  ciphertext: firebase.default.firestore.Blob;\n}\n\nconst encryptElements = async (\n  key: string,\n  elements: readonly ExcalidrawElement[],\n): Promise<{ ciphertext: ArrayBuffer; iv: Uint8Array }> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  const json = JSON.stringify(elements);\n  const encoded = new TextEncoder().encode(json);\n  const ciphertext = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    importedKey,\n    encoded,\n  );\n\n  return { ciphertext, iv };\n};\n\nconst decryptElements = async (\n  key: string,\n  iv: Uint8Array,\n  ciphertext: ArrayBuffer,\n): Promise<readonly ExcalidrawElement[]> => {\n  const importedKey = await getImportedKey(key, \"decrypt\");\n  const decrypted = await window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    importedKey,\n    ciphertext,\n  );\n\n  const decodedData = new TextDecoder(\"utf-8\").decode(\n    new Uint8Array(decrypted) as any,\n  );\n  return JSON.parse(decodedData);\n};\n\nconst firebaseSceneVersionCache = new WeakMap<SocketIOClient.Socket, number>();\n\nexport const isSavedToFirebase = (\n  portal: Portal,\n  elements: readonly ExcalidrawElement[],\n): boolean => {\n  if (portal.socket && portal.roomId && portal.roomKey) {\n    const sceneVersion = getSceneVersion(elements);\n    return firebaseSceneVersionCache.get(portal.socket) === sceneVersion;\n  }\n  // if no room exists, consider the room saved so that we don't unnecessarily\n  // prevent unload (there's nothing we could do at that point anyway)\n  return true;\n};\n\nexport const saveToFirebase = async (\n  portal: Portal,\n  elements: readonly ExcalidrawElement[],\n) => {\n  const { roomId, roomKey, socket } = portal;\n  if (\n    // if no room exists, consider the room saved because there's nothing we can\n    // do at this point\n    !roomId ||\n    !roomKey ||\n    !socket ||\n    isSavedToFirebase(portal, elements)\n  ) {\n    return true;\n  }\n\n  const firebase = await loadFirestore();\n  const sceneVersion = getSceneVersion(elements);\n  const { ciphertext, iv } = await encryptElements(roomKey, elements);\n\n  const nextDocData = {\n    sceneVersion,\n    ciphertext: firebase.firestore.Blob.fromUint8Array(\n      new Uint8Array(ciphertext),\n    ),\n    iv: firebase.firestore.Blob.fromUint8Array(iv),\n  } as FirebaseStoredScene;\n\n  const db = firebase.firestore();\n  const docRef = db.collection(\"scenes\").doc(roomId);\n  const didUpdate = await db.runTransaction(async (transaction) => {\n    const doc = await transaction.get(docRef);\n    if (!doc.exists) {\n      transaction.set(docRef, nextDocData);\n      return true;\n    }\n\n    const prevDocData = doc.data() as FirebaseStoredScene;\n    if (prevDocData.sceneVersion >= nextDocData.sceneVersion) {\n      return false;\n    }\n\n    transaction.update(docRef, nextDocData);\n    return true;\n  });\n\n  if (didUpdate) {\n    firebaseSceneVersionCache.set(socket, sceneVersion);\n  }\n\n  return didUpdate;\n};\n\nexport const loadFromFirebase = async (\n  roomId: string,\n  roomKey: string,\n  socket: SocketIOClient.Socket | null,\n): Promise<readonly ExcalidrawElement[] | null> => {\n  const firebase = await loadFirestore();\n  const db = firebase.firestore();\n\n  const docRef = db.collection(\"scenes\").doc(roomId);\n  const doc = await docRef.get();\n  if (!doc.exists) {\n    return null;\n  }\n  const storedScene = doc.data() as FirebaseStoredScene;\n  const ciphertext = storedScene.ciphertext.toUint8Array();\n  const iv = storedScene.iv.toUint8Array();\n\n  const elements = await decryptElements(roomKey, iv, ciphertext);\n\n  if (socket) {\n    firebaseSceneVersionCache.set(socket, getSceneVersion(elements));\n  }\n\n  return restoreElements(elements, null);\n};\n","import { ExcalidrawElement } from \"../../element/types\";\nimport { AppState } from \"../../types\";\nimport {\n  clearAppStateForLocalStorage,\n  getDefaultAppState,\n} from \"../../appState\";\nimport { clearElementsForLocalStorage } from \"../../element\";\nimport { STORAGE_KEYS as APP_STORAGE_KEYS } from \"../../constants\";\n\nexport const STORAGE_KEYS = {\n  LOCAL_STORAGE_ELEMENTS: \"excalidraw\",\n  LOCAL_STORAGE_APP_STATE: \"excalidraw-state\",\n  LOCAL_STORAGE_COLLAB: \"excalidraw-collab\",\n  LOCAL_STORAGE_KEY_COLLAB_FORCE_FLAG: \"collabLinkForceLoadFlag\",\n};\n\nexport const saveUsernameToLocalStorage = (username: string) => {\n  try {\n    localStorage.setItem(\n      STORAGE_KEYS.LOCAL_STORAGE_COLLAB,\n      JSON.stringify({ username }),\n    );\n  } catch (error) {\n    // Unable to access window.localStorage\n    console.error(error);\n  }\n};\n\nexport const importUsernameFromLocalStorage = (): string | null => {\n  try {\n    const data = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_COLLAB);\n    if (data) {\n      return JSON.parse(data).username;\n    }\n  } catch (error) {\n    // Unable to access localStorage\n    console.error(error);\n  }\n\n  return null;\n};\n\nexport const saveToLocalStorage = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  try {\n    localStorage.setItem(\n      STORAGE_KEYS.LOCAL_STORAGE_ELEMENTS,\n      JSON.stringify(clearElementsForLocalStorage(elements)),\n    );\n    localStorage.setItem(\n      STORAGE_KEYS.LOCAL_STORAGE_APP_STATE,\n      JSON.stringify(clearAppStateForLocalStorage(appState)),\n    );\n  } catch (error) {\n    // Unable to access window.localStorage\n    console.error(error);\n  }\n};\n\nexport const importFromLocalStorage = () => {\n  let savedElements = null;\n  let savedState = null;\n\n  try {\n    savedElements = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_ELEMENTS);\n    savedState = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_APP_STATE);\n  } catch (error) {\n    // Unable to access localStorage\n    console.error(error);\n  }\n\n  let elements: ExcalidrawElement[] = [];\n  if (savedElements) {\n    try {\n      elements = clearElementsForLocalStorage(JSON.parse(savedElements));\n    } catch (error) {\n      console.error(error);\n      // Do nothing because elements array is already empty\n    }\n  }\n\n  let appState = null;\n  if (savedState) {\n    try {\n      appState = {\n        ...getDefaultAppState(),\n        ...clearAppStateForLocalStorage(\n          JSON.parse(savedState) as Partial<AppState>,\n        ),\n      };\n    } catch (error) {\n      console.error(error);\n      // Do nothing because appState is already null\n    }\n  }\n  return { elements, appState };\n};\n\nexport const getElementsStorageSize = () => {\n  try {\n    const elements = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_ELEMENTS);\n    const elementsSize = elements?.length || 0;\n    return elementsSize;\n  } catch (error) {\n    console.error(error);\n    return 0;\n  }\n};\n\nexport const getTotalStorageSize = () => {\n  try {\n    const appState = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_APP_STATE);\n    const collab = localStorage.getItem(STORAGE_KEYS.LOCAL_STORAGE_COLLAB);\n    const library = localStorage.getItem(\n      APP_STORAGE_KEYS.LOCAL_STORAGE_LIBRARY,\n    );\n\n    const appStateSize = appState?.length || 0;\n    const collabSize = collab?.length || 0;\n    const librarySize = library?.length || 0;\n\n    return appStateSize + collabSize + librarySize + getElementsStorageSize();\n  } catch (error) {\n    console.error(error);\n    return 0;\n  }\n};\n","import {\n  encryptAESGEM,\n  SocketUpdateData,\n  SocketUpdateDataSource,\n} from \"../data\";\n\nimport CollabWrapper from \"./CollabWrapper\";\n\nimport { ExcalidrawElement } from \"../../element/types\";\nimport { BROADCAST, SCENE } from \"../app_constants\";\nimport { UserIdleState } from \"../../types\";\nimport { trackEvent } from \"../../analytics\";\n\nclass Portal {\n  collab: CollabWrapper;\n  socket: SocketIOClient.Socket | null = null;\n  socketInitialized: boolean = false; // we don't want the socket to emit any updates until it is fully initialized\n  roomId: string | null = null;\n  roomKey: string | null = null;\n  broadcastedElementVersions: Map<string, number> = new Map();\n\n  constructor(collab: CollabWrapper) {\n    this.collab = collab;\n  }\n\n  open(socket: SocketIOClient.Socket, id: string, key: string) {\n    this.socket = socket;\n    this.roomId = id;\n    this.roomKey = key;\n\n    // Initialize socket listeners\n    this.socket.on(\"init-room\", () => {\n      if (this.socket) {\n        this.socket.emit(\"join-room\", this.roomId);\n        trackEvent(\"share\", \"room joined\");\n      }\n    });\n    this.socket.on(\"new-user\", async (_socketId: string) => {\n      this.broadcastScene(\n        SCENE.INIT,\n        this.collab.getSyncableElements(\n          this.collab.getSceneElementsIncludingDeleted(),\n        ),\n        /* syncAll */ true,\n      );\n    });\n    this.socket.on(\"room-user-change\", (clients: string[]) => {\n      this.collab.setCollaborators(clients);\n    });\n  }\n\n  close() {\n    if (!this.socket) {\n      return;\n    }\n    this.socket.close();\n    this.socket = null;\n    this.roomId = null;\n    this.roomKey = null;\n    this.socketInitialized = false;\n    this.broadcastedElementVersions = new Map();\n  }\n\n  isOpen() {\n    return !!(\n      this.socketInitialized &&\n      this.socket &&\n      this.roomId &&\n      this.roomKey\n    );\n  }\n\n  async _broadcastSocketData(\n    data: SocketUpdateData,\n    volatile: boolean = false,\n  ) {\n    if (this.isOpen()) {\n      const json = JSON.stringify(data);\n      const encoded = new TextEncoder().encode(json);\n      const encrypted = await encryptAESGEM(encoded, this.roomKey!);\n      this.socket!.emit(\n        volatile ? BROADCAST.SERVER_VOLATILE : BROADCAST.SERVER,\n        this.roomId,\n        encrypted.data,\n        encrypted.iv,\n      );\n    }\n  }\n\n  broadcastScene = async (\n    sceneType: SCENE.INIT | SCENE.UPDATE,\n    syncableElements: ExcalidrawElement[],\n    syncAll: boolean,\n  ) => {\n    if (sceneType === SCENE.INIT && !syncAll) {\n      throw new Error(\"syncAll must be true when sending SCENE.INIT\");\n    }\n\n    if (!syncAll) {\n      // sync out only the elements we think we need to to save bandwidth.\n      // periodically we'll resync the whole thing to make sure no one diverges\n      // due to a dropped message (server goes down etc).\n      syncableElements = syncableElements.filter(\n        (syncableElement) =>\n          !this.broadcastedElementVersions.has(syncableElement.id) ||\n          syncableElement.version >\n            this.broadcastedElementVersions.get(syncableElement.id)!,\n      );\n    }\n\n    const data: SocketUpdateDataSource[typeof sceneType] = {\n      type: sceneType,\n      payload: {\n        elements: syncableElements,\n      },\n    };\n\n    for (const syncableElement of syncableElements) {\n      this.broadcastedElementVersions.set(\n        syncableElement.id,\n        syncableElement.version,\n      );\n    }\n\n    const broadcastPromise = this._broadcastSocketData(\n      data as SocketUpdateData,\n    );\n\n    if (syncAll && this.collab.isCollaborating) {\n      await Promise.all([\n        broadcastPromise,\n        this.collab.saveCollabRoomToFirebase(syncableElements),\n      ]);\n    } else {\n      await broadcastPromise;\n    }\n  };\n\n  broadcastIdleChange = (userState: UserIdleState) => {\n    if (this.socket?.id) {\n      const data: SocketUpdateDataSource[\"IDLE_STATUS\"] = {\n        type: \"IDLE_STATUS\",\n        payload: {\n          socketId: this.socket.id,\n          userState,\n          username: this.collab.state.username,\n        },\n      };\n      return this._broadcastSocketData(\n        data as SocketUpdateData,\n        true, // volatile\n      );\n    }\n  };\n\n  broadcastMouseLocation = (payload: {\n    pointer: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"pointer\"];\n    button: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"button\"];\n  }) => {\n    if (this.socket?.id) {\n      const data: SocketUpdateDataSource[\"MOUSE_LOCATION\"] = {\n        type: \"MOUSE_LOCATION\",\n        payload: {\n          socketId: this.socket.id,\n          pointer: payload.pointer,\n          button: payload.button || \"up\",\n          selectedElementIds: this.collab.excalidrawAPI.getAppState()\n            .selectedElementIds,\n          username: this.collab.state.username,\n        },\n      };\n      return this._broadcastSocketData(\n        data as SocketUpdateData,\n        true, // volatile\n      );\n    }\n  };\n}\n\nexport default Portal;\n","import React, { useRef } from \"react\";\nimport { copyTextToSystemClipboard } from \"../../clipboard\";\nimport { Dialog } from \"../../components/Dialog\";\nimport {\n  clipboard,\n  start,\n  stop,\n  share,\n  shareIOS,\n  shareWindows,\n} from \"../../components/icons\";\nimport { ToolButton } from \"../../components/ToolButton\";\nimport { t } from \"../../i18n\";\nimport \"./RoomDialog.scss\";\nimport Stack from \"../../components/Stack\";\nimport { AppState } from \"../../types\";\n\nconst getShareIcon = () => {\n  const navigator = window.navigator as any;\n  const isAppleBrowser = /Apple/.test(navigator.vendor);\n  const isWindowsBrowser = navigator.appVersion.indexOf(\"Win\") !== -1;\n\n  if (isAppleBrowser) {\n    return shareIOS;\n  } else if (isWindowsBrowser) {\n    return shareWindows;\n  }\n\n  return share;\n};\n\nconst RoomDialog = ({\n  handleClose,\n  activeRoomLink,\n  username,\n  onUsernameChange,\n  onRoomCreate,\n  onRoomDestroy,\n  setErrorMessage,\n  theme,\n}: {\n  handleClose: () => void;\n  activeRoomLink: string;\n  username: string;\n  onUsernameChange: (username: string) => void;\n  onRoomCreate: () => void;\n  onRoomDestroy: () => void;\n  setErrorMessage: (message: string) => void;\n  theme: AppState[\"theme\"];\n}) => {\n  const roomLinkInput = useRef<HTMLInputElement>(null);\n\n  const copyRoomLink = async () => {\n    try {\n      await copyTextToSystemClipboard(activeRoomLink);\n    } catch (error) {\n      setErrorMessage(error.message);\n    }\n    if (roomLinkInput.current) {\n      roomLinkInput.current.select();\n    }\n  };\n\n  const shareRoomLink = async () => {\n    try {\n      await navigator.share({\n        title: t(\"roomDialog.shareTitle\"),\n        text: t(\"roomDialog.shareTitle\"),\n        url: activeRoomLink,\n      });\n    } catch (error) {\n      // Just ignore.\n    }\n  };\n\n  const selectInput = (event: React.MouseEvent<HTMLInputElement>) => {\n    if (event.target !== document.activeElement) {\n      event.preventDefault();\n      (event.target as HTMLInputElement).select();\n    }\n  };\n\n  const renderRoomDialog = () => {\n    return (\n      <div className=\"RoomDialog-modal\">\n        {!activeRoomLink && (\n          <>\n            <p>{t(\"roomDialog.desc_intro\")}</p>\n            <p>{`🔒 ${t(\"roomDialog.desc_privacy\")}`}</p>\n            <div className=\"RoomDialog-sessionStartButtonContainer\">\n              <ToolButton\n                className=\"RoomDialog-startSession\"\n                type=\"button\"\n                icon={start}\n                title={t(\"roomDialog.button_startSession\")}\n                aria-label={t(\"roomDialog.button_startSession\")}\n                showAriaLabel={true}\n                onClick={onRoomCreate}\n              />\n            </div>\n          </>\n        )}\n        {activeRoomLink && (\n          <>\n            <p>{t(\"roomDialog.desc_inProgressIntro\")}</p>\n            <p>{t(\"roomDialog.desc_shareLink\")}</p>\n            <div className=\"RoomDialog-linkContainer\">\n              <Stack.Row gap={2}>\n                {\"share\" in navigator ? (\n                  <ToolButton\n                    type=\"button\"\n                    icon={getShareIcon()}\n                    title={t(\"labels.share\")}\n                    aria-label={t(\"labels.share\")}\n                    onClick={shareRoomLink}\n                  />\n                ) : null}\n                <ToolButton\n                  type=\"button\"\n                  icon={clipboard}\n                  title={t(\"labels.copy\")}\n                  aria-label={t(\"labels.copy\")}\n                  onClick={copyRoomLink}\n                />\n              </Stack.Row>\n              <input\n                value={activeRoomLink}\n                readOnly={true}\n                className=\"RoomDialog-link\"\n                ref={roomLinkInput}\n                onPointerDown={selectInput}\n              />\n            </div>\n            <div className=\"RoomDialog-usernameContainer\">\n              <label className=\"RoomDialog-usernameLabel\" htmlFor=\"username\">\n                {t(\"labels.yourName\")}\n              </label>\n              <input\n                id=\"username\"\n                value={username || \"\"}\n                className=\"RoomDialog-username TextInput\"\n                onChange={(event) => onUsernameChange(event.target.value)}\n                onKeyPress={(event) => event.key === \"Enter\" && handleClose()}\n              />\n            </div>\n            <p>\n              <span role=\"img\" aria-hidden=\"true\" className=\"RoomDialog-emoji\">\n                {\"🔒\"}\n              </span>{\" \"}\n              {t(\"roomDialog.desc_privacy\")}\n            </p>\n            <p>{t(\"roomDialog.desc_exitSession\")}</p>\n            <div className=\"RoomDialog-sessionStartButtonContainer\">\n              <ToolButton\n                className=\"RoomDialog-stopSession\"\n                type=\"button\"\n                icon={stop}\n                title={t(\"roomDialog.button_stopSession\")}\n                aria-label={t(\"roomDialog.button_stopSession\")}\n                showAriaLabel={true}\n                onClick={onRoomDestroy}\n              />\n            </div>\n          </>\n        )}\n      </div>\n    );\n  };\n  return (\n    <Dialog\n      small\n      onCloseRequest={handleClose}\n      title={t(\"labels.liveCollaboration\")}\n      theme={theme}\n    >\n      {renderRoomDialog()}\n    </Dialog>\n  );\n};\n\nexport default RoomDialog;\n","import React from \"react\";\n\nexport const createInverseContext = <T extends unknown = null>(\n  initialValue: T,\n) => {\n  const Context = React.createContext(initialValue) as React.Context<T> & {\n    _updateProviderValue?: (value: T) => void;\n  };\n\n  class InverseConsumer extends React.Component {\n    state = { value: initialValue };\n    constructor(props: any) {\n      super(props);\n      Context._updateProviderValue = (value: T) => this.setState({ value });\n    }\n    render() {\n      return (\n        <Context.Provider value={this.state.value}>\n          {this.props.children}\n        </Context.Provider>\n      );\n    }\n  }\n\n  class InverseProvider extends React.Component<{ value: T }> {\n    componentDidMount() {\n      Context._updateProviderValue?.(this.props.value);\n    }\n    componentDidUpdate() {\n      Context._updateProviderValue?.(this.props.value);\n    }\n    render() {\n      return <Context.Consumer>{() => this.props.children}</Context.Consumer>;\n    }\n  }\n\n  return {\n    Context,\n    Consumer: InverseConsumer,\n    Provider: InverseProvider,\n  };\n};\n","import throttle from \"lodash.throttle\";\nimport React, { PureComponent } from \"react\";\nimport { ExcalidrawImperativeAPI } from \"../../types\";\nimport { ErrorDialog } from \"../../components/ErrorDialog\";\nimport { APP_NAME, ENV, EVENT } from \"../../constants\";\nimport { ImportedDataState } from \"../../data/types\";\nimport { ExcalidrawElement } from \"../../element/types\";\nimport {\n  getElementMap,\n  getSceneVersion,\n} from \"../../packages/excalidraw/index\";\nimport { Collaborator, Gesture } from \"../../types\";\nimport { resolvablePromise, withBatchedUpdates } from \"../../utils\";\nimport {\n  INITIAL_SCENE_UPDATE_TIMEOUT,\n  SCENE,\n  SYNC_FULL_SCENE_INTERVAL_MS,\n} from \"../app_constants\";\nimport {\n  decryptAESGEM,\n  generateCollaborationLinkData,\n  getCollaborationLink,\n  SocketUpdateDataSource,\n  SOCKET_SERVER,\n} from \"../data\";\nimport {\n  isSavedToFirebase,\n  loadFromFirebase,\n  saveToFirebase,\n} from \"../data/firebase\";\nimport {\n  importUsernameFromLocalStorage,\n  saveUsernameToLocalStorage,\n  STORAGE_KEYS,\n} from \"../data/localStorage\";\nimport Portal from \"./Portal\";\nimport RoomDialog from \"./RoomDialog\";\nimport { createInverseContext } from \"../../createInverseContext\";\nimport { t } from \"../../i18n\";\nimport { UserIdleState } from \"../../types\";\nimport { IDLE_THRESHOLD, ACTIVE_THRESHOLD } from \"../../constants\";\nimport { trackEvent } from \"../../analytics\";\nimport { isInvisiblySmallElement } from \"../../element\";\n\ninterface CollabState {\n  modalIsShown: boolean;\n  errorMessage: string;\n  username: string;\n  userState: UserIdleState;\n  activeRoomLink: string;\n}\n\ntype CollabInstance = InstanceType<typeof CollabWrapper>;\n\nexport interface CollabAPI {\n  /** function so that we can access the latest value from stale callbacks */\n  isCollaborating: () => boolean;\n  username: CollabState[\"username\"];\n  userState: CollabState[\"userState\"];\n  onPointerUpdate: CollabInstance[\"onPointerUpdate\"];\n  initializeSocketClient: CollabInstance[\"initializeSocketClient\"];\n  onCollabButtonClick: CollabInstance[\"onCollabButtonClick\"];\n  broadcastElements: CollabInstance[\"broadcastElements\"];\n}\n\ntype ReconciledElements = readonly ExcalidrawElement[] & {\n  _brand: \"reconciledElements\";\n};\n\ninterface Props {\n  excalidrawAPI: ExcalidrawImperativeAPI;\n}\n\nconst {\n  Context: CollabContext,\n  Consumer: CollabContextConsumer,\n  Provider: CollabContextProvider,\n} = createInverseContext<{ api: CollabAPI | null }>({ api: null });\n\nexport { CollabContext, CollabContextConsumer };\n\nclass CollabWrapper extends PureComponent<Props, CollabState> {\n  portal: Portal;\n  excalidrawAPI: Props[\"excalidrawAPI\"];\n  isCollaborating: boolean = false;\n  activeIntervalId: number | null;\n  idleTimeoutId: number | null;\n\n  private socketInitializationTimer?: NodeJS.Timeout;\n  private lastBroadcastedOrReceivedSceneVersion: number = -1;\n  private collaborators = new Map<string, Collaborator>();\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n      modalIsShown: false,\n      errorMessage: \"\",\n      username: importUsernameFromLocalStorage() || \"\",\n      userState: UserIdleState.ACTIVE,\n      activeRoomLink: \"\",\n    };\n    this.portal = new Portal(this);\n    this.excalidrawAPI = props.excalidrawAPI;\n    this.activeIntervalId = null;\n    this.idleTimeoutId = null;\n  }\n\n  componentDidMount() {\n    window.addEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.addEventListener(EVENT.UNLOAD, this.onUnload);\n\n    if (\n      process.env.NODE_ENV === ENV.TEST ||\n      process.env.NODE_ENV === ENV.DEVELOPMENT\n    ) {\n      window.collab = window.collab || ({} as Window[\"collab\"]);\n      Object.defineProperties(window, {\n        collab: {\n          configurable: true,\n          value: this,\n        },\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(EVENT.BEFORE_UNLOAD, this.beforeUnload);\n    window.removeEventListener(EVENT.UNLOAD, this.onUnload);\n    window.removeEventListener(EVENT.POINTER_MOVE, this.onPointerMove);\n    window.removeEventListener(\n      EVENT.VISIBILITY_CHANGE,\n      this.onVisibilityChange,\n    );\n    if (this.activeIntervalId) {\n      window.clearInterval(this.activeIntervalId);\n      this.activeIntervalId = null;\n    }\n    if (this.idleTimeoutId) {\n      window.clearTimeout(this.idleTimeoutId);\n      this.idleTimeoutId = null;\n    }\n  }\n\n  private onUnload = () => {\n    this.destroySocketClient({ isUnload: true });\n  };\n\n  private beforeUnload = withBatchedUpdates((event: BeforeUnloadEvent) => {\n    const syncableElements = this.getSyncableElements(\n      this.getSceneElementsIncludingDeleted(),\n    );\n\n    if (\n      this.isCollaborating &&\n      !isSavedToFirebase(this.portal, syncableElements)\n    ) {\n      // this won't run in time if user decides to leave the site, but\n      //  the purpose is to run in immediately after user decides to stay\n      this.saveCollabRoomToFirebase(syncableElements);\n\n      event.preventDefault();\n      // NOTE: modern browsers no longer allow showing a custom message here\n      event.returnValue = \"\";\n    }\n\n    if (this.isCollaborating || this.portal.roomId) {\n      try {\n        localStorage?.setItem(\n          STORAGE_KEYS.LOCAL_STORAGE_KEY_COLLAB_FORCE_FLAG,\n          JSON.stringify({\n            timestamp: Date.now(),\n            room: this.portal.roomId,\n          }),\n        );\n      } catch {}\n    }\n  });\n\n  saveCollabRoomToFirebase = async (\n    syncableElements: ExcalidrawElement[] = this.getSyncableElements(\n      this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n    ),\n  ) => {\n    try {\n      await saveToFirebase(this.portal, syncableElements);\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  openPortal = async () => {\n    trackEvent(\"share\", \"room creation\");\n    return this.initializeSocketClient(null);\n  };\n\n  closePortal = () => {\n    this.saveCollabRoomToFirebase();\n    if (window.confirm(t(\"alerts.collabStopOverridePrompt\"))) {\n      window.history.pushState({}, APP_NAME, window.location.origin);\n      this.destroySocketClient();\n      trackEvent(\"share\", \"room closed\");\n    }\n  };\n\n  private destroySocketClient = (opts?: { isUnload: boolean }) => {\n    if (!opts?.isUnload) {\n      this.collaborators = new Map();\n      this.excalidrawAPI.updateScene({\n        collaborators: this.collaborators,\n      });\n      this.setState({\n        activeRoomLink: \"\",\n      });\n      this.isCollaborating = false;\n    }\n    this.portal.close();\n  };\n\n  private initializeSocketClient = async (\n    existingRoomLinkData: null | { roomId: string; roomKey: string },\n  ): Promise<ImportedDataState | null> => {\n    if (this.portal.socket) {\n      return null;\n    }\n\n    let roomId;\n    let roomKey;\n\n    if (existingRoomLinkData) {\n      ({ roomId, roomKey } = existingRoomLinkData);\n    } else {\n      ({ roomId, roomKey } = await generateCollaborationLinkData());\n      window.history.pushState(\n        {},\n        APP_NAME,\n        getCollaborationLink({ roomId, roomKey }),\n      );\n    }\n\n    const scenePromise = resolvablePromise<ImportedDataState | null>();\n\n    this.isCollaborating = true;\n\n    const { default: socketIOClient }: any = await import(\n      /* webpackChunkName: \"socketIoClient\" */ \"socket.io-client\"\n    );\n\n    this.portal.open(socketIOClient(SOCKET_SERVER), roomId, roomKey);\n\n    if (existingRoomLinkData) {\n      this.excalidrawAPI.resetScene();\n\n      try {\n        const elements = await loadFromFirebase(\n          roomId,\n          roomKey,\n          this.portal.socket,\n        );\n        if (elements) {\n          scenePromise.resolve({\n            elements,\n            scrollToContent: true,\n          });\n        }\n      } catch (error) {\n        // log the error and move on. other peers will sync us the scene.\n        console.error(error);\n      }\n    } else {\n      const elements = this.excalidrawAPI.getSceneElements();\n      // remove deleted elements from elements array & history to ensure we don't\n      // expose potentially sensitive user data in case user manually deletes\n      // existing elements (or clears scene), which would otherwise be persisted\n      // to database even if deleted before creating the room.\n      this.excalidrawAPI.history.clear();\n      this.excalidrawAPI.updateScene({\n        elements,\n        commitToHistory: true,\n      });\n    }\n\n    // fallback in case you're not alone in the room but still don't receive\n    // initial SCENE_UPDATE message\n    this.socketInitializationTimer = setTimeout(() => {\n      this.initializeSocket();\n      scenePromise.resolve(null);\n    }, INITIAL_SCENE_UPDATE_TIMEOUT);\n\n    // All socket listeners are moving to Portal\n    this.portal.socket!.on(\n      \"client-broadcast\",\n      async (encryptedData: ArrayBuffer, iv: Uint8Array) => {\n        if (!this.portal.roomKey) {\n          return;\n        }\n        const decryptedData = await decryptAESGEM(\n          encryptedData,\n          this.portal.roomKey,\n          iv,\n        );\n\n        switch (decryptedData.type) {\n          case \"INVALID_RESPONSE\":\n            return;\n          case SCENE.INIT: {\n            if (!this.portal.socketInitialized) {\n              this.initializeSocket();\n              const remoteElements = decryptedData.payload.elements;\n              const reconciledElements = this.reconcileElements(remoteElements);\n              this.handleRemoteSceneUpdate(reconciledElements, {\n                init: true,\n              });\n              // noop if already resolved via init from firebase\n              scenePromise.resolve({\n                elements: reconciledElements,\n                scrollToContent: true,\n              });\n            }\n            break;\n          }\n          case SCENE.UPDATE:\n            this.handleRemoteSceneUpdate(\n              this.reconcileElements(decryptedData.payload.elements),\n            );\n            break;\n          case \"MOUSE_LOCATION\": {\n            const {\n              pointer,\n              button,\n              username,\n              selectedElementIds,\n            } = decryptedData.payload;\n            const socketId: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"socketId\"] =\n              decryptedData.payload.socketId ||\n              // @ts-ignore legacy, see #2094 (#2097)\n              decryptedData.payload.socketID;\n\n            const collaborators = new Map(this.collaborators);\n            const user = collaborators.get(socketId) || {}!;\n            user.pointer = pointer;\n            user.button = button;\n            user.selectedElementIds = selectedElementIds;\n            user.username = username;\n            collaborators.set(socketId, user);\n            this.excalidrawAPI.updateScene({\n              collaborators,\n            });\n            break;\n          }\n          case \"IDLE_STATUS\": {\n            const { userState, socketId, username } = decryptedData.payload;\n            const collaborators = new Map(this.collaborators);\n            const user = collaborators.get(socketId) || {}!;\n            user.userState = userState;\n            user.username = username;\n            this.excalidrawAPI.updateScene({\n              collaborators,\n            });\n            break;\n          }\n        }\n      },\n    );\n\n    this.portal.socket!.on(\"first-in-room\", () => {\n      if (this.portal.socket) {\n        this.portal.socket.off(\"first-in-room\");\n      }\n      this.initializeSocket();\n      scenePromise.resolve(null);\n    });\n\n    this.initializeIdleDetector();\n\n    this.setState({\n      activeRoomLink: window.location.href,\n    });\n\n    return scenePromise;\n  };\n\n  private initializeSocket = () => {\n    this.portal.socketInitialized = true;\n    clearTimeout(this.socketInitializationTimer!);\n  };\n\n  private reconcileElements = (\n    elements: readonly ExcalidrawElement[],\n  ): ReconciledElements => {\n    const currentElements = this.getSceneElementsIncludingDeleted();\n    // create a map of ids so we don't have to iterate\n    // over the array more than once.\n    const localElementMap = getElementMap(currentElements);\n\n    const appState = this.excalidrawAPI.getAppState();\n\n    // Reconcile\n    const newElements: readonly ExcalidrawElement[] = elements\n      .reduce((elements, element) => {\n        // if the remote element references one that's currently\n        // edited on local, skip it (it'll be added in the next step)\n        if (\n          element.id === appState.editingElement?.id ||\n          element.id === appState.resizingElement?.id ||\n          element.id === appState.draggingElement?.id\n        ) {\n          return elements;\n        }\n\n        if (\n          localElementMap.hasOwnProperty(element.id) &&\n          localElementMap[element.id].version > element.version\n        ) {\n          elements.push(localElementMap[element.id]);\n          delete localElementMap[element.id];\n        } else if (\n          localElementMap.hasOwnProperty(element.id) &&\n          localElementMap[element.id].version === element.version &&\n          localElementMap[element.id].versionNonce !== element.versionNonce\n        ) {\n          // resolve conflicting edits deterministically by taking the one with the lowest versionNonce\n          if (localElementMap[element.id].versionNonce < element.versionNonce) {\n            elements.push(localElementMap[element.id]);\n          } else {\n            // it should be highly unlikely that the two versionNonces are the same. if we are\n            // really worried about this, we can replace the versionNonce with the socket id.\n            elements.push(element);\n          }\n          delete localElementMap[element.id];\n        } else {\n          elements.push(element);\n          delete localElementMap[element.id];\n        }\n\n        return elements;\n      }, [] as Mutable<typeof elements>)\n      // add local elements that weren't deleted or on remote\n      .concat(...Object.values(localElementMap));\n\n    // Avoid broadcasting to the rest of the collaborators the scene\n    // we just received!\n    // Note: this needs to be set before updating the scene as it\n    // synchronously calls render.\n    this.setLastBroadcastedOrReceivedSceneVersion(getSceneVersion(newElements));\n\n    return newElements as ReconciledElements;\n  };\n\n  private handleRemoteSceneUpdate = (\n    elements: ReconciledElements,\n    { init = false }: { init?: boolean } = {},\n  ) => {\n    this.excalidrawAPI.updateScene({\n      elements,\n      commitToHistory: !!init,\n    });\n\n    // We haven't yet implemented multiplayer undo functionality, so we clear the undo stack\n    // when we receive any messages from another peer. This UX can be pretty rough -- if you\n    // undo, a user makes a change, and then try to redo, your element(s) will be lost. However,\n    // right now we think this is the right tradeoff.\n    this.excalidrawAPI.history.clear();\n  };\n\n  private onPointerMove = () => {\n    if (this.idleTimeoutId) {\n      window.clearTimeout(this.idleTimeoutId);\n      this.idleTimeoutId = null;\n    }\n    this.idleTimeoutId = window.setTimeout(this.reportIdle, IDLE_THRESHOLD);\n    if (!this.activeIntervalId) {\n      this.activeIntervalId = window.setInterval(\n        this.reportActive,\n        ACTIVE_THRESHOLD,\n      );\n    }\n  };\n\n  private onVisibilityChange = () => {\n    if (document.hidden) {\n      if (this.idleTimeoutId) {\n        window.clearTimeout(this.idleTimeoutId);\n        this.idleTimeoutId = null;\n      }\n      if (this.activeIntervalId) {\n        window.clearInterval(this.activeIntervalId);\n        this.activeIntervalId = null;\n      }\n      this.onIdleStateChange(UserIdleState.AWAY);\n    } else {\n      this.idleTimeoutId = window.setTimeout(this.reportIdle, IDLE_THRESHOLD);\n      this.activeIntervalId = window.setInterval(\n        this.reportActive,\n        ACTIVE_THRESHOLD,\n      );\n      this.onIdleStateChange(UserIdleState.ACTIVE);\n    }\n  };\n\n  private reportIdle = () => {\n    this.onIdleStateChange(UserIdleState.IDLE);\n    if (this.activeIntervalId) {\n      window.clearInterval(this.activeIntervalId);\n      this.activeIntervalId = null;\n    }\n  };\n\n  private reportActive = () => {\n    this.onIdleStateChange(UserIdleState.ACTIVE);\n  };\n\n  private initializeIdleDetector = () => {\n    document.addEventListener(EVENT.POINTER_MOVE, this.onPointerMove);\n    document.addEventListener(EVENT.VISIBILITY_CHANGE, this.onVisibilityChange);\n  };\n\n  setCollaborators(sockets: string[]) {\n    this.setState((state) => {\n      const collaborators: InstanceType<\n        typeof CollabWrapper\n      >[\"collaborators\"] = new Map();\n      for (const socketId of sockets) {\n        if (this.collaborators.has(socketId)) {\n          collaborators.set(socketId, this.collaborators.get(socketId)!);\n        } else {\n          collaborators.set(socketId, {});\n        }\n      }\n      this.collaborators = collaborators;\n      this.excalidrawAPI.updateScene({ collaborators });\n    });\n  }\n\n  public setLastBroadcastedOrReceivedSceneVersion = (version: number) => {\n    this.lastBroadcastedOrReceivedSceneVersion = version;\n  };\n\n  public getLastBroadcastedOrReceivedSceneVersion = () => {\n    return this.lastBroadcastedOrReceivedSceneVersion;\n  };\n\n  public getSceneElementsIncludingDeleted = () => {\n    return this.excalidrawAPI.getSceneElementsIncludingDeleted();\n  };\n\n  onPointerUpdate = (payload: {\n    pointer: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"pointer\"];\n    button: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"button\"];\n    pointersMap: Gesture[\"pointers\"];\n  }) => {\n    payload.pointersMap.size < 2 &&\n      this.portal.socket &&\n      this.portal.broadcastMouseLocation(payload);\n  };\n\n  onIdleStateChange = (userState: UserIdleState) => {\n    this.setState({ userState });\n    this.portal.broadcastIdleChange(userState);\n  };\n\n  broadcastElements = (elements: readonly ExcalidrawElement[]) => {\n    if (\n      getSceneVersion(elements) >\n      this.getLastBroadcastedOrReceivedSceneVersion()\n    ) {\n      this.portal.broadcastScene(\n        SCENE.UPDATE,\n        this.getSyncableElements(elements),\n        false,\n      );\n      this.lastBroadcastedOrReceivedSceneVersion = getSceneVersion(elements);\n      this.queueBroadcastAllElements();\n    }\n  };\n\n  queueBroadcastAllElements = throttle(() => {\n    this.portal.broadcastScene(\n      SCENE.UPDATE,\n      this.getSyncableElements(\n        this.excalidrawAPI.getSceneElementsIncludingDeleted(),\n      ),\n      true,\n    );\n    const currentVersion = this.getLastBroadcastedOrReceivedSceneVersion();\n    const newVersion = Math.max(\n      currentVersion,\n      getSceneVersion(this.getSceneElementsIncludingDeleted()),\n    );\n    this.setLastBroadcastedOrReceivedSceneVersion(newVersion);\n  }, SYNC_FULL_SCENE_INTERVAL_MS);\n\n  handleClose = () => {\n    this.setState({ modalIsShown: false });\n  };\n\n  onUsernameChange = (username: string) => {\n    this.setState({ username });\n    saveUsernameToLocalStorage(username);\n  };\n\n  onCollabButtonClick = () => {\n    this.setState({\n      modalIsShown: true,\n    });\n  };\n\n  getSyncableElements = (elements: readonly ExcalidrawElement[]) =>\n    elements.filter((el) => el.isDeleted || !isInvisiblySmallElement(el));\n\n  /** PRIVATE. Use `this.getContextValue()` instead. */\n  private contextValue: CollabAPI | null = null;\n\n  /** Getter of context value. Returned object is stable. */\n  getContextValue = (): CollabAPI => {\n    if (!this.contextValue) {\n      this.contextValue = {} as CollabAPI;\n    }\n\n    this.contextValue.isCollaborating = () => this.isCollaborating;\n    this.contextValue.username = this.state.username;\n    this.contextValue.onPointerUpdate = this.onPointerUpdate;\n    this.contextValue.initializeSocketClient = this.initializeSocketClient;\n    this.contextValue.onCollabButtonClick = this.onCollabButtonClick;\n    this.contextValue.broadcastElements = this.broadcastElements;\n    return this.contextValue;\n  };\n\n  render() {\n    const { modalIsShown, username, errorMessage, activeRoomLink } = this.state;\n\n    return (\n      <>\n        {modalIsShown && (\n          <RoomDialog\n            handleClose={this.handleClose}\n            activeRoomLink={activeRoomLink}\n            username={username}\n            onUsernameChange={this.onUsernameChange}\n            onRoomCreate={this.openPortal}\n            onRoomDestroy={this.closePortal}\n            setErrorMessage={(errorMessage) => {\n              this.setState({ errorMessage });\n            }}\n            theme={this.excalidrawAPI.getAppState().theme}\n          />\n        )}\n        {errorMessage && (\n          <ErrorDialog\n            message={errorMessage}\n            onClose={() => this.setState({ errorMessage: \"\" })}\n          />\n        )}\n        <CollabContextProvider\n          value={{\n            api: this.getContextValue(),\n          }}\n        />\n      </>\n    );\n  }\n}\n\ndeclare global {\n  interface Window {\n    collab: InstanceType<typeof CollabWrapper>;\n  }\n}\n\nif (\n  process.env.NODE_ENV === ENV.TEST ||\n  process.env.NODE_ENV === ENV.DEVELOPMENT\n) {\n  window.collab = window.collab || ({} as Window[\"collab\"]);\n}\n\nexport default CollabWrapper;\n","import React from \"react\";\nimport clsx from \"clsx\";\nimport * as i18n from \"../../i18n\";\n\nexport const LanguageList = ({\n  onChange,\n  languages = i18n.languages,\n  currentLangCode = i18n.getLanguage().code,\n  floating,\n}: {\n  languages?: { code: string; label: string }[];\n  onChange: (langCode: i18n.Language[\"code\"]) => void;\n  currentLangCode?: i18n.Language[\"code\"];\n  floating?: boolean;\n}) => (\n  <React.Fragment>\n    <select\n      className={clsx(\"dropdown-select dropdown-select__language\", {\n        \"dropdown-select--floating\": floating,\n      })}\n      onChange={({ target }) => onChange(target.value)}\n      value={currentLangCode}\n      aria-label={i18n.t(\"buttons.selectLanguage\")}\n    >\n      <option key={i18n.defaultLang.code} value={i18n.defaultLang.code}>\n        {i18n.defaultLang.label}\n      </option>\n      {languages.map((lang) => (\n        <option key={lang.code} value={lang.code}>\n          {lang.label}\n        </option>\n      ))}\n    </select>\n  </React.Fragment>\n);\n","import React, { useEffect, useState } from \"react\";\nimport { debounce, getVersion, nFormatter } from \"../utils\";\nimport {\n  getElementsStorageSize,\n  getTotalStorageSize,\n} from \"./data/localStorage\";\nimport { DEFAULT_VERSION } from \"../constants\";\nimport { t } from \"../i18n\";\nimport { copyTextToSystemClipboard } from \"../clipboard\";\ntype StorageSizes = { scene: number; total: number };\n\nconst STORAGE_SIZE_TIMEOUT = 500;\n\nconst getStorageSizes = debounce((cb: (sizes: StorageSizes) => void) => {\n  cb({\n    scene: getElementsStorageSize(),\n    total: getTotalStorageSize(),\n  });\n}, STORAGE_SIZE_TIMEOUT);\n\ntype Props = {\n  setToastMessage: (message: string) => void;\n};\nconst CustomStats = (props: Props) => {\n  const [storageSizes, setStorageSizes] = useState<StorageSizes>({\n    scene: 0,\n    total: 0,\n  });\n\n  useEffect(() => {\n    getStorageSizes((sizes) => {\n      setStorageSizes(sizes);\n    });\n  });\n  useEffect(() => () => getStorageSizes.cancel(), []);\n\n  const version = getVersion();\n  let hash;\n  let timestamp;\n\n  if (version !== DEFAULT_VERSION) {\n    timestamp = version.slice(0, 16).replace(\"T\", \" \");\n    hash = version.slice(21);\n  } else {\n    timestamp = t(\"stats.versionNotAvailable\");\n  }\n\n  return (\n    <>\n      <tr>\n        <th colSpan={2}>{t(\"stats.storage\")}</th>\n      </tr>\n      <tr>\n        <td>{t(\"stats.scene\")}</td>\n        <td>{nFormatter(storageSizes.scene, 1)}</td>\n      </tr>\n      <tr>\n        <td>{t(\"stats.total\")}</td>\n        <td>{nFormatter(storageSizes.total, 1)}</td>\n      </tr>\n      <tr>\n        <th colSpan={2}>{t(\"stats.version\")}</th>\n      </tr>\n      <tr>\n        <td\n          colSpan={2}\n          style={{ textAlign: \"center\", cursor: \"pointer\" }}\n          onClick={async () => {\n            try {\n              await copyTextToSystemClipboard(getVersion());\n              props.setToastMessage(t(\"toast.copyToClipboard\"));\n            } catch {}\n          }}\n          title={t(\"stats.versionCopy\")}\n        >\n          {timestamp}\n          <br />\n          {hash}\n        </td>\n      </tr>\n    </>\n  );\n};\n\nexport default CustomStats;\n","import { createIcon } from \"../../components/icons\";\n\nexport const excalidrawPlusIcon = createIcon(\n  <>\n    <path\n      d=\"M72.652 63.598c-1.368.91-1.191 2.833-.953 4.572.702 5.104.47 5.323 1.073 7.016.649 1.826.433 2.553-.08 3.292-.406.588-1.207 1.371-1.906 1.516-.98.204-2.967.01-3.922-.246-.643-.174-1.292-.94-1.598-1.53-.389-.751-1.256-1.951-.694-3.593.56-1.64 1.325-5.374 1.363-6.108.098-1.904.02-3.934-1.085-5.014-1.104-1.082-3.941-1.055-5.739-1.038-1.723.017-3.583 1.207-5.045 1.141-1.343-.061-2.939-.686-3.728-1.536-.79-.852-1.082-2.469-1.007-3.57.074-1.1.726-2.398 1.454-3.033.727-.635 1.91-.867 2.909-.777 1.472.13 4.1 1.342 5.928 1.564 1.67.203 4.016.501 5.04-.227 1.021-.73 1.048-2.717 1.094-4.145.07-2.063-1.021-6.528-.683-8.23.22-1.098 1.709-1.696 2.717-1.979 1.007-.282 2.521-.125 3.328.285.788.398 1.499 1.29 1.516 2.173.031 1.68-1.209 5.66-1.322 7.905-.058 1.133-.61 3.124.482 3.764 1.264.74 2.95 1.778 7.1.673 1.765-.47 3.157-.689 4.62-.622 1.342.06 2.939.685 3.728 1.536.787.85 1.08 2.468 1.006 3.568-.074 1.101-.726 2.4-1.454 3.035-.727.634-1.908.866-2.908.777-1.473-.13-3.164-.68-4.88-1.248-2.526-.835-5.176-.708-6.354.079z\"\n      fill=\"currentColor\"\n    />\n    <path\n      d=\"M51.396 25.807c0 .237-.285.474-.617.474-.284 0-1.09 1.328-1.708 2.941-1.897 4.934-20.873 42.46-20.92 41.273 0-.616-.285-1.043-.76-1.043-.664 0-.759.38-.474 2.23.284 2.134.095 2.609-6.642 15.702-3.795 7.448-7.875 15.228-9.06 17.316-1.234 2.182-2.183 4.554-2.278 5.55-.142 1.708.047 1.945 4.175 5.503 2.372 2.088 5.408 4.697 6.736 5.883 5.978 5.456 8.777 7.638 9.536 7.496 1.138-.19 18.739-18.644 18.786-19.688 0-.475-.854-7.685-1.898-16.035-1.802-14.232-3.51-30.884-3.32-32.497.142-.996-.57-6.024-1.092-8.207-.426-1.708-.237-2.42 3.179-10.2 1.992-4.601 4.602-10.247 5.74-12.524 1.091-2.277 2.04-4.27 2.04-4.412 0-.142-.332-.237-.711-.237-.38 0-.712.19-.712.475zM40.485 61.245c.522 3.32 1.565 11.29 2.324 17.695 1.47 11.765 3.179 24.811 3.653 28.132.285 1.66.095 1.992-2.989 5.408-5.36 6.025-11.053 11.955-12.998 13.473l-1.803 1.423-9.25-8.634c-8.54-7.875-9.252-8.681-8.73-9.63.285-.522 2.704-4.934 5.361-9.773 2.657-4.839 6.167-11.29 7.78-14.327 1.66-3.084 3.179-5.74 3.463-5.882.332-.19.427 4.601.332 14.8-.19 15.23-.142 15.277 1.376 14.945.19 0 .332-7.686.332-17.031V74.86l4.981-9.963c2.752-5.503 5.03-9.915 5.124-9.867.095.047.57 2.846 1.044 6.215zM20.228 3.842c-3.51 2.799-8.919 7.543-13.189 11.623l-3.368 3.178.617 4.175c.332 2.277.949 6.736 1.328 9.867.427 3.132.854 6.073.996 6.5.19.57 0 .854-.521.854-.902 0-.95-.237 1.518 7.59.901 2.989 1.755 5.74 1.85 6.025.095.332.474.474.901.332.427-.19.664-.57.522-.901-.142-.38.095-.76.474-.902.522-.19.475-.569-.332-1.945-1.28-2.134-4.554-20.352-4.744-26.234-.142-4.175-.142-4.222 1.613-6.594 1.708-2.325 5.646-5.835 11.718-10.295 1.708-1.28 3.416-2.704 3.89-3.178.712-.854 1.044-.617 7.021 5.74 3.463 3.653 7.306 7.4 8.54 8.35l2.277 1.707-1.756 3.7c-.948 1.993-4.791 9.678-8.586 16.984-7.923 15.37-6.31 13.9-15.513 14.043l-5.978.047-1.992 2.277c-2.088 2.42-2.372 3.32-1.376 4.839.38.522.664 1.376.664 1.898 0 .854.332.996 2.23 1.09 1.186.048 2.277.19 2.42.333.142.142.331 3.083.474 6.547l.19 6.262-3.179 6.831c-5.266 11.386-7.353 16.604-7.353 18.312 0 .901.19 1.66.38 1.66.474 0 .474-.047 19.782-40.324 8.966-18.691 17.458-36.292 18.881-39.185 1.423-2.894 2.704-5.55 2.799-5.93.095-.427-3.178-3.7-8.397-8.303-4.696-4.174-8.824-7.97-9.203-8.396-1.091-1.329-2.704-.902-5.598 1.423zm-2.372 62.147c-.38.996-1.376 3.083-2.183 4.649-1.328 2.656-1.47 2.751-1.802 1.66-.19-.664-.332-2.61-.38-4.364-.047-3.464-.142-3.416 3.843-3.653l1.28-.048-.758 1.756zm3.985-7.59c-2.183 4.221-2.277 4.269-8.255 4.553-5.266.285-5.36.238-5.36-.759 0-.569-.19-1.328-.428-1.708-.284-.426-.094-1.186.57-2.23l1.043-1.612h4.744c2.61-.048 5.598-.237 6.642-.427 1.044-.19 1.945-.285 2.04-.237.095.047-.38 1.138-.996 2.42zm-.19-43.266c-.854.616-1.091 1.233-1.091 2.799 0 1.85.142 2.134 1.423 2.656 1.28.522 1.613.475 3.084-.522 1.945-1.328 1.992-1.66.569-3.795-1.234-1.85-2.467-2.182-3.985-1.138z\"\n      fill=\"currentColor\"\n    />\n    <path\n      d=\"M50.141 24.917c.352-.615 1.06-1.085 1.967-1.085.804 0 1.477.34 1.734.597.342.342.477.74.477 1.14 0 .089-.006.305-.119.612-.168.461-1.056 2.337-2.08 4.471-1.131 2.264-3.724 7.875-5.708 12.457-1.671 3.806-2.558 5.881-2.97 7.216-.301.975-.279 1.406-.123 2.032.558 2.33 1.27 7.704 1.122 8.73-.187 1.596 1.537 18.06 3.32 32.136 1.056 8.446 1.91 15.74 1.91 16.22l-.002.07c-.009.184-.087.607-.447 1.14-.506.747-1.932 2.414-3.805 4.476-4.242 4.672-10.806 11.46-13.673 14.059-.682.617-1.199 1.023-1.472 1.182a1.872 1.872 0 01-.612.236c-.41.077-1.225-.015-2.35-.737-1.495-.959-4.19-3.217-8.46-7.114-1.327-1.184-4.36-3.79-6.718-5.865-1.712-1.476-2.767-2.405-3.411-3.096-.677-.727-.994-1.291-1.16-1.839-.165-.544-.18-1.09-.117-1.847.104-1.1 1.103-3.737 2.466-6.15 1.182-2.08 5.247-9.833 9.031-17.26 3.34-6.491 5.06-9.853 5.906-11.859.677-1.603.696-2.113.587-2.93-.18-1.168-.195-1.884-.111-2.308.1-.511.321-.851.58-1.1.346-.331.813-.55 1.488-.55.199 0 .391.024.574.07 4.068-7.268 18.093-35.143 19.705-39.334.585-1.53 1.353-2.823 1.794-3.288.228-.24.462-.39.677-.482zM38.72 59.573a448.835 448.835 0 00-3.06 5.995l-4.823 9.646v16.63c0 8.501-.124 15.643-.287 16.987-.142 1.166-1.002 1.462-1.384 1.526l.16-.017c-.671.147-1.214.135-1.647-.047-.495-.209-1.058-.629-1.33-1.813-.332-1.439-.336-5.202-.22-14.563.04-4.272.047-7.59.016-9.984-.33.582-.666 1.188-.986 1.783-1.615 3.04-5.13 9.5-7.79 14.345-2.383 4.34-4.576 8.338-5.207 9.493.131.186.356.489.61.77 1.165 1.287 3.451 3.428 7.667 7.316l8.316 7.76.798-.63c1.917-1.495 7.517-7.35 12.808-13.295.898-.995 1.544-1.72 2-2.29.37-.464.594-.76.675-1.06.067-.247.004-.478-.051-.8l-.007-.041c-.475-3.324-2.184-16.382-3.657-28.168-.757-6.384-1.797-14.328-2.317-17.639l-.004-.023c-.089-.635-.185-1.272-.28-1.881zM19.289 2.67c1.673-1.343 3-2.096 4.04-2.364 1.537-.394 2.687.004 3.621 1.119.396.44 4.46 4.165 9.071 8.264 4.274 3.769 7.265 6.676 8.244 7.909.69.868.68 1.598.625 1.844-.002.013-.006.026-.009.038-.1.398-1.416 3.195-2.908 6.228-1.423 2.893-9.912 20.488-18.875 39.173C7.581 97.252 4.465 103.75 3.6 105.058c-.497.751-.885.854-1.111.924a1.729 1.729 0 01-.526.076c-.42 0-.964-.148-1.368-.767-.223-.342-.511-1.288-.511-2.394 0-.606.19-1.592.67-3.03.955-2.866 3.1-7.864 6.821-15.911l3.03-6.513-.178-5.89a153.908 153.908 0 00-.33-5.346c-.352-.041-.773-.081-1.14-.096-.98-.049-1.616-.131-2.03-.261-.645-.204-1.016-.535-1.267-.928-.221-.348-.358-.79-.358-1.4 0-.282-.173-.735-.377-1.016l-.04-.059c-.621-.945-.859-1.757-.79-2.608.085-1.023.72-2.222 2.283-4.034l1.607-1.836c-.218-.687-.996-3.199-1.807-5.89-1.558-4.942-2.122-6.841-2.152-7.56-.034-.83.282-1.245.57-1.51a1.53 1.53 0 01.406-.265c-.217-1.235-.55-3.498-.875-5.878a488.89 488.89 0 00-1.323-9.829l-.617-4.175a1.5 1.5 0 01.455-1.31l3.361-3.172c4.301-4.11 9.749-8.888 13.287-11.709zm-3.879 71.31c-.31.283-.612.394-.858.441a1.547 1.547 0 01-1.04-.132l.103 3.418v.018l1.795-3.746zm12.426 1.473a23.55 23.55 0 01-.225.553 43.912 43.912 0 01-.763 1.686c.328-.11.65-.094.966.015l.022.008v-2.262zm1.524-3.996l-.032.037a1.575 1.575 0 01-.862.5c.042.411.057.798 0 1.25l.894-1.787zM16.286 65.87c-.566.056-1.034.117-1.267.149-.014.118-.03.275-.035.408-.012.4-.001.889.007 1.466.006.237.014.477.024.716.49-.997.97-2.02 1.271-2.739zm4.486-3.076a4.31 4.31 0 01-.88.654c.136.22.21.469.22.721l.281-.585.38-.79zm-.299-5.017c-1.381.168-3.98.324-6.29.365h-3.956l-.594.92c-.19.298-.36.7-.429.874.215.444.399 1.073.478 1.666h.014c.771.012 1.964-.048 3.819-.148 2.63-.125 3.979-.11 4.898-.616.326-.18.561-.453.817-.83.374-.551.75-1.276 1.243-2.23zm4.52-3.77a6.345 6.345 0 01-1.098.892c.156.141.3.333.383.595l.714-1.487zm15.241-3.122c-.47.934-.941 1.866-1.41 2.789.6-.264 1.192-.034 1.288.014.079.04.308.15.517.425a27.335 27.335 0 00-.224-1.044c-.185-.74-.289-1.336-.17-2.184zM24.148 5.38c-.758.673-2.198 1.856-3.649 2.944-5.896 4.33-9.738 7.717-11.4 9.978-.594.803-.97 1.279-1.177 1.801-.316.802-.217 1.685-.143 3.852.132 4.065 1.762 14.092 3.157 20.466.555 2.535 1.023 4.46 1.383 5.059.528.9.771 1.5.842 1.889.088.484.016.86-.118 1.167a1.86 1.86 0 01-.27.446l2.687-.021c1.825-.028 3.22.008 4.349-.038.897-.038 1.587-.111 2.187-.396.71-.336 1.26-.968 1.948-2.018 1.313-2.003 2.904-5.314 5.721-10.782 3.785-7.286 7.618-14.95 8.563-16.935l1.23-2.593-1.311-.984c-1.258-.967-5.182-4.782-8.717-8.51-2.604-2.769-4.52-4.608-5.282-5.325zm-11.86 47.181l-.001-.003-.026-.064.027.067zm-1.503-1.764l.059-.024a1.07 1.07 0 00-.059.024zm42.106-24.884l-.002.022.001-.009.001-.013zm.003-.035l.002-.071-.002.071zM20.773 13.917c-1.241.896-1.713 1.74-1.713 4.015 0 1.663.252 2.444.727 3.002.334.391.822.714 1.63 1.043.743.303 1.275.437 1.771.44.735.005 1.457-.254 2.72-1.109 1.495-1.02 2.072-1.825 2.19-2.615.111-.744-.188-1.715-1.214-3.254-.872-1.307-1.805-2.006-2.727-2.266-1.036-.292-2.15-.105-3.356.723l-.028.02zm4.263 4.285c-.128-.242-.375-.69-.648-1.099-.4-.598-.691-1.03-1.123-1.056-.24-.015-.473.123-.744.308-.461.337-.461.721-.461 1.577 0 .417.04.883.058 1.064.1.052.282.142.431.203.283.115.47.216.66.218.084 0 .152-.057.255-.113.215-.115.46-.275.757-.476.311-.213.632-.472.815-.626zM19.293 2.669l-.005.003.005-.003z\"\n      fill=\"currentColor\"\n    />\n  </>,\n  { width: 89, height: 131, style: { transform: \"translateX(4px)\" } },\n);\n","import React from \"react\";\nimport { Card } from \"../../components/Card\";\nimport { ToolButton } from \"../../components/ToolButton\";\nimport { serializeAsJSON } from \"../../data/json\";\nimport { getImportedKey, createIV, generateEncryptionKey } from \"../data\";\nimport { loadFirebaseStorage } from \"../data/firebase\";\nimport { NonDeletedExcalidrawElement } from \"../../element/types\";\nimport { AppState } from \"../../types\";\nimport { nanoid } from \"nanoid\";\nimport { t } from \"../../i18n\";\nimport { excalidrawPlusIcon } from \"./icons\";\n\nconst encryptData = async (\n  key: string,\n  json: string,\n): Promise<{ blob: Blob; iv: Uint8Array }> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  const encoded = new TextEncoder().encode(json);\n  const ciphertext = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv,\n    },\n    importedKey,\n    encoded,\n  );\n\n  return { blob: new Blob([new Uint8Array(ciphertext)]), iv };\n};\n\nconst exportToExcalidrawPlus = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  const firebase = await loadFirebaseStorage();\n\n  const id = `${nanoid(12)}`;\n\n  const key = (await generateEncryptionKey())!;\n  const encryptedData = await encryptData(\n    key,\n    serializeAsJSON(elements, appState),\n  );\n\n  const blob = new Blob([encryptedData.iv, encryptedData.blob], {\n    type: \"application/octet-stream\",\n  });\n\n  await firebase\n    .storage()\n    .ref(`/migrations/scenes/${id}`)\n    .put(blob, {\n      customMetadata: {\n        data: JSON.stringify({ version: 1, name: appState.name }),\n        created: Date.now().toString(),\n      },\n    });\n\n  window.open(`https://plus.excalidraw.com/import?excalidraw=${id},${key}`);\n};\n\nexport const ExportToExcalidrawPlus: React.FC<{\n  elements: readonly NonDeletedExcalidrawElement[];\n  appState: AppState;\n  onError: (error: Error) => void;\n}> = ({ elements, appState, onError }) => {\n  return (\n    <Card color=\"indigo\">\n      <div className=\"Card-icon\">{excalidrawPlusIcon}</div>\n      <h2>Excalidraw+</h2>\n      <div className=\"Card-details\">\n        {t(\"exportDialog.excalidrawplus_description\")}\n      </div>\n      <ToolButton\n        className=\"Card-button\"\n        type=\"button\"\n        title={t(\"exportDialog.excalidrawplus_button\")}\n        aria-label={t(\"exportDialog.excalidrawplus_button\")}\n        showAriaLabel={true}\n        onClick={async () => {\n          try {\n            await exportToExcalidrawPlus(elements, appState);\n          } catch (error) {\n            console.error(error);\n            onError(new Error(t(\"exportDialog.excalidrawplus_exportError\")));\n          }\n        }}\n      />\n    </Card>\n  );\n};\n","import LanguageDetector from \"i18next-browser-languagedetector\";\nimport React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { trackEvent } from \"../analytics\";\nimport { getDefaultAppState } from \"../appState\";\nimport { ErrorDialog } from \"../components/ErrorDialog\";\nimport { TopErrorBoundary } from \"../components/TopErrorBoundary\";\nimport {\n  APP_NAME,\n  EVENT,\n  STORAGE_KEYS,\n  TITLE_TIMEOUT,\n  URL_HASH_KEYS,\n  VERSION_TIMEOUT,\n} from \"../constants\";\nimport { loadFromBlob } from \"../data/blob\";\nimport { ImportedDataState } from \"../data/types\";\nimport {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { useCallbackRefState } from \"../hooks/useCallbackRefState\";\nimport { Language, t } from \"../i18n\";\nimport Excalidraw, {\n  defaultLang,\n  languages,\n} from \"../packages/excalidraw/index\";\nimport { AppState, LibraryItems, ExcalidrawImperativeAPI } from \"../types\";\nimport {\n  debounce,\n  getVersion,\n  ResolvablePromise,\n  resolvablePromise,\n} from \"../utils\";\nimport { SAVE_TO_LOCAL_STORAGE_TIMEOUT } from \"./app_constants\";\nimport CollabWrapper, {\n  CollabAPI,\n  CollabContext,\n  CollabContextConsumer,\n} from \"./collab/CollabWrapper\";\nimport { LanguageList } from \"./components/LanguageList\";\nimport { exportToBackend, getCollaborationLinkData, loadScene } from \"./data\";\nimport {\n  importFromLocalStorage,\n  saveToLocalStorage,\n} from \"./data/localStorage\";\nimport CustomStats from \"./CustomStats\";\nimport { restoreAppState, RestoredDataState } from \"../data/restore\";\nimport { Tooltip } from \"../components/Tooltip\";\nimport { shield } from \"../components/icons\";\n\nimport \"./index.scss\";\nimport { ExportToExcalidrawPlus } from \"./components/ExportToExcalidrawPlus\";\n\nconst languageDetector = new LanguageDetector();\nlanguageDetector.init({\n  languageUtils: {\n    formatLanguageCode: (langCode: Language[\"code\"]) => langCode,\n    isWhitelisted: () => true,\n  },\n  checkWhitelist: false,\n});\n\nconst saveDebounced = debounce(\n  (elements: readonly ExcalidrawElement[], state: AppState) => {\n    saveToLocalStorage(elements, state);\n  },\n  SAVE_TO_LOCAL_STORAGE_TIMEOUT,\n);\n\nconst onBlur = () => {\n  saveDebounced.flush();\n};\n\nconst initializeScene = async (opts: {\n  collabAPI: CollabAPI;\n}): Promise<ImportedDataState | null> => {\n  const searchParams = new URLSearchParams(window.location.search);\n  const id = searchParams.get(\"id\");\n  const jsonBackendMatch = window.location.hash.match(\n    /^#json=([0-9]+),([a-zA-Z0-9_-]+)$/,\n  );\n  const externalUrlMatch = window.location.hash.match(/^#url=(.*)$/);\n\n  const localDataState = importFromLocalStorage();\n\n  let scene: RestoredDataState & {\n    scrollToContent?: boolean;\n  } = await loadScene(null, null, localDataState);\n\n  let roomLinkData = getCollaborationLinkData(window.location.href);\n  const isExternalScene = !!(id || jsonBackendMatch || roomLinkData);\n  if (isExternalScene) {\n    if (\n      // don't prompt if scene is empty\n      !scene.elements.length ||\n      // don't prompt for collab scenes because we don't override local storage\n      roomLinkData ||\n      // otherwise, prompt whether user wants to override current scene\n      window.confirm(t(\"alerts.loadSceneOverridePrompt\"))\n    ) {\n      // Backwards compatibility with legacy url format\n      if (id) {\n        scene = await loadScene(id, null, localDataState);\n      } else if (jsonBackendMatch) {\n        scene = await loadScene(\n          jsonBackendMatch[1],\n          jsonBackendMatch[2],\n          localDataState,\n        );\n      }\n      scene.scrollToContent = true;\n      if (!roomLinkData) {\n        window.history.replaceState({}, APP_NAME, window.location.origin);\n      }\n    } else {\n      // https://github.com/excalidraw/excalidraw/issues/1919\n      if (document.hidden) {\n        return new Promise((resolve, reject) => {\n          window.addEventListener(\n            \"focus\",\n            () => initializeScene(opts).then(resolve).catch(reject),\n            {\n              once: true,\n            },\n          );\n        });\n      }\n\n      roomLinkData = null;\n      window.history.replaceState({}, APP_NAME, window.location.origin);\n    }\n  } else if (externalUrlMatch) {\n    window.history.replaceState({}, APP_NAME, window.location.origin);\n\n    const url = externalUrlMatch[1];\n    try {\n      const request = await fetch(window.decodeURIComponent(url));\n      const data = await loadFromBlob(await request.blob(), null, null);\n      if (\n        !scene.elements.length ||\n        window.confirm(t(\"alerts.loadSceneOverridePrompt\"))\n      ) {\n        return data;\n      }\n    } catch (error) {\n      return {\n        appState: {\n          errorMessage: t(\"alerts.invalidSceneUrl\"),\n        },\n      };\n    }\n  }\n\n  if (roomLinkData) {\n    return opts.collabAPI.initializeSocketClient(roomLinkData);\n  } else if (scene) {\n    return scene;\n  }\n  return null;\n};\n\nconst PlusLinkJSX = (\n  <p style={{ direction: \"ltr\", unicodeBidi: \"embed\" }}>\n    Introducing Excalidraw+\n    <br />\n    <a\n      href=\"https://plus.excalidraw.com/?utm_source=excalidraw&utm_medium=banner&utm_campaign=launch\"\n      target=\"_blank\"\n      rel=\"noreferrer\"\n    >\n      Try out now!\n    </a>\n  </p>\n);\n\nconst ExcalidrawWrapper = () => {\n  const [errorMessage, setErrorMessage] = useState(\"\");\n  const currentLangCode = languageDetector.detect() || defaultLang.code;\n  const [langCode, setLangCode] = useState(currentLangCode);\n\n  // initial state\n  // ---------------------------------------------------------------------------\n\n  const initialStatePromiseRef = useRef<{\n    promise: ResolvablePromise<ImportedDataState | null>;\n  }>({ promise: null! });\n  if (!initialStatePromiseRef.current.promise) {\n    initialStatePromiseRef.current.promise = resolvablePromise<ImportedDataState | null>();\n  }\n\n  useEffect(() => {\n    // Delayed so that the app has a time to load the latest SW\n    setTimeout(() => {\n      trackEvent(\"load\", \"version\", getVersion());\n    }, VERSION_TIMEOUT);\n  }, []);\n\n  const [\n    excalidrawAPI,\n    excalidrawRefCallback,\n  ] = useCallbackRefState<ExcalidrawImperativeAPI>();\n\n  const collabAPI = useContext(CollabContext)?.api;\n\n  useEffect(() => {\n    if (!collabAPI || !excalidrawAPI) {\n      return;\n    }\n\n    initializeScene({ collabAPI }).then((scene) => {\n      if (scene) {\n        try {\n          scene.libraryItems =\n            JSON.parse(\n              localStorage.getItem(\n                STORAGE_KEYS.LOCAL_STORAGE_LIBRARY,\n              ) as string,\n            ) || [];\n        } catch (e) {\n          console.error(e);\n        }\n      }\n      initialStatePromiseRef.current.promise.resolve(scene);\n    });\n\n    const onHashChange = (event: HashChangeEvent) => {\n      event.preventDefault();\n      const hash = new URLSearchParams(window.location.hash.slice(1));\n      const libraryUrl = hash.get(URL_HASH_KEYS.addLibrary);\n      if (libraryUrl) {\n        // If hash changed and it contains library url, import it and replace\n        // the url to its previous state (important in case of collaboration\n        // and similar).\n        // Using history API won't trigger another hashchange.\n        window.history.replaceState({}, \"\", event.oldURL);\n        excalidrawAPI.importLibrary(libraryUrl, hash.get(\"token\"));\n      } else {\n        initializeScene({ collabAPI }).then((scene) => {\n          if (scene) {\n            excalidrawAPI.updateScene({\n              ...scene,\n              appState: restoreAppState(scene.appState, null),\n            });\n          }\n        });\n      }\n    };\n\n    const titleTimeout = setTimeout(\n      () => (document.title = APP_NAME),\n      TITLE_TIMEOUT,\n    );\n    window.addEventListener(EVENT.HASHCHANGE, onHashChange, false);\n    window.addEventListener(EVENT.UNLOAD, onBlur, false);\n    window.addEventListener(EVENT.BLUR, onBlur, false);\n    return () => {\n      window.removeEventListener(EVENT.HASHCHANGE, onHashChange, false);\n      window.removeEventListener(EVENT.UNLOAD, onBlur, false);\n      window.removeEventListener(EVENT.BLUR, onBlur, false);\n      clearTimeout(titleTimeout);\n    };\n  }, [collabAPI, excalidrawAPI]);\n\n  useEffect(() => {\n    languageDetector.cacheUserLanguage(langCode);\n  }, [langCode]);\n\n  const onChange = (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState,\n  ) => {\n    if (collabAPI?.isCollaborating()) {\n      collabAPI.broadcastElements(elements);\n    } else {\n      // collab scenes are persisted to the server, so we don't have to persist\n      // them locally, which has the added benefit of not overwriting whatever\n      // the user was working on before joining\n      saveDebounced(elements, appState);\n    }\n  };\n\n  const onExportToBackend = async (\n    exportedElements: readonly NonDeletedExcalidrawElement[],\n    appState: AppState,\n    canvas: HTMLCanvasElement | null,\n  ) => {\n    if (exportedElements.length === 0) {\n      return window.alert(t(\"alerts.cannotExportEmptyCanvas\"));\n    }\n    if (canvas) {\n      try {\n        await exportToBackend(exportedElements, {\n          ...appState,\n          viewBackgroundColor: appState.exportBackground\n            ? appState.viewBackgroundColor\n            : getDefaultAppState().viewBackgroundColor,\n        });\n      } catch (error) {\n        if (error.name !== \"AbortError\") {\n          const { width, height } = canvas;\n          console.error(error, { width, height });\n          setErrorMessage(error.message);\n        }\n      }\n    }\n  };\n\n  const renderTopRightUI = useCallback(\n    (isMobile: boolean, appState: AppState) => {\n      return (\n        <div\n          style={{\n            width: \"24ch\",\n            fontSize: \"0.7em\",\n            textAlign: \"center\",\n          }}\n        >\n          {/* <GitHubCorner theme={appState.theme} dir={document.dir} /> */}\n          {/* FIXME remove after 2021-05-20 */}\n          {PlusLinkJSX}\n        </div>\n      );\n    },\n    [],\n  );\n\n  const renderFooter = useCallback(\n    (isMobile: boolean) => {\n      const renderEncryptedIcon = () => (\n        <a\n          className=\"encrypted-icon tooltip\"\n          href=\"https://blog.excalidraw.com/end-to-end-encryption/\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          aria-label={t(\"encrypted.link\")}\n        >\n          <Tooltip label={t(\"encrypted.tooltip\")} long={true}>\n            {shield}\n          </Tooltip>\n        </a>\n      );\n\n      const renderLanguageList = () => (\n        <LanguageList\n          onChange={(langCode) => {\n            setLangCode(langCode);\n          }}\n          languages={languages}\n          floating={!isMobile}\n          currentLangCode={langCode}\n        />\n      );\n      if (isMobile) {\n        const isTinyDevice = window.innerWidth < 362;\n        return (\n          <div\n            style={{\n              display: \"flex\",\n              flexDirection: isTinyDevice ? \"column\" : \"row\",\n            }}\n          >\n            <fieldset>\n              <legend>{t(\"labels.language\")}</legend>\n              {renderLanguageList()}\n            </fieldset>\n            {/* FIXME remove after 2021-05-20 */}\n            <div\n              style={{\n                width: \"24ch\",\n                fontSize: \"0.7em\",\n                textAlign: \"center\",\n                marginTop: isTinyDevice ? 16 : undefined,\n                marginLeft: \"auto\",\n                marginRight: isTinyDevice ? \"auto\" : undefined,\n                padding: \"4px 2px\",\n                border: \"1px dashed #aaa\",\n                borderRadius: 12,\n              }}\n            >\n              {PlusLinkJSX}\n            </div>\n          </div>\n        );\n      }\n      return (\n        <>\n          {renderEncryptedIcon()}\n          {renderLanguageList()}\n        </>\n      );\n    },\n    [langCode],\n  );\n\n  const renderCustomStats = () => {\n    return (\n      <CustomStats\n        setToastMessage={(message) => excalidrawAPI!.setToastMessage(message)}\n      />\n    );\n  };\n\n  const onLibraryChange = async (items: LibraryItems) => {\n    if (!items.length) {\n      localStorage.removeItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY);\n      return;\n    }\n    const serializedItems = JSON.stringify(items);\n    localStorage.setItem(STORAGE_KEYS.LOCAL_STORAGE_LIBRARY, serializedItems);\n  };\n\n  return (\n    <>\n      <Excalidraw\n        ref={excalidrawRefCallback}\n        onChange={onChange}\n        initialData={initialStatePromiseRef.current.promise}\n        onCollabButtonClick={collabAPI?.onCollabButtonClick}\n        isCollaborating={collabAPI?.isCollaborating()}\n        onPointerUpdate={collabAPI?.onPointerUpdate}\n        UIOptions={{\n          canvasActions: {\n            export: {\n              onExportToBackend,\n              renderCustomUI: (elements, appState) => {\n                return (\n                  <ExportToExcalidrawPlus\n                    elements={elements}\n                    appState={appState}\n                    onError={(error) => {\n                      excalidrawAPI?.updateScene({\n                        appState: {\n                          errorMessage: error.message,\n                        },\n                      });\n                    }}\n                  />\n                );\n              },\n            },\n          },\n        }}\n        renderTopRightUI={renderTopRightUI}\n        renderFooter={renderFooter}\n        langCode={langCode}\n        renderCustomStats={renderCustomStats}\n        detectScroll={false}\n        handleKeyboardGlobally={true}\n        onLibraryChange={onLibraryChange}\n        autoFocus={true}\n      />\n      {excalidrawAPI && <CollabWrapper excalidrawAPI={excalidrawAPI} />}\n      {errorMessage && (\n        <ErrorDialog\n          message={errorMessage}\n          onClose={() => setErrorMessage(\"\")}\n        />\n      )}\n    </>\n  );\n};\n\nconst ExcalidrawApp = () => {\n  return (\n    <TopErrorBoundary>\n      <CollabContextConsumer>\n        <ExcalidrawWrapper />\n      </CollabContextConsumer>\n    </TopErrorBoundary>\n  );\n};\n\nexport default ExcalidrawApp;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport const register = (config?: Config) => {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.info(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\",\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n};\n\nconst registerValidSW = (swUrl: string, config?: Config) => {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n\n              console.info(\n                \"New content is available and will be used when all tabs for this page are closed.\",\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n\n              console.info(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n};\n\nconst checkValidServiceWorker = (swUrl: string, config?: Config) => {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch((error) => {\n      console.info(\n        \"No internet connection found. App is running in offline mode.\",\n        error.message,\n      );\n    });\n};\n\nexport const unregister = () => {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n};\n","import { register as registerServiceWorker } from \"../serviceWorker\";\nimport { EVENT } from \"../constants\";\n\n// On Apple mobile devices add the proprietary app icon and splashscreen markup.\n// No one should have to do this manually, and eventually this annoyance will\n// go away once https://bugs.webkit.org/show_bug.cgi?id=183937 is fixed.\nif (\n  /\\b(iPad|iPhone|iPod|Safari)\\b/.test(navigator.userAgent) &&\n  !matchMedia(\"(display-mode: standalone)\").matches\n) {\n  import(/* webpackChunkName: \"pwacompat\" */ \"pwacompat\");\n}\n\nregisterServiceWorker({\n  onUpdate: (registration) => {\n    const waitingServiceWorker = registration.waiting;\n    if (waitingServiceWorker) {\n      waitingServiceWorker.addEventListener(\n        EVENT.STATE_CHANGE,\n        (event: Event) => {\n          const target = event.target as ServiceWorker;\n          const state = target.state as ServiceWorkerState;\n          if (state === \"activated\") {\n            window.location.reload();\n          }\n        },\n      );\n      waitingServiceWorker.postMessage({ type: \"SKIP_WAITING\" });\n    }\n  },\n});\n","import * as Sentry from \"@sentry/browser\";\nimport * as SentryIntegrations from \"@sentry/integrations\";\n\nconst SentryEnvHostnameMap: { [key: string]: string } = {\n  \"excalidraw.com\": \"production\",\n  \"vercel.app\": \"staging\",\n};\n\nconst REACT_APP_DISABLE_SENTRY =\n  process.env.REACT_APP_DISABLE_SENTRY === \"true\";\n\n// Disable Sentry locally or inside the Docker to avoid noise/respect privacy\nconst onlineEnv =\n  !REACT_APP_DISABLE_SENTRY &&\n  Object.keys(SentryEnvHostnameMap).find(\n    (item) => window.location.hostname.indexOf(item) >= 0,\n  );\n\nSentry.init({\n  dsn: onlineEnv\n    ? \"https://7bfc596a5bf945eda6b660d3015a5460@sentry.io/5179260\"\n    : undefined,\n  environment: onlineEnv ? SentryEnvHostnameMap[onlineEnv] : undefined,\n  release: process.env.REACT_APP_GIT_SHA,\n  ignoreErrors: [\n    \"undefined is not an object (evaluating 'window.__pad.performLoop')\", // Only happens on Safari, but spams our servers. Doesn't break anything\n  ],\n  integrations: [\n    new SentryIntegrations.CaptureConsole({\n      levels: [\"error\"],\n    }),\n  ],\n  beforeSend(event) {\n    if (event.request?.url) {\n      event.request.url = event.request.url.replace(/#.*$/, \"\");\n    }\n    return event;\n  },\n});\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport ExcalidrawApp from \"./excalidraw-app\";\n\nimport \"./excalidraw-app/pwa\";\nimport \"./excalidraw-app/sentry\";\nwindow.__EXCALIDRAW_SHA__ = process.env.REACT_APP_GIT_SHA;\n\nReactDOM.render(<ExcalidrawApp />, document.getElementById(\"root\"));\n"],"sourceRoot":""}